<?php // target.php

/** @var PhpFuzzer\Fuzzer $fuzzer */

require './tolerant-php-parser-master/vendor/autoload.php';

// Required: The target accepts a single input string and runs it through the tested
//           library. The target is allowed to throw normal Exceptions (which are ignored),
//           but Error exceptions are considered as a found bug.
$parser = new Microsoft\PhpParser\Parser();
$fuzzer->setTarget(function(string $input) use($parser) {
    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1; $parser->parseSourceFile($input); }
});

// Optional: Many targets don't exhibit bugs on large inputs that can't also be
//           produced with small inputs. Limiting the length may improve performance.
$fuzzer->setMaxLen(1024);
// Optional: A dictionary can be used to provide useful fragments to the fuzzer,
//           such as language keywords. This is particularly important if these
//           cannot be easily discovered by the fuzzer, because they are handled
//           by a non-instrumented PHP extension function such as token_get_all().
$fuzzer->addDictionary('example/php.dict');
?>
<?php

// autoload.php @generated by Composer

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit718e12bccf6cad6e9086d8f64e94517b::getLoader();
<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInit718e12bccf6cad6e9086d8f64e94517b
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 4; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 4; if ('Composer\Autoload\ClassLoader' === $class) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 2; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 2; require __DIR__ . '/ClassLoader.php'; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 3; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 3; }
    }

    public static function getLoader()
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 24; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 24; if (null !== self::$loader) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 5; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 5; return self::$loader; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 6; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 6; }

        spl_autoload_register(array('ComposerAutoloaderInit718e12bccf6cad6e9086d8f64e94517b', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        spl_autoload_unregister(array('ComposerAutoloaderInit718e12bccf6cad6e9086d8f64e94517b', 'loadClassLoader'));

        $useStaticLoader = PHP_VERSION_ID >= 50600 && \PhpFuzzer\FuzzingContext::traceBlock(7, !defined('HHVM_VERSION')) && (\PhpFuzzer\FuzzingContext::traceBlock(9, !function_exists('zend_loader_file_encoded') || \PhpFuzzer\FuzzingContext::traceBlock(8, !zend_loader_file_encoded())));
        if ($useStaticLoader) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 17; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 17; require_once __DIR__ . '/autoload_static.php'; }

            call_user_func(\Composer\Autoload\ComposerStaticInit718e12bccf6cad6e9086d8f64e94517b::getInitializer($loader));
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 16; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 16; $map = require __DIR__ . '/autoload_namespaces.php'; }
            foreach ($map as $namespace => $path) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 10; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 10; $loader->set($namespace, $path); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 11; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 11;

            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 12; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 12; $loader->setPsr4($namespace, $path); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 13; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 13;

            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 14; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 14; $loader->addClassMap($classMap); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 15; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 15;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 18; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 18;

        $loader->register(true);

        if ($useStaticLoader) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 20; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 20; $includeFiles = Composer\Autoload\ComposerStaticInit718e12bccf6cad6e9086d8f64e94517b::$files; }
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 19; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 19; $includeFiles = require __DIR__ . '/autoload_files.php'; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 21; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 21;
        foreach ($includeFiles as $fileIdentifier => $file) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 22; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 22; composerRequire718e12bccf6cad6e9086d8f64e94517b($fileIdentifier, $file); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 23; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 23;

        return $loader;
    }
}

function composerRequire718e12bccf6cad6e9086d8f64e94517b($fileIdentifier, $file)
{
    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 27; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 27; if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 25; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 25; require $file; }

        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 26; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 26; }
}
<?php

// autoload_static.php @generated by Composer

namespace Composer\Autoload;

class ComposerStaticInit718e12bccf6cad6e9086d8f64e94517b
{
    public static $files = array (
        '320cde22f66dd4f5d3fd621d3e88b98f' => __DIR__ . '/..' . '/symfony/polyfill-ctype/bootstrap.php',
        '6124b4c8570aa390c21fafd04a26c69f' => __DIR__ . '/..' . '/myclabs/deep-copy/src/DeepCopy/deep_copy.php',
    );

    public static $prefixLengthsPsr4 = array (
        'p' => 
        array (
            'phpDocumentor\\Reflection\\' => 25,
        ),
        'W' => 
        array (
            'Webmozart\\Assert\\' => 17,
        ),
        'S' => 
        array (
            'Symfony\\Polyfill\\Ctype\\' => 23,
        ),
        'P' => 
        array (
            'Prophecy\\' => 9,
        ),
        'M' => 
        array (
            'Microsoft\\PhpParser\\' => 20,
        ),
        'D' => 
        array (
            'Doctrine\\Instantiator\\' => 22,
            'DeepCopy\\' => 9,
        ),
    );

    public static $prefixDirsPsr4 = array (
        'phpDocumentor\\Reflection\\' => 
        array (
            0 => __DIR__ . '/..' . '/phpdocumentor/reflection-common/src',
            1 => __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src',
            2 => __DIR__ . '/..' . '/phpdocumentor/type-resolver/src',
        ),
        'Webmozart\\Assert\\' => 
        array (
            0 => __DIR__ . '/..' . '/webmozart/assert/src',
        ),
        'Symfony\\Polyfill\\Ctype\\' => 
        array (
            0 => __DIR__ . '/..' . '/symfony/polyfill-ctype',
        ),
        'Prophecy\\' => 
        array (
            0 => __DIR__ . '/..' . '/phpspec/prophecy/src/Prophecy',
        ),
        'Microsoft\\PhpParser\\' => 
        array (
            0 => __DIR__ . '/../..' . '/src',
        ),
        'Doctrine\\Instantiator\\' => 
        array (
            0 => __DIR__ . '/..' . '/doctrine/instantiator/src/Doctrine/Instantiator',
        ),
        'DeepCopy\\' => 
        array (
            0 => __DIR__ . '/..' . '/myclabs/deep-copy/src/DeepCopy',
        ),
    );

    public static $classMap = array (
        'File_Iterator' => __DIR__ . '/..' . '/phpunit/php-file-iterator/src/Iterator.php',
        'File_Iterator_Facade' => __DIR__ . '/..' . '/phpunit/php-file-iterator/src/Facade.php',
        'File_Iterator_Factory' => __DIR__ . '/..' . '/phpunit/php-file-iterator/src/Factory.php',
        'PHPUnit\\Exception' => __DIR__ . '/..' . '/phpunit/phpunit/src/Exception.php',
        'PHPUnit\\Framework\\Assert' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Assert.php',
        'PHPUnit\\Framework\\AssertionFailedError' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/AssertionFailedError.php',
        'PHPUnit\\Framework\\BaseTestListener' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/BaseTestListener.php',
        'PHPUnit\\Framework\\CodeCoverageException' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/CodeCoverageException.php',
        'PHPUnit\\Framework\\Constraint\\ArrayHasKey' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/ArrayHasKey.php',
        'PHPUnit\\Framework\\Constraint\\ArraySubset' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/ArraySubset.php',
        'PHPUnit\\Framework\\Constraint\\Attribute' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/Attribute.php',
        'PHPUnit\\Framework\\Constraint\\Callback' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/Callback.php',
        'PHPUnit\\Framework\\Constraint\\ClassHasAttribute' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/ClassHasAttribute.php',
        'PHPUnit\\Framework\\Constraint\\ClassHasStaticAttribute' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/ClassHasStaticAttribute.php',
        'PHPUnit\\Framework\\Constraint\\Composite' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/Composite.php',
        'PHPUnit\\Framework\\Constraint\\Constraint' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/Constraint.php',
        'PHPUnit\\Framework\\Constraint\\Count' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/Count.php',
        'PHPUnit\\Framework\\Constraint\\DirectoryExists' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/DirectoryExists.php',
        'PHPUnit\\Framework\\Constraint\\Exception' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/Exception.php',
        'PHPUnit\\Framework\\Constraint\\ExceptionCode' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/ExceptionCode.php',
        'PHPUnit\\Framework\\Constraint\\ExceptionMessage' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/ExceptionMessage.php',
        'PHPUnit\\Framework\\Constraint\\ExceptionMessageRegularExpression' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/ExceptionMessageRegularExpression.php',
        'PHPUnit\\Framework\\Constraint\\FileExists' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/FileExists.php',
        'PHPUnit\\Framework\\Constraint\\GreaterThan' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/GreaterThan.php',
        'PHPUnit\\Framework\\Constraint\\IsAnything' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsAnything.php',
        'PHPUnit\\Framework\\Constraint\\IsEmpty' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsEmpty.php',
        'PHPUnit\\Framework\\Constraint\\IsEqual' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsEqual.php',
        'PHPUnit\\Framework\\Constraint\\IsFalse' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsFalse.php',
        'PHPUnit\\Framework\\Constraint\\IsFinite' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsFinite.php',
        'PHPUnit\\Framework\\Constraint\\IsIdentical' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsIdentical.php',
        'PHPUnit\\Framework\\Constraint\\IsInfinite' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsInfinite.php',
        'PHPUnit\\Framework\\Constraint\\IsInstanceOf' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsInstanceOf.php',
        'PHPUnit\\Framework\\Constraint\\IsJson' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsJson.php',
        'PHPUnit\\Framework\\Constraint\\IsNan' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsNan.php',
        'PHPUnit\\Framework\\Constraint\\IsNull' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsNull.php',
        'PHPUnit\\Framework\\Constraint\\IsReadable' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsReadable.php',
        'PHPUnit\\Framework\\Constraint\\IsTrue' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsTrue.php',
        'PHPUnit\\Framework\\Constraint\\IsType' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsType.php',
        'PHPUnit\\Framework\\Constraint\\IsWritable' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/IsWritable.php',
        'PHPUnit\\Framework\\Constraint\\JsonMatches' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/JsonMatches.php',
        'PHPUnit\\Framework\\Constraint\\JsonMatchesErrorMessageProvider' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/JsonMatchesErrorMessageProvider.php',
        'PHPUnit\\Framework\\Constraint\\LessThan' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/LessThan.php',
        'PHPUnit\\Framework\\Constraint\\LogicalAnd' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/LogicalAnd.php',
        'PHPUnit\\Framework\\Constraint\\LogicalNot' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/LogicalNot.php',
        'PHPUnit\\Framework\\Constraint\\LogicalOr' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/LogicalOr.php',
        'PHPUnit\\Framework\\Constraint\\LogicalXor' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/LogicalXor.php',
        'PHPUnit\\Framework\\Constraint\\ObjectHasAttribute' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/ObjectHasAttribute.php',
        'PHPUnit\\Framework\\Constraint\\RegularExpression' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/RegularExpression.php',
        'PHPUnit\\Framework\\Constraint\\SameSize' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/SameSize.php',
        'PHPUnit\\Framework\\Constraint\\StringContains' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/StringContains.php',
        'PHPUnit\\Framework\\Constraint\\StringEndsWith' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/StringEndsWith.php',
        'PHPUnit\\Framework\\Constraint\\StringMatchesFormatDescription' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/StringMatchesFormatDescription.php',
        'PHPUnit\\Framework\\Constraint\\StringStartsWith' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/StringStartsWith.php',
        'PHPUnit\\Framework\\Constraint\\TraversableContains' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/TraversableContains.php',
        'PHPUnit\\Framework\\Constraint\\TraversableContainsOnly' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Constraint/TraversableContainsOnly.php',
        'PHPUnit\\Framework\\CoveredCodeNotExecutedException' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/CoveredCodeNotExecutedException.php',
        'PHPUnit\\Framework\\DataProviderTestSuite' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/DataProviderTestSuite.php',
        'PHPUnit\\Framework\\Error\\Deprecated' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Error/Deprecated.php',
        'PHPUnit\\Framework\\Error\\Error' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Error/Error.php',
        'PHPUnit\\Framework\\Error\\Notice' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Error/Notice.php',
        'PHPUnit\\Framework\\Error\\Warning' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Error/Warning.php',
        'PHPUnit\\Framework\\Exception' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Exception.php',
        'PHPUnit\\Framework\\ExceptionWrapper' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/ExceptionWrapper.php',
        'PHPUnit\\Framework\\ExpectationFailedException' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/ExpectationFailedException.php',
        'PHPUnit\\Framework\\IncompleteTest' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/IncompleteTest.php',
        'PHPUnit\\Framework\\IncompleteTestCase' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/IncompleteTestCase.php',
        'PHPUnit\\Framework\\IncompleteTestError' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/IncompleteTestError.php',
        'PHPUnit\\Framework\\InvalidCoversTargetException' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/InvalidCoversTargetException.php',
        'PHPUnit\\Framework\\MissingCoversAnnotationException' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/MissingCoversAnnotationException.php',
        'PHPUnit\\Framework\\MockObject\\BadMethodCallException' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Exception/BadMethodCallException.php',
        'PHPUnit\\Framework\\MockObject\\Builder\\Identity' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Builder/Identity.php',
        'PHPUnit\\Framework\\MockObject\\Builder\\InvocationMocker' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Builder/InvocationMocker.php',
        'PHPUnit\\Framework\\MockObject\\Builder\\Match' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Builder/Match.php',
        'PHPUnit\\Framework\\MockObject\\Builder\\MethodNameMatch' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Builder/MethodNameMatch.php',
        'PHPUnit\\Framework\\MockObject\\Builder\\NamespaceMatch' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Builder/NamespaceMatch.php',
        'PHPUnit\\Framework\\MockObject\\Builder\\ParametersMatch' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Builder/ParametersMatch.php',
        'PHPUnit\\Framework\\MockObject\\Builder\\Stub' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Builder/Stub.php',
        'PHPUnit\\Framework\\MockObject\\Exception' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Exception/Exception.php',
        'PHPUnit\\Framework\\MockObject\\Generator' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Generator.php',
        'PHPUnit\\Framework\\MockObject\\Invocation' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Invocation/Invocation.php',
        'PHPUnit\\Framework\\MockObject\\InvocationMocker' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/InvocationMocker.php',
        'PHPUnit\\Framework\\MockObject\\Invocation\\ObjectInvocation' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Invocation/ObjectInvocation.php',
        'PHPUnit\\Framework\\MockObject\\Invocation\\StaticInvocation' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Invocation/StaticInvocation.php',
        'PHPUnit\\Framework\\MockObject\\Invokable' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Invokable.php',
        'PHPUnit\\Framework\\MockObject\\Matcher' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\AnyInvokedCount' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/AnyInvokedCount.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\AnyParameters' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/AnyParameters.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\ConsecutiveParameters' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/ConsecutiveParameters.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\Invocation' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/Invocation.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\InvokedAtIndex' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/InvokedAtIndex.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\InvokedAtLeastCount' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/InvokedAtLeastCount.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\InvokedAtLeastOnce' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/InvokedAtLeastOnce.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\InvokedAtMostCount' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/InvokedAtMostCount.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\InvokedCount' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/InvokedCount.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\InvokedRecorder' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/InvokedRecorder.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\MethodName' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/MethodName.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\Parameters' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/Parameters.php',
        'PHPUnit\\Framework\\MockObject\\Matcher\\StatelessInvocation' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Matcher/StatelessInvocation.php',
        'PHPUnit\\Framework\\MockObject\\MockBuilder' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/MockBuilder.php',
        'PHPUnit\\Framework\\MockObject\\MockObject' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/ForwardCompatibility/MockObject.php',
        'PHPUnit\\Framework\\MockObject\\RuntimeException' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Exception/RuntimeException.php',
        'PHPUnit\\Framework\\MockObject\\Stub' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\ConsecutiveCalls' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/ConsecutiveCalls.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\Exception' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/Exception.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\MatcherCollection' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/MatcherCollection.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\ReturnArgument' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/ReturnArgument.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\ReturnCallback' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/ReturnCallback.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\ReturnReference' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/ReturnReference.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\ReturnSelf' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/ReturnSelf.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\ReturnStub' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/ReturnStub.php',
        'PHPUnit\\Framework\\MockObject\\Stub\\ReturnValueMap' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Stub/ReturnValueMap.php',
        'PHPUnit\\Framework\\MockObject\\Verifiable' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/Verifiable.php',
        'PHPUnit\\Framework\\OutputError' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/OutputError.php',
        'PHPUnit\\Framework\\RiskyTest' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/RiskyTest.php',
        'PHPUnit\\Framework\\RiskyTestError' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/RiskyTestError.php',
        'PHPUnit\\Framework\\SelfDescribing' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/SelfDescribing.php',
        'PHPUnit\\Framework\\SkippedTest' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/SkippedTest.php',
        'PHPUnit\\Framework\\SkippedTestCase' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/SkippedTestCase.php',
        'PHPUnit\\Framework\\SkippedTestError' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/SkippedTestError.php',
        'PHPUnit\\Framework\\SkippedTestSuiteError' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/SkippedTestSuiteError.php',
        'PHPUnit\\Framework\\SyntheticError' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/SyntheticError.php',
        'PHPUnit\\Framework\\Test' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Test.php',
        'PHPUnit\\Framework\\TestCase' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/TestCase.php',
        'PHPUnit\\Framework\\TestFailure' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/TestFailure.php',
        'PHPUnit\\Framework\\TestListener' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/TestListener.php',
        'PHPUnit\\Framework\\TestListenerDefaultImplementation' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/TestListenerDefaultImplementation.php',
        'PHPUnit\\Framework\\TestResult' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/TestResult.php',
        'PHPUnit\\Framework\\TestSuite' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/TestSuite.php',
        'PHPUnit\\Framework\\TestSuiteIterator' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/TestSuiteIterator.php',
        'PHPUnit\\Framework\\UnintentionallyCoveredCodeError' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/UnintentionallyCoveredCodeError.php',
        'PHPUnit\\Framework\\Warning' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/Warning.php',
        'PHPUnit\\Framework\\WarningTestCase' => __DIR__ . '/..' . '/phpunit/phpunit/src/Framework/WarningTestCase.php',
        'PHPUnit\\Runner\\BaseTestRunner' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/BaseTestRunner.php',
        'PHPUnit\\Runner\\Exception' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/Exception.php',
        'PHPUnit\\Runner\\Filter\\ExcludeGroupFilterIterator' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/Filter/ExcludeGroupFilterIterator.php',
        'PHPUnit\\Runner\\Filter\\Factory' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/Filter/Factory.php',
        'PHPUnit\\Runner\\Filter\\GroupFilterIterator' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/Filter/GroupFilterIterator.php',
        'PHPUnit\\Runner\\Filter\\IncludeGroupFilterIterator' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/Filter/IncludeGroupFilterIterator.php',
        'PHPUnit\\Runner\\Filter\\NameFilterIterator' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/Filter/NameFilterIterator.php',
        'PHPUnit\\Runner\\PhptTestCase' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/PhptTestCase.php',
        'PHPUnit\\Runner\\StandardTestSuiteLoader' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/StandardTestSuiteLoader.php',
        'PHPUnit\\Runner\\TestSuiteLoader' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/TestSuiteLoader.php',
        'PHPUnit\\Runner\\Version' => __DIR__ . '/..' . '/phpunit/phpunit/src/Runner/Version.php',
        'PHPUnit\\TextUI\\Command' => __DIR__ . '/..' . '/phpunit/phpunit/src/TextUI/Command.php',
        'PHPUnit\\TextUI\\ResultPrinter' => __DIR__ . '/..' . '/phpunit/phpunit/src/TextUI/ResultPrinter.php',
        'PHPUnit\\TextUI\\TestRunner' => __DIR__ . '/..' . '/phpunit/phpunit/src/TextUI/TestRunner.php',
        'PHPUnit\\Util\\Blacklist' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Blacklist.php',
        'PHPUnit\\Util\\Configuration' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Configuration.php',
        'PHPUnit\\Util\\ConfigurationGenerator' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/ConfigurationGenerator.php',
        'PHPUnit\\Util\\ErrorHandler' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/ErrorHandler.php',
        'PHPUnit\\Util\\Fileloader' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Fileloader.php',
        'PHPUnit\\Util\\Filesystem' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Filesystem.php',
        'PHPUnit\\Util\\Filter' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Filter.php',
        'PHPUnit\\Util\\Getopt' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Getopt.php',
        'PHPUnit\\Util\\GlobalState' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/GlobalState.php',
        'PHPUnit\\Util\\InvalidArgumentHelper' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/InvalidArgumentHelper.php',
        'PHPUnit\\Util\\Json' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Json.php',
        'PHPUnit\\Util\\Log\\JUnit' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Log/JUnit.php',
        'PHPUnit\\Util\\Log\\TeamCity' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Log/TeamCity.php',
        'PHPUnit\\Util\\PHP\\AbstractPhpProcess' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/PHP/AbstractPhpProcess.php',
        'PHPUnit\\Util\\PHP\\DefaultPhpProcess' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/PHP/DefaultPhpProcess.php',
        'PHPUnit\\Util\\PHP\\WindowsPhpProcess' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/PHP/WindowsPhpProcess.php',
        'PHPUnit\\Util\\Printer' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Printer.php',
        'PHPUnit\\Util\\RegularExpression' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/RegularExpression.php',
        'PHPUnit\\Util\\Test' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Test.php',
        'PHPUnit\\Util\\TestDox\\HtmlResultPrinter' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/TestDox/HtmlResultPrinter.php',
        'PHPUnit\\Util\\TestDox\\NamePrettifier' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/TestDox/NamePrettifier.php',
        'PHPUnit\\Util\\TestDox\\ResultPrinter' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/TestDox/ResultPrinter.php',
        'PHPUnit\\Util\\TestDox\\TextResultPrinter' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/TestDox/TextResultPrinter.php',
        'PHPUnit\\Util\\TestDox\\XmlResultPrinter' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/TestDox/XmlResultPrinter.php',
        'PHPUnit\\Util\\TextTestListRenderer' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/TextTestListRenderer.php',
        'PHPUnit\\Util\\Type' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Type.php',
        'PHPUnit\\Util\\Xml' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/Xml.php',
        'PHPUnit\\Util\\XmlTestListRenderer' => __DIR__ . '/..' . '/phpunit/phpunit/src/Util/XmlTestListRenderer.php',
        'PHPUnit_Framework_MockObject_MockObject' => __DIR__ . '/..' . '/phpunit/phpunit-mock-objects/src/MockObject.php',
        'PHP_Timer' => __DIR__ . '/..' . '/phpunit/php-timer/src/Timer.php',
        'PHP_Token' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_TokenWithScope' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_TokenWithScopeAndVisibility' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ABSTRACT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_AMPERSAND' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_AND_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ARRAY' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ARRAY_CAST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_AS' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ASYNC' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_AT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_AWAIT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_BACKTICK' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_BAD_CHARACTER' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_BOOLEAN_AND' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_BOOLEAN_OR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_BOOL_CAST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_BREAK' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CALLABLE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CARET' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CASE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CATCH' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CHARACTER' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CLASS' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CLASS_C' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CLASS_NAME_CONSTANT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CLONE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CLOSE_BRACKET' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CLOSE_CURLY' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CLOSE_SQUARE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CLOSE_TAG' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_COALESCE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_COLON' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_COMMA' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_COMMENT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_COMPILER_HALT_OFFSET' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CONCAT_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CONST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CONSTANT_ENCAPSED_STRING' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CONTINUE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_CURLY_OPEN' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DEC' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DECLARE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DEFAULT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DIR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DIV' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DIV_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DNUMBER' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DO' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DOC_COMMENT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DOLLAR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DOLLAR_OPEN_CURLY_BRACES' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DOT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DOUBLE_ARROW' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DOUBLE_CAST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DOUBLE_COLON' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_DOUBLE_QUOTES' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ECHO' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ELLIPSIS' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ELSE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ELSEIF' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_EMPTY' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ENCAPSED_AND_WHITESPACE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ENDDECLARE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ENDFOR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ENDFOREACH' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ENDIF' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ENDSWITCH' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ENDWHILE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_END_HEREDOC' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ENUM' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_EQUALS' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_EVAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_EXCLAMATION_MARK' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_EXIT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_EXTENDS' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_FILE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_FINAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_FINALLY' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_FOR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_FOREACH' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_FUNCTION' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_FUNC_C' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_GLOBAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_GOTO' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_GT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_HALT_COMPILER' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IF' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IMPLEMENTS' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IN' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_INC' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_INCLUDE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_INCLUDE_ONCE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_INLINE_HTML' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_INSTANCEOF' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_INSTEADOF' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_INTERFACE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_INT_CAST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ISSET' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IS_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IS_GREATER_OR_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IS_IDENTICAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IS_NOT_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IS_NOT_IDENTICAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_IS_SMALLER_OR_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_Includes' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_JOIN' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LAMBDA_ARROW' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LAMBDA_CP' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LAMBDA_OP' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LINE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LIST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LNUMBER' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LOGICAL_AND' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LOGICAL_OR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LOGICAL_XOR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_LT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_METHOD_C' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_MINUS' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_MINUS_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_MOD_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_MULT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_MUL_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_NAMESPACE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_NEW' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_NS_C' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_NS_SEPARATOR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_NULLSAFE_OBJECT_OPERATOR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_NUM_STRING' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_OBJECT_CAST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_OBJECT_OPERATOR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_ONUMBER' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_OPEN_BRACKET' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_OPEN_CURLY' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_OPEN_SQUARE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_OPEN_TAG' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_OPEN_TAG_WITH_ECHO' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_OR_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PAAMAYIM_NEKUDOTAYIM' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PERCENT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PIPE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PLUS' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PLUS_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_POW' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_POW_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PRINT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PRIVATE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PROTECTED' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_PUBLIC' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_QUESTION_MARK' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_REQUIRE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_REQUIRE_ONCE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_RETURN' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SEMICOLON' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SHAPE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SL_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SPACESHIP' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SR_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_START_HEREDOC' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_STATIC' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_STRING' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_STRING_CAST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_STRING_VARNAME' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SUPER' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_SWITCH' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_Stream' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token/Stream.php',
        'PHP_Token_Stream_CachingFactory' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token/Stream/CachingFactory.php',
        'PHP_Token_THROW' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_TILDE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_TRAIT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_TRAIT_C' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_TRY' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_TYPE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_TYPELIST_GT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_TYPELIST_LT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_UNSET' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_UNSET_CAST' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_USE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_USE_FUNCTION' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_VAR' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_VARIABLE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_WHERE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_WHILE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_WHITESPACE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_ATTRIBUTE' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_CATEGORY' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_CATEGORY_LABEL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_CHILDREN' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_LABEL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_REQUIRED' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_TAG_GT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_TAG_LT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XHP_TEXT' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_XOR_EQUAL' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_YIELD' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PHP_Token_YIELD_FROM' => __DIR__ . '/..' . '/phpunit/php-token-stream/src/Token.php',
        'PharIo\\Manifest\\Application' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Application.php',
        'PharIo\\Manifest\\ApplicationName' => __DIR__ . '/..' . '/phar-io/manifest/src/values/ApplicationName.php',
        'PharIo\\Manifest\\Author' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Author.php',
        'PharIo\\Manifest\\AuthorCollection' => __DIR__ . '/..' . '/phar-io/manifest/src/values/AuthorCollection.php',
        'PharIo\\Manifest\\AuthorCollectionIterator' => __DIR__ . '/..' . '/phar-io/manifest/src/values/AuthorCollectionIterator.php',
        'PharIo\\Manifest\\AuthorElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/AuthorElement.php',
        'PharIo\\Manifest\\AuthorElementCollection' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/AuthorElementCollection.php',
        'PharIo\\Manifest\\BundledComponent' => __DIR__ . '/..' . '/phar-io/manifest/src/values/BundledComponent.php',
        'PharIo\\Manifest\\BundledComponentCollection' => __DIR__ . '/..' . '/phar-io/manifest/src/values/BundledComponentCollection.php',
        'PharIo\\Manifest\\BundledComponentCollectionIterator' => __DIR__ . '/..' . '/phar-io/manifest/src/values/BundledComponentCollectionIterator.php',
        'PharIo\\Manifest\\BundlesElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/BundlesElement.php',
        'PharIo\\Manifest\\ComponentElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ComponentElement.php',
        'PharIo\\Manifest\\ComponentElementCollection' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ComponentElementCollection.php',
        'PharIo\\Manifest\\ContainsElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ContainsElement.php',
        'PharIo\\Manifest\\CopyrightElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/CopyrightElement.php',
        'PharIo\\Manifest\\CopyrightInformation' => __DIR__ . '/..' . '/phar-io/manifest/src/values/CopyrightInformation.php',
        'PharIo\\Manifest\\ElementCollection' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ElementCollection.php',
        'PharIo\\Manifest\\Email' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Email.php',
        'PharIo\\Manifest\\Exception' => __DIR__ . '/..' . '/phar-io/manifest/src/exceptions/Exception.php',
        'PharIo\\Manifest\\ExtElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ExtElement.php',
        'PharIo\\Manifest\\ExtElementCollection' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ExtElementCollection.php',
        'PharIo\\Manifest\\Extension' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Extension.php',
        'PharIo\\Manifest\\ExtensionElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ExtensionElement.php',
        'PharIo\\Manifest\\InvalidApplicationNameException' => __DIR__ . '/..' . '/phar-io/manifest/src/exceptions/InvalidApplicationNameException.php',
        'PharIo\\Manifest\\InvalidEmailException' => __DIR__ . '/..' . '/phar-io/manifest/src/exceptions/InvalidEmailException.php',
        'PharIo\\Manifest\\InvalidUrlException' => __DIR__ . '/..' . '/phar-io/manifest/src/exceptions/InvalidUrlException.php',
        'PharIo\\Manifest\\Library' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Library.php',
        'PharIo\\Manifest\\License' => __DIR__ . '/..' . '/phar-io/manifest/src/values/License.php',
        'PharIo\\Manifest\\LicenseElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/LicenseElement.php',
        'PharIo\\Manifest\\Manifest' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Manifest.php',
        'PharIo\\Manifest\\ManifestDocument' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ManifestDocument.php',
        'PharIo\\Manifest\\ManifestDocumentException' => __DIR__ . '/..' . '/phar-io/manifest/src/exceptions/ManifestDocumentException.php',
        'PharIo\\Manifest\\ManifestDocumentLoadingException' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ManifestDocumentLoadingException.php',
        'PharIo\\Manifest\\ManifestDocumentMapper' => __DIR__ . '/..' . '/phar-io/manifest/src/ManifestDocumentMapper.php',
        'PharIo\\Manifest\\ManifestDocumentMapperException' => __DIR__ . '/..' . '/phar-io/manifest/src/exceptions/ManifestDocumentMapperException.php',
        'PharIo\\Manifest\\ManifestElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/ManifestElement.php',
        'PharIo\\Manifest\\ManifestElementException' => __DIR__ . '/..' . '/phar-io/manifest/src/exceptions/ManifestElementException.php',
        'PharIo\\Manifest\\ManifestLoader' => __DIR__ . '/..' . '/phar-io/manifest/src/ManifestLoader.php',
        'PharIo\\Manifest\\ManifestLoaderException' => __DIR__ . '/..' . '/phar-io/manifest/src/exceptions/ManifestLoaderException.php',
        'PharIo\\Manifest\\ManifestSerializer' => __DIR__ . '/..' . '/phar-io/manifest/src/ManifestSerializer.php',
        'PharIo\\Manifest\\PhpElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/PhpElement.php',
        'PharIo\\Manifest\\PhpExtensionRequirement' => __DIR__ . '/..' . '/phar-io/manifest/src/values/PhpExtensionRequirement.php',
        'PharIo\\Manifest\\PhpVersionRequirement' => __DIR__ . '/..' . '/phar-io/manifest/src/values/PhpVersionRequirement.php',
        'PharIo\\Manifest\\Requirement' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Requirement.php',
        'PharIo\\Manifest\\RequirementCollection' => __DIR__ . '/..' . '/phar-io/manifest/src/values/RequirementCollection.php',
        'PharIo\\Manifest\\RequirementCollectionIterator' => __DIR__ . '/..' . '/phar-io/manifest/src/values/RequirementCollectionIterator.php',
        'PharIo\\Manifest\\RequiresElement' => __DIR__ . '/..' . '/phar-io/manifest/src/xml/RequiresElement.php',
        'PharIo\\Manifest\\Type' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Type.php',
        'PharIo\\Manifest\\Url' => __DIR__ . '/..' . '/phar-io/manifest/src/values/Url.php',
        'PharIo\\Version\\AbstractVersionConstraint' => __DIR__ . '/..' . '/phar-io/version/src/AbstractVersionConstraint.php',
        'PharIo\\Version\\AndVersionConstraintGroup' => __DIR__ . '/..' . '/phar-io/version/src/AndVersionConstraintGroup.php',
        'PharIo\\Version\\AnyVersionConstraint' => __DIR__ . '/..' . '/phar-io/version/src/AnyVersionConstraint.php',
        'PharIo\\Version\\ExactVersionConstraint' => __DIR__ . '/..' . '/phar-io/version/src/ExactVersionConstraint.php',
        'PharIo\\Version\\Exception' => __DIR__ . '/..' . '/phar-io/version/src/Exception.php',
        'PharIo\\Version\\GreaterThanOrEqualToVersionConstraint' => __DIR__ . '/..' . '/phar-io/version/src/GreaterThanOrEqualToVersionConstraint.php',
        'PharIo\\Version\\InvalidVersionException' => __DIR__ . '/..' . '/phar-io/version/src/InvalidVersionException.php',
        'PharIo\\Version\\OrVersionConstraintGroup' => __DIR__ . '/..' . '/phar-io/version/src/OrVersionConstraintGroup.php',
        'PharIo\\Version\\PreReleaseSuffix' => __DIR__ . '/..' . '/phar-io/version/src/PreReleaseSuffix.php',
        'PharIo\\Version\\SpecificMajorAndMinorVersionConstraint' => __DIR__ . '/..' . '/phar-io/version/src/SpecificMajorAndMinorVersionConstraint.php',
        'PharIo\\Version\\SpecificMajorVersionConstraint' => __DIR__ . '/..' . '/phar-io/version/src/SpecificMajorVersionConstraint.php',
        'PharIo\\Version\\UnsupportedVersionConstraintException' => __DIR__ . '/..' . '/phar-io/version/src/UnsupportedVersionConstraintException.php',
        'PharIo\\Version\\Version' => __DIR__ . '/..' . '/phar-io/version/src/Version.php',
        'PharIo\\Version\\VersionConstraint' => __DIR__ . '/..' . '/phar-io/version/src/VersionConstraint.php',
        'PharIo\\Version\\VersionConstraintParser' => __DIR__ . '/..' . '/phar-io/version/src/VersionConstraintParser.php',
        'PharIo\\Version\\VersionConstraintValue' => __DIR__ . '/..' . '/phar-io/version/src/VersionConstraintValue.php',
        'PharIo\\Version\\VersionNumber' => __DIR__ . '/..' . '/phar-io/version/src/VersionNumber.php',
        'SebastianBergmann\\CodeCoverage\\CodeCoverage' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/CodeCoverage.php',
        'SebastianBergmann\\CodeCoverage\\CoveredCodeNotExecutedException' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Exception/CoveredCodeNotExecutedException.php',
        'SebastianBergmann\\CodeCoverage\\Driver\\Driver' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Driver/Driver.php',
        'SebastianBergmann\\CodeCoverage\\Driver\\HHVM' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Driver/HHVM.php',
        'SebastianBergmann\\CodeCoverage\\Driver\\PHPDBG' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Driver/PHPDBG.php',
        'SebastianBergmann\\CodeCoverage\\Driver\\Xdebug' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Driver/Xdebug.php',
        'SebastianBergmann\\CodeCoverage\\Exception' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Exception/Exception.php',
        'SebastianBergmann\\CodeCoverage\\Filter' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Filter.php',
        'SebastianBergmann\\CodeCoverage\\InvalidArgumentException' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Exception/InvalidArgumentException.php',
        'SebastianBergmann\\CodeCoverage\\MissingCoversAnnotationException' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Exception/MissingCoversAnnotationException.php',
        'SebastianBergmann\\CodeCoverage\\Node\\AbstractNode' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Node/AbstractNode.php',
        'SebastianBergmann\\CodeCoverage\\Node\\Builder' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Node/Builder.php',
        'SebastianBergmann\\CodeCoverage\\Node\\Directory' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Node/Directory.php',
        'SebastianBergmann\\CodeCoverage\\Node\\File' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Node/File.php',
        'SebastianBergmann\\CodeCoverage\\Node\\Iterator' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Node/Iterator.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Clover' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Clover.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Crap4j' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Crap4j.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Html\\Dashboard' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Html/Renderer/Dashboard.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Html\\Directory' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Html/Renderer/Directory.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Html\\Facade' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Html/Facade.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Html\\File' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Html/Renderer/File.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Html\\Renderer' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Html/Renderer.php',
        'SebastianBergmann\\CodeCoverage\\Report\\PHP' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/PHP.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Text' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Text.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\BuildInformation' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/BuildInformation.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Coverage' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Coverage.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Directory' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Directory.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Facade' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Facade.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\File' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/File.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Method' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Method.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Node' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Node.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Project' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Project.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Report' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Report.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Source' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Source.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Tests' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Tests.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Totals' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Totals.php',
        'SebastianBergmann\\CodeCoverage\\Report\\Xml\\Unit' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Report/Xml/Unit.php',
        'SebastianBergmann\\CodeCoverage\\RuntimeException' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Exception/RuntimeException.php',
        'SebastianBergmann\\CodeCoverage\\UnintentionallyCoveredCodeException' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Exception/UnintentionallyCoveredCodeException.php',
        'SebastianBergmann\\CodeCoverage\\Util' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Util.php',
        'SebastianBergmann\\CodeCoverage\\Version' => __DIR__ . '/..' . '/phpunit/php-code-coverage/src/Version.php',
        'SebastianBergmann\\CodeUnitReverseLookup\\Wizard' => __DIR__ . '/..' . '/sebastian/code-unit-reverse-lookup/src/Wizard.php',
        'SebastianBergmann\\Comparator\\ArrayComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/ArrayComparator.php',
        'SebastianBergmann\\Comparator\\Comparator' => __DIR__ . '/..' . '/sebastian/comparator/src/Comparator.php',
        'SebastianBergmann\\Comparator\\ComparisonFailure' => __DIR__ . '/..' . '/sebastian/comparator/src/ComparisonFailure.php',
        'SebastianBergmann\\Comparator\\DOMNodeComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/DOMNodeComparator.php',
        'SebastianBergmann\\Comparator\\DateTimeComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/DateTimeComparator.php',
        'SebastianBergmann\\Comparator\\DoubleComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/DoubleComparator.php',
        'SebastianBergmann\\Comparator\\ExceptionComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/ExceptionComparator.php',
        'SebastianBergmann\\Comparator\\Factory' => __DIR__ . '/..' . '/sebastian/comparator/src/Factory.php',
        'SebastianBergmann\\Comparator\\MockObjectComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/MockObjectComparator.php',
        'SebastianBergmann\\Comparator\\NumericComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/NumericComparator.php',
        'SebastianBergmann\\Comparator\\ObjectComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/ObjectComparator.php',
        'SebastianBergmann\\Comparator\\ResourceComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/ResourceComparator.php',
        'SebastianBergmann\\Comparator\\ScalarComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/ScalarComparator.php',
        'SebastianBergmann\\Comparator\\SplObjectStorageComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/SplObjectStorageComparator.php',
        'SebastianBergmann\\Comparator\\TypeComparator' => __DIR__ . '/..' . '/sebastian/comparator/src/TypeComparator.php',
        'SebastianBergmann\\Diff\\Chunk' => __DIR__ . '/..' . '/sebastian/diff/src/Chunk.php',
        'SebastianBergmann\\Diff\\Diff' => __DIR__ . '/..' . '/sebastian/diff/src/Diff.php',
        'SebastianBergmann\\Diff\\Differ' => __DIR__ . '/..' . '/sebastian/diff/src/Differ.php',
        'SebastianBergmann\\Diff\\Exception' => __DIR__ . '/..' . '/sebastian/diff/src/Exception/Exception.php',
        'SebastianBergmann\\Diff\\InvalidArgumentException' => __DIR__ . '/..' . '/sebastian/diff/src/Exception/InvalidArgumentException.php',
        'SebastianBergmann\\Diff\\Line' => __DIR__ . '/..' . '/sebastian/diff/src/Line.php',
        'SebastianBergmann\\Diff\\LongestCommonSubsequenceCalculator' => __DIR__ . '/..' . '/sebastian/diff/src/LongestCommonSubsequenceCalculator.php',
        'SebastianBergmann\\Diff\\MemoryEfficientLongestCommonSubsequenceCalculator' => __DIR__ . '/..' . '/sebastian/diff/src/MemoryEfficientLongestCommonSubsequenceCalculator.php',
        'SebastianBergmann\\Diff\\Output\\AbstractChunkOutputBuilder' => __DIR__ . '/..' . '/sebastian/diff/src/Output/AbstractChunkOutputBuilder.php',
        'SebastianBergmann\\Diff\\Output\\DiffOnlyOutputBuilder' => __DIR__ . '/..' . '/sebastian/diff/src/Output/DiffOnlyOutputBuilder.php',
        'SebastianBergmann\\Diff\\Output\\DiffOutputBuilderInterface' => __DIR__ . '/..' . '/sebastian/diff/src/Output/DiffOutputBuilderInterface.php',
        'SebastianBergmann\\Diff\\Output\\UnifiedDiffOutputBuilder' => __DIR__ . '/..' . '/sebastian/diff/src/Output/UnifiedDiffOutputBuilder.php',
        'SebastianBergmann\\Diff\\Parser' => __DIR__ . '/..' . '/sebastian/diff/src/Parser.php',
        'SebastianBergmann\\Diff\\TimeEfficientLongestCommonSubsequenceCalculator' => __DIR__ . '/..' . '/sebastian/diff/src/TimeEfficientLongestCommonSubsequenceCalculator.php',
        'SebastianBergmann\\Environment\\Console' => __DIR__ . '/..' . '/sebastian/environment/src/Console.php',
        'SebastianBergmann\\Environment\\OperatingSystem' => __DIR__ . '/..' . '/sebastian/environment/src/OperatingSystem.php',
        'SebastianBergmann\\Environment\\Runtime' => __DIR__ . '/..' . '/sebastian/environment/src/Runtime.php',
        'SebastianBergmann\\Exporter\\Exporter' => __DIR__ . '/..' . '/sebastian/exporter/src/Exporter.php',
        'SebastianBergmann\\GlobalState\\Blacklist' => __DIR__ . '/..' . '/sebastian/global-state/src/Blacklist.php',
        'SebastianBergmann\\GlobalState\\CodeExporter' => __DIR__ . '/..' . '/sebastian/global-state/src/CodeExporter.php',
        'SebastianBergmann\\GlobalState\\Exception' => __DIR__ . '/..' . '/sebastian/global-state/src/exceptions/Exception.php',
        'SebastianBergmann\\GlobalState\\Restorer' => __DIR__ . '/..' . '/sebastian/global-state/src/Restorer.php',
        'SebastianBergmann\\GlobalState\\RuntimeException' => __DIR__ . '/..' . '/sebastian/global-state/src/exceptions/RuntimeException.php',
        'SebastianBergmann\\GlobalState\\Snapshot' => __DIR__ . '/..' . '/sebastian/global-state/src/Snapshot.php',
        'SebastianBergmann\\ObjectEnumerator\\Enumerator' => __DIR__ . '/..' . '/sebastian/object-enumerator/src/Enumerator.php',
        'SebastianBergmann\\ObjectEnumerator\\Exception' => __DIR__ . '/..' . '/sebastian/object-enumerator/src/Exception.php',
        'SebastianBergmann\\ObjectEnumerator\\InvalidArgumentException' => __DIR__ . '/..' . '/sebastian/object-enumerator/src/InvalidArgumentException.php',
        'SebastianBergmann\\ObjectReflector\\Exception' => __DIR__ . '/..' . '/sebastian/object-reflector/src/Exception.php',
        'SebastianBergmann\\ObjectReflector\\InvalidArgumentException' => __DIR__ . '/..' . '/sebastian/object-reflector/src/InvalidArgumentException.php',
        'SebastianBergmann\\ObjectReflector\\ObjectReflector' => __DIR__ . '/..' . '/sebastian/object-reflector/src/ObjectReflector.php',
        'SebastianBergmann\\RecursionContext\\Context' => __DIR__ . '/..' . '/sebastian/recursion-context/src/Context.php',
        'SebastianBergmann\\RecursionContext\\Exception' => __DIR__ . '/..' . '/sebastian/recursion-context/src/Exception.php',
        'SebastianBergmann\\RecursionContext\\InvalidArgumentException' => __DIR__ . '/..' . '/sebastian/recursion-context/src/InvalidArgumentException.php',
        'SebastianBergmann\\ResourceOperations\\ResourceOperations' => __DIR__ . '/..' . '/sebastian/resource-operations/src/ResourceOperations.php',
        'SebastianBergmann\\Version' => __DIR__ . '/..' . '/sebastian/version/src/Version.php',
        'Text_Template' => __DIR__ . '/..' . '/phpunit/php-text-template/src/Template.php',
        'TheSeer\\Tokenizer\\Exception' => __DIR__ . '/..' . '/theseer/tokenizer/src/Exception.php',
        'TheSeer\\Tokenizer\\NamespaceUri' => __DIR__ . '/..' . '/theseer/tokenizer/src/NamespaceUri.php',
        'TheSeer\\Tokenizer\\NamespaceUriException' => __DIR__ . '/..' . '/theseer/tokenizer/src/NamespaceUriException.php',
        'TheSeer\\Tokenizer\\Token' => __DIR__ . '/..' . '/theseer/tokenizer/src/Token.php',
        'TheSeer\\Tokenizer\\TokenCollection' => __DIR__ . '/..' . '/theseer/tokenizer/src/TokenCollection.php',
        'TheSeer\\Tokenizer\\TokenCollectionException' => __DIR__ . '/..' . '/theseer/tokenizer/src/TokenCollectionException.php',
        'TheSeer\\Tokenizer\\Tokenizer' => __DIR__ . '/..' . '/theseer/tokenizer/src/Tokenizer.php',
        'TheSeer\\Tokenizer\\XMLSerializer' => __DIR__ . '/..' . '/theseer/tokenizer/src/XMLSerializer.php',
    );

    public static function getInitializer(ClassLoader $loader)
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 29; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 29; return \Closure::bind(function () use ($loader) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 28; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 28; $loader->prefixLengthsPsr4 = ComposerStaticInit718e12bccf6cad6e9086d8f64e94517b::$prefixLengthsPsr4; }
            $loader->prefixDirsPsr4 = ComposerStaticInit718e12bccf6cad6e9086d8f64e94517b::$prefixDirsPsr4;
            $loader->classMap = ComposerStaticInit718e12bccf6cad6e9086d8f64e94517b::$classMap;

        }, null, ClassLoader::class); }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

use Microsoft\PhpParser\Node\AnonymousFunctionUseClause;
use Microsoft\PhpParser\Node\ArrayElement;
use Microsoft\PhpParser\Node\Attribute;
use Microsoft\PhpParser\Node\AttributeGroup;
use Microsoft\PhpParser\Node\CaseStatementNode;
use Microsoft\PhpParser\Node\CatchClause;
use Microsoft\PhpParser\Node\ClassBaseClause;
use Microsoft\PhpParser\Node\ClassInterfaceClause;
use Microsoft\PhpParser\Node\ClassMembersNode;
use Microsoft\PhpParser\Node\ConstElement;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\Expression\{
    AnonymousFunctionCreationExpression,
    ArgumentExpression,
    ArrayCreationExpression,
    ArrowFunctionCreationExpression,
    AssignmentExpression,
    BinaryExpression,
    BracedExpression,
    CallExpression,
    CastExpression,
    CloneExpression,
    EmptyIntrinsicExpression,
    ErrorControlExpression,
    EvalIntrinsicExpression,
    ExitIntrinsicExpression,
    IssetIntrinsicExpression,
    MatchExpression,
    MemberAccessExpression,
    ParenthesizedExpression,
    PrefixUpdateExpression,
    PrintIntrinsicExpression,
    EchoExpression,
    ListIntrinsicExpression,
    ObjectCreationExpression,
    ScriptInclusionExpression,
    PostfixUpdateExpression,
    ScopedPropertyAccessExpression,
    SubscriptExpression,
    TernaryExpression,
    ThrowExpression,
    UnaryExpression,
    UnaryOpExpression,
    UnsetIntrinsicExpression,
    Variable,
    YieldExpression
};
use Microsoft\PhpParser\Node\StaticVariableDeclaration;
use Microsoft\PhpParser\Node\ClassConstDeclaration;
use Microsoft\PhpParser\Node\DeclareDirective;
use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\ElseClauseNode;
use Microsoft\PhpParser\Node\ElseIfClauseNode;
use Microsoft\PhpParser\Node\FinallyClause;
use Microsoft\PhpParser\Node\ForeachKey;
use Microsoft\PhpParser\Node\ForeachValue;
use Microsoft\PhpParser\Node\InterfaceBaseClause;
use Microsoft\PhpParser\Node\InterfaceMembers;
use Microsoft\PhpParser\Node\MatchArm;
use Microsoft\PhpParser\Node\MissingDeclaration;
use Microsoft\PhpParser\Node\MissingMemberDeclaration;
use Microsoft\PhpParser\Node\NamespaceAliasingClause;
use Microsoft\PhpParser\Node\NamespaceUseGroupClause;
use Microsoft\PhpParser\Node\NumericLiteral;
use Microsoft\PhpParser\Node\PropertyDeclaration;
use Microsoft\PhpParser\Node\ReservedWord;
use Microsoft\PhpParser\Node\StringLiteral;
use Microsoft\PhpParser\Node\MethodDeclaration;
use Microsoft\PhpParser\Node\Parameter;
use Microsoft\PhpParser\Node\QualifiedName;
use Microsoft\PhpParser\Node\RelativeSpecifier;
use Microsoft\PhpParser\Node\SourceFileNode;
use Microsoft\PhpParser\Node\Statement\{
    ClassDeclaration,
    ConstDeclaration,
    CompoundStatementNode,
    FunctionStaticDeclaration,
    GlobalDeclaration,
    BreakOrContinueStatement,
    DeclareStatement,
    DoStatement,
    EmptyStatement,
    ExpressionStatement,
    ForeachStatement,
    ForStatement,
    FunctionDeclaration,
    GotoStatement,
    IfStatementNode,
    InlineHtml,
    InterfaceDeclaration,
    NamespaceDefinition,
    NamespaceUseDeclaration,
    NamedLabelStatement,
    ReturnStatement,
    SwitchStatementNode,
    ThrowStatement,
    TraitDeclaration,
    TryStatement,
    WhileStatement
};
use Microsoft\PhpParser\Node\TraitMembers;
use Microsoft\PhpParser\Node\TraitSelectOrAliasClause;
use Microsoft\PhpParser\Node\TraitUseClause;
use Microsoft\PhpParser\Node\UseVariableName;
use Microsoft\PhpParser\Node\NamespaceUseClause;

class Parser {
    /** @var TokenStreamProviderInterface */
    private $lexer;

    private $currentParseContext;
    public $sourceFile;

    private $nameOrKeywordOrReservedWordTokens;
    private $nameOrReservedWordTokens;
    private $nameOrStaticOrReservedWordTokens;
    private $reservedWordTokens;
    private $keywordTokens;
    private $argumentStartTokensSet;
    // TODO consider validating parameter and return types on post-parse instead so we can be more permissive
    private $parameterTypeDeclarationTokens;
    private $returnTypeDeclarationTokens;

    public function __construct() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 30; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 30; $this->reservedWordTokens = \array_values(TokenStringMaps::RESERVED_WORDS); }
        $this->keywordTokens = \array_values(TokenStringMaps::KEYWORDS);
        $this->argumentStartTokensSet = \array_flip(TokenStringMaps::KEYWORDS);
        unset($this->argumentStartTokensSet[TokenKind::YieldFromKeyword]);
        $this->argumentStartTokensSet[TokenKind::DotDotDotToken] = '...';
        $this->nameOrKeywordOrReservedWordTokens = \array_merge([TokenKind::Name], $this->keywordTokens, $this->reservedWordTokens);
        $this->nameOrReservedWordTokens = \array_merge([TokenKind::Name], $this->reservedWordTokens);
        $this->nameOrStaticOrReservedWordTokens = \array_merge([TokenKind::Name, TokenKind::StaticKeyword], $this->reservedWordTokens);
        $this->parameterTypeDeclarationTokens =
            [TokenKind::ArrayKeyword, TokenKind::CallableKeyword, TokenKind::BoolReservedWord,
            TokenKind::FloatReservedWord, TokenKind::IntReservedWord, TokenKind::StringReservedWord,
            TokenKind::ObjectReservedWord, TokenKind::NullReservedWord, TokenKind::FalseReservedWord]; // TODO update spec
        $this->returnTypeDeclarationTokens = \array_merge([TokenKind::VoidReservedWord, TokenKind::NullReservedWord, TokenKind::FalseReservedWord, TokenKind::StaticKeyword], $this->parameterTypeDeclarationTokens);
    }

    /**
     * This method exists so that it can be overridden in subclasses.
     * Any subclass must return a token stream that is equivalent to the contents in $fileContents for this to work properly.
     *
     * Possible reasons for applications to override the lexer:
     *
     * - Imitate token stream of a newer/older PHP version (e.g. T_FN is only available in php 7.4)
     * - Reuse the result of token_get_all to create a Node again.
     * - Reuse the result of token_get_all in a different library.
     */
    protected function makeLexer(string $fileContents): TokenStreamProviderInterface
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 31; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 31; return TokenStreamProviderFactory::GetTokenStreamProvider($fileContents); }
    }

    /**
     * Generates AST from source file contents. Returns an instance of SourceFileNode, which is always the top-most
     * Node-type of the tree.
     *
     * @param string $fileContents
     * @return SourceFileNode
     */
    public function parseSourceFile(string $fileContents, string $uri = null) : SourceFileNode {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 36; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 36; $this->lexer = $this->makeLexer($fileContents); }

        $this->reset();

        $sourceFile = new SourceFileNode();
        $this->sourceFile = $sourceFile;
        $sourceFile->fileContents = $fileContents;
        $sourceFile->uri = $uri;
        $sourceFile->statementList = array();
        if ($this->getCurrentToken()->kind !== TokenKind::EndOfFileToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 34; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 34; $inlineHTML = $this->parseInlineHtml($sourceFile); }
            $sourceFile->statementList[] = $inlineHTML;
            if ($inlineHTML->echoStatement) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 32; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 32; $sourceFile->statementList[] = $inlineHTML->echoStatement; }
                $inlineHTML->echoStatement->parent = $sourceFile;
                $inlineHTML->echoStatement = null;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 33; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 33;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 35; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 35;
        $sourceFile->statementList =
            \array_merge($sourceFile->statementList, $this->parseList($sourceFile, ParseContext::SourceElements));

        $this->sourceFile->endOfFileToken = $this->eat1(TokenKind::EndOfFileToken);
        $this->advanceToken();

        $sourceFile->parent = null;

        return $sourceFile;
    }

    private function reset() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 37; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 37; $this->advanceToken(); }

        // Stores the current parse context, which includes the current and enclosing lists.
        $this->currentParseContext = 0;
    }

    /**
     * Parse a list of elements for a given ParseContext until a list terminator associated
     * with that ParseContext is reached. Additionally abort parsing when an element is reached
     * that is invalid in the current context, but valid in an enclosing context. If an element
     * is invalid in both current and enclosing contexts, generate a SkippedToken, and continue.
     * @param Node $parentNode
     * @param int $listParseContext
     * @return array
     */
    private function parseList($parentNode, int $listParseContext) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 48; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 48; $savedParseContext = $this->currentParseContext; }
        $this->currentParseContext |= 1 << $listParseContext;
        $parseListElementFn = $this->getParseListElementFn($listParseContext);

        $nodeArray = array();
        while (!$this->isListTerminator($listParseContext)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 47; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 47; if ($this->isValidListElement($listParseContext, $this->getCurrentToken())) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 43; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 43; $element = $parseListElementFn($parentNode); }
                $nodeArray[] = $element;
                if ($element instanceof Node) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 41; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 41; $element->parent = $parentNode; }
                    if ($element instanceof InlineHtml && \PhpFuzzer\FuzzingContext::traceBlock(38, $element->echoStatement)) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 39; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 39; $nodeArray[] = $element->echoStatement; }
                        $element->echoStatement->parent = $parentNode;
                        $element->echoStatement = null;
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 40; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 40;
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 42; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 42;
                continue;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 44; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 44; }

            // Error handling logic:
            // The current parse context does not know how to handle the current token,
            // so check if the enclosing contexts know what to do. If so, we assume that
            // the list has completed parsing, and return to the enclosing context.
            //
            // Example:
            //     class A {
            //         function foo() {
            //            return;
            //      // } <- MissingToken (generated when we try to "eat" the closing brace)
            //
            //         public function bar() {
            //         }
            //     }
            //
            // In the case above, the Method ParseContext doesn't know how to handle "public", but
            // the Class ParseContext will know what to do with it. So we abort the Method ParseContext,
            // and return to the Class ParseContext. This enables us to generate a tree with a single
            // class that contains two method nodes, even though there was an error present in the first method.
            if ($this->isCurrentTokenValidInEnclosingContexts()) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 45; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 45; break; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 46; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 46;

            // None of the enclosing contexts know how to handle the token. Generate a
            // SkippedToken, and continue parsing in the current context.
            // Example:
            //     class A {
            //         function foo() {
            //            return;
            //            & // <- SkippedToken
            //         }
            //     }
            $token = new SkippedToken($this->getCurrentToken());
            $nodeArray[] = $token;
            $this->advanceToken();
        }

        $this->currentParseContext = $savedParseContext;

        return $nodeArray;
    }

    private function isListTerminator(int $parseContext) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 68; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 68; $tokenKind = $this->getCurrentToken()->kind; }
        if ($tokenKind === TokenKind::EndOfFileToken) {
            // Being at the end of the file ends all lists.
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 49; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 49; return true; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 50; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 50;

        switch ($parseContext) {
            case ParseContext::SourceElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 51; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 51; return false; }

            case ParseContext::InterfaceMembers: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 52; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 52;
            case ParseContext::ClassMembers: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 53; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 53;
            case ParseContext::BlockStatements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 54; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 54;
            case ParseContext::TraitMembers:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 55; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 55; return $tokenKind === TokenKind::CloseBraceToken; }
            case ParseContext::SwitchStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 57; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 57; return $tokenKind === TokenKind::CloseBraceToken || \PhpFuzzer\FuzzingContext::traceBlock(56, $tokenKind === TokenKind::EndSwitchKeyword); }
            case ParseContext::IfClause2Elements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 60; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 60; return
                    $tokenKind === TokenKind::ElseIfKeyword ||
                    \PhpFuzzer\FuzzingContext::traceBlock(58, $tokenKind === TokenKind::ElseKeyword) ||
                    \PhpFuzzer\FuzzingContext::traceBlock(59, $tokenKind === TokenKind::EndIfKeyword); }

            case ParseContext::WhileStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 61; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 61; return $tokenKind === TokenKind::EndWhileKeyword; }

            case ParseContext::CaseStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 63; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 63; return
                    $tokenKind === TokenKind::CaseKeyword ||
                    \PhpFuzzer\FuzzingContext::traceBlock(62, $tokenKind === TokenKind::DefaultKeyword); }

            case ParseContext::ForStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 64; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 64; return
                    $tokenKind === TokenKind::EndForKeyword; }

            case ParseContext::ForeachStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 65; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 65; return $tokenKind === TokenKind::EndForEachKeyword; }

            case ParseContext::DeclareStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 66; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 66; return $tokenKind === TokenKind::EndDeclareKeyword; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 67; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 67;
        // TODO warn about unhandled parse context
        return false;
    }

    private function isValidListElement($context, Token $token) {

        // TODO
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 83; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 83; switch ($context) {
            case ParseContext::SourceElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 69; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 69;
            case ParseContext::BlockStatements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 70; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 70;
            case ParseContext::IfClause2Elements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 71; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 71;
            case ParseContext::CaseStatementElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 72; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 72;
            case ParseContext::WhileStatementElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 73; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 73;
            case ParseContext::ForStatementElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 74; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 74;
            case ParseContext::ForeachStatementElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 75; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 75;
            case ParseContext::DeclareStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 76; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 76; return $this->isStatementStart($token); }

            case ParseContext::ClassMembers:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 77; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 77; return $this->isClassMemberDeclarationStart($token); }

            case ParseContext::TraitMembers:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 78; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 78; return $this->isTraitMemberDeclarationStart($token); }

            case ParseContext::InterfaceMembers:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 79; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 79; return $this->isInterfaceMemberDeclarationStart($token); }

            case ParseContext::SwitchStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 81; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 81; return
                    $token->kind === TokenKind::CaseKeyword ||
                    \PhpFuzzer\FuzzingContext::traceBlock(80, $token->kind === TokenKind::DefaultKeyword); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 82; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 82; }
        return false;
    }

    private function getParseListElementFn($context) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 98; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 98; switch ($context) {
            case ParseContext::SourceElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 84; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 84;
            case ParseContext::BlockStatements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 85; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 85;
            case ParseContext::IfClause2Elements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 86; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 86;
            case ParseContext::CaseStatementElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 87; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 87;
            case ParseContext::WhileStatementElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 88; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 88;
            case ParseContext::ForStatementElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 89; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 89;
            case ParseContext::ForeachStatementElements: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 90; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 90;
            case ParseContext::DeclareStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 91; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 91; return $this->parseStatementFn(); }
            case ParseContext::ClassMembers:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 92; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 92; return $this->parseClassElementFn(); }

            case ParseContext::TraitMembers:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 93; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 93; return $this->parseTraitElementFn(); }

            case ParseContext::InterfaceMembers:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 94; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 94; return $this->parseInterfaceElementFn(); }

            case ParseContext::SwitchStatementElements:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 95; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 95; return $this->parseCaseOrDefaultStatement(); }
            default:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 96; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 96; throw new \Exception("Unrecognized parse context"); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 97; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 97; }
    }

    /**
     * Aborts parsing list when one of the parent contexts understands something
     * @return bool
     */
    private function isCurrentTokenValidInEnclosingContexts() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 106; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 106; for ($contextKind = 0; $contextKind < ParseContext::Count; $contextKind++) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 104; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 104; if ($this->isInParseContext($contextKind)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 102; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 102; if ($this->isValidListElement($contextKind, $this->getCurrentToken()) || \PhpFuzzer\FuzzingContext::traceBlock(99, $this->isListTerminator($contextKind))) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 100; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 100; return true; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 101; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 101; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 103; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 103; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 105; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 105; }
        return false;
    }

    private function isInParseContext($contextToCheck) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 107; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 107; return ($this->currentParseContext & (1 << $contextToCheck)); }
    }

    /**
     * Retrieve the current token, and check that it's of the expected TokenKind.
     * If so, advance and return the token. Otherwise return a MissingToken for
     * the expected token.
     * @param int|int[] ...$kinds
     * @return Token
     */
    private function eat(...$kinds) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 114; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 114; $token = $this->token; }
        if (\is_array($kinds[0])) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 108; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 108; $kinds = $kinds[0]; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 109; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 109;
        foreach ($kinds as $kind) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 112; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 112; if ($token->kind === $kind) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 110; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 110; $this->token = $this->lexer->scanNextToken(); }
                return $token;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 111; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 111; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 113; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 113;
        // TODO include optional grouping for token kinds
        return new MissingToken($kinds[0], $token->fullStart);
    }

    /**
     * Retrieve the current token, and check that it's of the kind $kind.
     * If so, advance and return the token. Otherwise return a MissingToken for
     * the expected token.
     *
     * This is faster than calling eat() if there is a single token.
     *
     * @param int $kind
     * @return Token
     */
    private function eat1($kind) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 117; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 117; $token = $this->token; }
        if ($token->kind === $kind) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 115; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 115; $this->token = $this->lexer->scanNextToken(); }
            return $token;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 116; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 116;
        // TODO include optional grouping for token kinds
        return new MissingToken($kind, $token->fullStart);
    }

    /**
     * @param int|int[] ...$kinds (Can provide a single value with a list of kinds, or multiple kinds)
     * @return Token|null
     */
    private function eatOptional(...$kinds) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 122; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 122; $token = $this->token; }
        if (\is_array($kinds[0])) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 118; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 118; $kinds = $kinds[0]; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 119; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 119;
        if (\in_array($token->kind, $kinds)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 120; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 120; $this->token = $this->lexer->scanNextToken(); }
            return $token;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 121; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 121;
        return null;
    }

    /**
     * @param int $kind a single kind
     * @return Token|null
     */
    private function eatOptional1($kind) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 125; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 125; $token = $this->token; }
        if ($token->kind === $kind) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 123; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 123; $this->token = $this->lexer->scanNextToken(); }
            return $token;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 124; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 124;
        return null;
    }

    private $token;

    private function getCurrentToken() : Token {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 126; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 126; return $this->token; }
    }

    private function advanceToken() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 127; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 127; $this->token = $this->lexer->scanNextToken(); }
    }

    private function parseStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 128; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 128; return ($this->parseStatementFn())($parentNode); }
    }

    private function parseStatementFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 173; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 173; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 172; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 172; $token = $this->getCurrentToken(); }
            switch ($token->kind) {
                // compound-statement
                case TokenKind::OpenBraceToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 129; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 129; return $this->parseCompoundStatement($parentNode); }

                // labeled-statement
                case TokenKind::Name:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 132; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 132; if ($this->lookahead(TokenKind::ColonToken)) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 130; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 130; return $this->parseNamedLabelStatement($parentNode); }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 131; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 131; }
                    break;

                // selection-statement
                case TokenKind::IfKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 133; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 133; return $this->parseIfStatement($parentNode); }
                case TokenKind::SwitchKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 134; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 134; return $this->parseSwitchStatement($parentNode); }

                // iteration-statement
                case TokenKind::WhileKeyword: // while-statement
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 135; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 135; return $this->parseWhileStatement($parentNode); }
                case TokenKind::DoKeyword: // do-statement
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 136; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 136; return $this->parseDoStatement($parentNode); }
                case TokenKind::ForKeyword: // for-statement
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 137; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 137; return $this->parseForStatement($parentNode); }
                case TokenKind::ForeachKeyword: // foreach-statement
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 138; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 138; return $this->parseForeachStatement($parentNode); }

                // jump-statement
                case TokenKind::GotoKeyword: // goto-statement
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 139; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 139; return $this->parseGotoStatement($parentNode); }
                case TokenKind::ContinueKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 140; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 140; // continue-statement
                case TokenKind::BreakKeyword: // break-statement
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 141; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 141; return $this->parseBreakOrContinueStatement($parentNode); }
                case TokenKind::ReturnKeyword: // return-statement
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 142; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 142; return $this->parseReturnStatement($parentNode); }
                case TokenKind::ThrowKeyword: // throw-statement
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 143; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 143; return $this->parseThrowStatement($parentNode); }

                // try-statement
                case TokenKind::TryKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 144; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 144; return $this->parseTryStatement($parentNode); }

                // declare-statement
                case TokenKind::DeclareKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 145; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 145; return $this->parseDeclareStatement($parentNode); }

                // attribute before statement or anonymous function
                case TokenKind::AttributeToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 146; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 146; return $this->parseAttributeStatement($parentNode); }

                // function-declaration
                case TokenKind::FunctionKeyword:
                    // Check that this is not an anonymous-function-creation-expression
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 150; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 150; if ($this->lookahead($this->nameOrKeywordOrReservedWordTokens) || \PhpFuzzer\FuzzingContext::traceBlock(147, $this->lookahead(TokenKind::AmpersandToken, $this->nameOrKeywordOrReservedWordTokens))) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 148; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 148; return $this->parseFunctionDeclaration($parentNode); }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 149; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 149; }
                    break;

                // class-declaration
                case TokenKind::FinalKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 151; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 151;
                case TokenKind::AbstractKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 154; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 154; if (!$this->lookahead(TokenKind::ClassKeyword)) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 152; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 152; $this->advanceToken(); }
                        return new SkippedToken($token);
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 153; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 153; }
                case TokenKind::ClassKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 155; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 155; return $this->parseClassDeclaration($parentNode); }

                // interface-declaration
                case TokenKind::InterfaceKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 156; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 156; return $this->parseInterfaceDeclaration($parentNode); }

                // namespace-definition
                case TokenKind::NamespaceKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 159; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 159; if (!$this->lookahead(TokenKind::BackslashToken)) {
                        // TODO add error handling for the case where a namespace definition does not occur in the outer-most scope
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 157; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 157; return $this->parseNamespaceDefinition($parentNode); }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 158; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 158; }
                    break;

                // namespace-use-declaration
                case TokenKind::UseKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 160; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 160; return $this->parseNamespaceUseDeclaration($parentNode); }

                case TokenKind::SemicolonToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 161; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 161; return $this->parseEmptyStatement($parentNode); }

                case TokenKind::EchoKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 162; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 162; return $this->parseEchoStatement($parentNode); }

                // trait-declaration
                case TokenKind::TraitKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 163; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 163; return $this->parseTraitDeclaration($parentNode); }

                // global-declaration
                case TokenKind::GlobalKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 164; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 164; return $this->parseGlobalDeclaration($parentNode); }

                // const-declaration
                case TokenKind::ConstKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 165; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 165; return $this->parseConstDeclaration($parentNode); }

                // function-static-declaration
                case TokenKind::StaticKeyword:
                    // Check that this is not an anonymous-function-creation-expression
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 168; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 168; if (!$this->lookahead([TokenKind::FunctionKeyword, TokenKind::FnKeyword, TokenKind::OpenParenToken, TokenKind::ColonColonToken])) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 166; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 166; return $this->parseFunctionStaticDeclaration($parentNode); }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 167; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 167; }
                    break;

                case TokenKind::ScriptSectionEndTag:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 169; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 169; return $this->parseInlineHtml($parentNode); }

                case TokenKind::UnsetKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 170; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 170; return $this->parseUnsetStatement($parentNode); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 171; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 171;

            $expressionStatement = new ExpressionStatement();
            $expressionStatement->parent = $parentNode;
            $expressionStatement->expression = $this->parseExpression($expressionStatement, true);
            $expressionStatement->semicolon = $this->eatSemicolonOrAbortStatement();
            return $expressionStatement;
        }; }
    }

    private function parseClassElementFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 183; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 183; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 182; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 182; $modifiers = $this->parseModifiers(); }

            $token = $this->getCurrentToken();
            switch ($token->kind) {
                case TokenKind::ConstKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 174; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 174; return $this->parseClassConstDeclaration($parentNode, $modifiers); }

                case TokenKind::FunctionKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 175; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 175; return $this->parseMethodDeclaration($parentNode, $modifiers); }

                case TokenKind::QuestionToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 176; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 176; return $this->parseRemainingPropertyDeclarationOrMissingMemberDeclaration(
                        $parentNode,
                        $modifiers,
                        $this->eat1(TokenKind::QuestionToken)
                    ); }
                case TokenKind::VariableName:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 177; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 177; return $this->parsePropertyDeclaration($parentNode, $modifiers); }

                case TokenKind::UseKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 178; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 178; return $this->parseTraitUseClause($parentNode); }

                case TokenKind::AttributeToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 179; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 179; return $this->parseAttributeStatement($parentNode); }

                default:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 180; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 180; return $this->parseRemainingPropertyDeclarationOrMissingMemberDeclaration($parentNode, $modifiers); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 181; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 181;
        }; }
    }

    private function parseClassDeclaration($parentNode) : Node {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 184; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 184; $classNode = new ClassDeclaration(); } // TODO verify not nested
        $classNode->parent = $parentNode;
        $classNode->abstractOrFinalModifier = $this->eatOptional(TokenKind::AbstractKeyword, TokenKind::FinalKeyword);
        $classNode->classKeyword = $this->eat1(TokenKind::ClassKeyword);
        $classNode->name = $this->eat($this->nameOrReservedWordTokens); // TODO should be any
        $classNode->name->kind = TokenKind::Name;
        $classNode->classBaseClause = $this->parseClassBaseClause($classNode);
        $classNode->classInterfaceClause = $this->parseClassInterfaceClause($classNode);
        $classNode->classMembers = $this->parseClassMembers($classNode);
        return $classNode;
    }

    private function parseClassMembers($parentNode) : Node {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 185; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 185; $classMembers = new ClassMembersNode(); }
        $classMembers->openBrace = $this->eat1(TokenKind::OpenBraceToken);
        $classMembers->classMemberDeclarations = $this->parseList($classMembers, ParseContext::ClassMembers);
        $classMembers->closeBrace = $this->eat1(TokenKind::CloseBraceToken);
        $classMembers->parent = $parentNode;
        return $classMembers;
    }

    private function parseFunctionDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 186; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 186; $functionNode = new FunctionDeclaration(); }
        $this->parseFunctionType($functionNode);
        $functionNode->parent = $parentNode;
        return $functionNode;
    }

    /**
     * @return Node
     */
    private function parseAttributeExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 198; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 198; $attributeGroups = $this->parseAttributeGroups(null); }
        // Warn about invalid syntax for attributed declarations
        // Lookahead for static, function, or fn for the only type of expressions that can have attributes (anonymous functions)
        if (in_array($this->token->kind, [TokenKind::FunctionKeyword, TokenKind::FnKeyword], true) ||
            \PhpFuzzer\FuzzingContext::traceBlock(188, $this->token->kind === TokenKind::StaticKeyword && \PhpFuzzer\FuzzingContext::traceBlock(187, $this->lookahead([TokenKind::FunctionKeyword, TokenKind::FnKeyword])))) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 190; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 190; $expression = $this->parsePrimaryExpression($parentNode); }
        } else {
            // Create a MissingToken so that diagnostics indicate that the attributes did not match up with an expression/declaration.
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 189; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 189; $expression = new MissingDeclaration(); }
            $expression->parent = $parentNode;
            $expression->declaration = new MissingToken(TokenKind::Expression, $this->token->fullStart);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 191; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 191;
        if ($expression instanceof AnonymousFunctionCreationExpression ||
            \PhpFuzzer\FuzzingContext::traceBlock(192, $expression instanceof ArrowFunctionCreationExpression) ||
            \PhpFuzzer\FuzzingContext::traceBlock(193, $expression instanceof MissingDeclaration)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 196; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 196; $expression->attributes = $attributeGroups; }
            foreach ($attributeGroups as $attributeGroup) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 194; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 194; $attributeGroup->parent = $expression; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 195; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 195;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 197; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 197;
        return $expression;
    }

    /**
     * Precondition: The next token is an AttributeToken
     * @return Node
     */
    private function parseAttributeStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 220; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 220; $attributeGroups = $this->parseAttributeGroups(null); }
        if ($parentNode instanceof ClassMembersNode) {
            // Create a class element or a MissingMemberDeclaration
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 207; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 207; $statement = $this->parseClassElementFn()($parentNode); }
        } elseif ($parentNode instanceof TraitMembers) {
            // Create a trait element or a MissingMemberDeclaration
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 199; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 199; $statement = $this->parseTraitElementFn()($parentNode); }
        } elseif ($parentNode instanceof InterfaceMembers) {
            // Create an interface element or a MissingMemberDeclaration
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 200; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 200; $statement = $this->parseInterfaceElementFn()($parentNode); }
        } else {
            // Classlikes, anonymous functions, global functions, and arrow functions can have attributes. Global constants cannot.
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 206; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 206; if (in_array($this->token->kind, [TokenKind::ClassKeyword, TokenKind::TraitKeyword, TokenKind::InterfaceKeyword, TokenKind::AbstractKeyword, TokenKind::FinalKeyword, TokenKind::FunctionKeyword, TokenKind::FnKeyword], true) ||
                \PhpFuzzer\FuzzingContext::traceBlock(202, $this->token->kind === TokenKind::StaticKeyword && \PhpFuzzer\FuzzingContext::traceBlock(201, $this->lookahead([TokenKind::FunctionKeyword, TokenKind::FnKeyword])))) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 204; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 204; $statement = $this->parseStatement($parentNode); }
            } else {
                // Create a MissingToken so that diagnostics indicate that the attributes did not match up with an expression/declaration.
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 203; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 203; $statement = new MissingDeclaration(); }
                $statement->parent = $parentNode;
                $statement->declaration = new MissingToken(TokenKind::Expression, $this->token->fullStart);
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 205; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 205; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 208; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 208;

        if ($statement instanceof FunctionLike ||
            \PhpFuzzer\FuzzingContext::traceBlock(209, $statement instanceof ClassDeclaration) ||
            \PhpFuzzer\FuzzingContext::traceBlock(210, $statement instanceof TraitDeclaration) ||
            \PhpFuzzer\FuzzingContext::traceBlock(211, $statement instanceof InterfaceDeclaration) ||
            \PhpFuzzer\FuzzingContext::traceBlock(212, $statement instanceof ClassConstDeclaration) ||
            \PhpFuzzer\FuzzingContext::traceBlock(213, $statement instanceof PropertyDeclaration) ||
            \PhpFuzzer\FuzzingContext::traceBlock(214, $statement instanceof MissingDeclaration) ||
            \PhpFuzzer\FuzzingContext::traceBlock(215, $statement instanceof MissingMemberDeclaration)) {

            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 218; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 218; $statement->attributes = $attributeGroups; }
            foreach ($attributeGroups as $attributeGroup) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 216; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 216; $attributeGroup->parent = $statement; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 217; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 217;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 219; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 219;
        return $statement;
    }

    /**
     * @param Node|null $parentNode
     * @return AttributeGroup[]
     */
    private function parseAttributeGroups($parentNode): array
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 223; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 223; $attributeGroups = []; }
        while ($attributeToken = $this->eatOptional1(TokenKind::AttributeToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 222; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 222; $attributeGroup = new AttributeGroup(); }
            $attributeGroup->startToken = $attributeToken;
            $attributeGroup->attributes = $this->parseAttributeElementList($attributeGroup)
                ?: (\PhpFuzzer\FuzzingContext::traceBlock(221, new MissingToken(TokenKind::Name, $this->token->fullStart)));
            $attributeGroup->endToken = $this->eat1(TokenKind::CloseBracketToken);
            $attributeGroup->parent = $parentNode;
            $attributeGroups[] = $attributeGroup;
        }
        return $attributeGroups;
    }

    /**
     * @return DelimitedList\AttributeElementList
     */
    private function parseAttributeElementList(AttributeGroup $parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 224; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 224; return $this->parseDelimitedList(
            DelimitedList\AttributeElementList::class,
            TokenKind::CommaToken,
            $this->isQualifiedNameStartFn(),
            $this->parseAttributeFn(),
            $parentNode,
            false); }
    }

    private function parseAttributeFn()
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 228; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 228; return function ($parentNode): Attribute {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 227; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 227; $attribute = new Attribute(); }
            $attribute->parent = $parentNode;
            $attribute->name = $this->parseQualifiedName($attribute);
            $attribute->openParen = $this->eatOptional1(TokenKind::OpenParenToken);
            if ($attribute->openParen) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 225; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 225; $attribute->argumentExpressionList = $this->parseArgumentExpressionList($attribute); }
                $attribute->closeParen = $this->eat1(TokenKind::CloseParenToken);
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 226; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 226;
            return $attribute;
        }; }
    }

    private function parseMethodDeclaration($parentNode, $modifiers) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 229; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 229; $methodDeclaration = new MethodDeclaration(); }
        $methodDeclaration->modifiers = $modifiers;
        $this->parseFunctionType($methodDeclaration, true);
        $methodDeclaration->parent = $parentNode;
        return $methodDeclaration;
    }

    private function parseParameterFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 239; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 239; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 238; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 238; $parameter = new Parameter(); }
            $parameter->parent = $parentNode;
            if ($this->token->kind === TokenKind::AttributeToken) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 230; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 230; $parameter->attributes = $this->parseAttributeGroups($parameter); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 231; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 231;
            $parameter->visibilityToken = $this->eatOptional([TokenKind::PublicKeyword, TokenKind::ProtectedKeyword, TokenKind::PrivateKeyword]);
            $parameter->questionToken = $this->eatOptional1(TokenKind::QuestionToken);
            $typeDeclarationList = $this->tryParseParameterTypeDeclarationList($parameter);
            if ($typeDeclarationList) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 234; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 234; $parameter->typeDeclaration = array_shift($typeDeclarationList->children); }
                $parameter->typeDeclaration->parent = $parameter;
                if ($typeDeclarationList->children) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 232; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 232; $parameter->otherTypeDeclarations = $typeDeclarationList; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 233; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 233;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 235; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 235;
            $parameter->byRefToken = $this->eatOptional1(TokenKind::AmpersandToken);
            // TODO add post-parse rule that prevents assignment
            // TODO add post-parse rule that requires only last parameter be variadic
            $parameter->dotDotDotToken = $this->eatOptional1(TokenKind::DotDotDotToken);
            $parameter->variableName = $this->eat1(TokenKind::VariableName);
            $parameter->equalsToken = $this->eatOptional1(TokenKind::EqualsToken);
            if ($parameter->equalsToken !== null) {
                // TODO add post-parse rule that checks for invalid assignments
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 236; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 236; $parameter->default = $this->parseExpression($parameter); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 237; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 237;
            return $parameter;
        }; }
    }

    /**
     * @param ArrowFunctionCreationExpression|AnonymousFunctionCreationExpression|FunctionDeclaration|MethodDeclaration $parentNode a node with FunctionReturnType trait
     */
    private function parseAndSetReturnTypeDeclarationList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 244; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 244; $returnTypeList = $this->parseReturnTypeDeclarationList($parentNode); }
        if (!$returnTypeList)  {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 240; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 240; $parentNode->returnType = new MissingToken(TokenKind::ReturnType, $this->token->fullStart); }
            return;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 241; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 241;
        $returnType = array_shift($returnTypeList->children);
        $parentNode->returnType = $returnType;
        $returnType->parent = $parentNode;
        if ($returnTypeList->children) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 242; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 242; $parentNode->otherReturnTypes = $returnTypeList; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 243; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 243;
    }

    /**
     * Attempt to parse the return type after the `:` and optional `?` token.
     *
     * @return DelimitedList\QualifiedNameList|null
     */
    private function parseReturnTypeDeclarationList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 252; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 252; $result = $this->parseDelimitedList(
            DelimitedList\QualifiedNameList::class,
            TokenKind::BarToken,
            function ($token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 246; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 246; return \in_array($token->kind, $this->returnTypeDeclarationTokens, true) || \PhpFuzzer\FuzzingContext::traceBlock(245, $this->isQualifiedNameStart($token)); }
            },
            function ($parentNode) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 247; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 247; return $this->parseReturnTypeDeclaration($parentNode); }
            },
            $parentNode,
            false); }

        // Add a MissingToken so that this will warn about `function () : T| {}`
        // TODO: Make this a reusable abstraction?
        if ($result && \PhpFuzzer\FuzzingContext::traceBlock(249, (end($result->children)->kind ?? \PhpFuzzer\FuzzingContext::traceBlock(248, null)) === TokenKind::BarToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 250; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 250; $result->children[] = new MissingToken(TokenKind::ReturnType, $this->token->fullStart); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 251; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 251;
        return $result;
    }

    private function parseReturnTypeDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 254; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 254; return $this->eatOptional($this->returnTypeDeclarationTokens)
            ?? \PhpFuzzer\FuzzingContext::traceBlock(253, $this->parseQualifiedName($parentNode)); }
    }

    private function tryParseParameterTypeDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 256; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 256; $parameterTypeDeclaration =
            $this->eatOptional($this->parameterTypeDeclarationTokens) ?? \PhpFuzzer\FuzzingContext::traceBlock(255, $this->parseQualifiedName($parentNode)); }
        return $parameterTypeDeclaration;
    }

    /**
     * @param Node $parentNode
     * @return DelimitedList\QualifiedNameList|null
     */
    private function tryParseParameterTypeDeclarationList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 264; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 264; $result = $this->parseDelimitedList(
            DelimitedList\QualifiedNameList::class,
            TokenKind::BarToken,
            function ($token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 258; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 258; return \in_array($token->kind, $this->parameterTypeDeclarationTokens, true) || \PhpFuzzer\FuzzingContext::traceBlock(257, $this->isQualifiedNameStart($token)); }
            },
            function ($parentNode) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 259; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 259; return $this->tryParseParameterTypeDeclaration($parentNode); }
            },
            $parentNode,
            true); }

        // Add a MissingToken so that this will Warn about `function (T| $x) {}`
        // TODO: Make this a reusable abstraction?
        if ($result && \PhpFuzzer\FuzzingContext::traceBlock(261, (end($result->children)->kind ?? \PhpFuzzer\FuzzingContext::traceBlock(260, null)) === TokenKind::BarToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 262; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 262; $result->children[] = new MissingToken(TokenKind::Name, $this->token->fullStart); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 263; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 263;
        return $result;
    }

    private function parseCompoundStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 265; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 265; $compoundStatement = new CompoundStatementNode(); }
        $compoundStatement->openBrace = $this->eat1(TokenKind::OpenBraceToken);
        $compoundStatement->statements =  $this->parseList($compoundStatement, ParseContext::BlockStatements);
        $compoundStatement->closeBrace = $this->eat1(TokenKind::CloseBraceToken);
        $compoundStatement->parent = $parentNode;
        return $compoundStatement;
    }

    private function array_push_list(& $array, $list) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 268; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 268; foreach ($list as $item) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 266; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 266; $array[] = $item; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 267; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 267; }
    }

    private function isClassMemberDeclarationStart(Token $token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 281; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 281; switch ($token->kind) {
            // const-modifier
            case TokenKind::ConstKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 269; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 269;

            // visibility-modifier
            case TokenKind::PublicKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 270; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 270;
            case TokenKind::ProtectedKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 271; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 271;
            case TokenKind::PrivateKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 272; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 272;

            // static-modifier
            case TokenKind::StaticKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 273; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 273;

            // class-modifier
            case TokenKind::AbstractKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 274; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 274;
            case TokenKind::FinalKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 275; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 275;

            case TokenKind::VarKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 276; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 276;

            case TokenKind::FunctionKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 277; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 277;

            case TokenKind::UseKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 278; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 278;

            // attributes
            case TokenKind::AttributeToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 279; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 279; return true; }

        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 280; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 280; }

        return false;
    }

    private function isStatementStart(Token $token) {
        // https://github.com/php/php-langspec/blob/master/spec/19-grammar.md#statements
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 313; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 313; switch ($token->kind) {
            // Compound Statements
            case TokenKind::OpenBraceToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 282; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 282;

            // Labeled Statements
            case TokenKind::Name: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 283; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 283;
//            case TokenKind::CaseKeyword: // TODO update spec
//            case TokenKind::DefaultKeyword:

            // Expression Statements
            case TokenKind::SemicolonToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 284; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 284;
            case TokenKind::IfKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 285; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 285;
            case TokenKind::SwitchKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 286; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 286;

            // Iteration Statements
            case TokenKind::WhileKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 287; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 287;
            case TokenKind::DoKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 288; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 288;
            case TokenKind::ForKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 289; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 289;
            case TokenKind::ForeachKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 290; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 290;

            // Jump Statements
            case TokenKind::GotoKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 291; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 291;
            case TokenKind::ContinueKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 292; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 292;
            case TokenKind::BreakKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 293; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 293;
            case TokenKind::ReturnKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 294; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 294;
            case TokenKind::ThrowKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 295; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 295;

            // The try Statement
            case TokenKind::TryKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 296; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 296;

            // The declare Statement
            case TokenKind::DeclareKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 297; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 297;

            // const-declaration
            case TokenKind::ConstKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 298; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 298;

            // function-definition
            case TokenKind::FunctionKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 299; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 299;

            // class-declaration
            case TokenKind::ClassKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 300; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 300;
            case TokenKind::AbstractKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 301; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 301;
            case TokenKind::FinalKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 302; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 302;

            // interface-declaration
            case TokenKind::InterfaceKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 303; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 303;

            // trait-declaration
            case TokenKind::TraitKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 304; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 304;

            // namespace-definition
            case TokenKind::NamespaceKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 305; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 305;

            // namespace-use-declaration
            case TokenKind::UseKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 306; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 306;

            // global-declaration
            case TokenKind::GlobalKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 307; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 307;

            // function-static-declaration
            case TokenKind::StaticKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 308; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 308;

            case TokenKind::ScriptSectionEndTag: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 309; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 309;

            // attributes
            case TokenKind::AttributeToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 310; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 310; return true; }

            default:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 311; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 311; return $this->isExpressionStart($token); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 312; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 312; }
    }

    private function isExpressionStart($token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 314; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 314; return ($this->isExpressionStartFn())($token); }
    }

    private function isExpressionStartFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 375; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 375; return function ($token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 374; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 374; switch ($token->kind) {
                // Script Inclusion Expression
                case TokenKind::RequireKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 315; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 315;
                case TokenKind::RequireOnceKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 316; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 316;
                case TokenKind::IncludeKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 317; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 317;
                case TokenKind::IncludeOnceKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 318; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 318;

                // yield-expression
                case TokenKind::YieldKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 319; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 319;
                case TokenKind::YieldFromKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 320; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 320;

                // object-creation-expression
                case TokenKind::NewKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 321; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 321;
                case TokenKind::CloneKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 322; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 322; return true; }

                // unary-op-expression
                case TokenKind::PlusToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 323; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 323;
                case TokenKind::MinusToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 324; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 324;
                case TokenKind::ExclamationToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 325; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 325;
                case TokenKind::TildeToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 326; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 326;

                // error-control-expression
                case TokenKind::AtSymbolToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 327; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 327;

                // prefix-increment-expression
                case TokenKind::PlusPlusToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 328; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 328;
                // prefix-decrement-expression
                case TokenKind::MinusMinusToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 329; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 329; return true; }

                // variable-name
                case TokenKind::VariableName: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 330; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 330;
                case TokenKind::DollarToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 331; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 331; return true; }

                // qualified-name
                case TokenKind::Name: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 332; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 332;
                case TokenKind::BackslashToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 333; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 333; return true; }
                case TokenKind::NamespaceKeyword:
                    // TODO currently only supports qualified-names, but eventually parse namespace declarations
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 334; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 334; return $this->isNamespaceKeywordStartOfExpression($token); }

                // literal
                case TokenKind::DecimalLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 335; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 335; // TODO merge dec, oct, hex, bin, float -> NumericLiteral
                case TokenKind::OctalLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 336; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 336;
                case TokenKind::HexadecimalLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 337; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 337;
                case TokenKind::BinaryLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 338; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 338;
                case TokenKind::FloatingLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 339; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 339;
                case TokenKind::InvalidOctalLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 340; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 340;
                case TokenKind::InvalidHexadecimalLiteral: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 341; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 341;
                case TokenKind::InvalidBinaryLiteral: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 342; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 342;
                case TokenKind::IntegerLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 343; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 343;

                case TokenKind::StringLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 344; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 344;

                case TokenKind::SingleQuoteToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 345; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 345;
                case TokenKind::DoubleQuoteToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 346; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 346;
                case TokenKind::HeredocStart: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 347; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 347;
                case TokenKind::BacktickToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 348; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 348;

                // array-creation-expression
                case TokenKind::ArrayKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 349; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 349;
                case TokenKind::OpenBracketToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 350; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 350;

                // intrinsic-construct
                case TokenKind::EchoKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 351; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 351;
                case TokenKind::ListKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 352; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 352;
                case TokenKind::UnsetKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 353; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 353;

                // intrinsic-operator
                case TokenKind::EmptyKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 354; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 354;
                case TokenKind::EvalKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 355; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 355;
                case TokenKind::ExitKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 356; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 356;
                case TokenKind::DieKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 357; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 357;
                case TokenKind::IsSetKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 358; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 358;
                case TokenKind::PrintKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 359; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 359;

                // ( expression )
                case TokenKind::OpenParenToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 360; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 360;
                case TokenKind::ArrayCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 361; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 361;
                case TokenKind::BoolCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 362; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 362;
                case TokenKind::DoubleCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 363; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 363;
                case TokenKind::IntCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 364; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 364;
                case TokenKind::ObjectCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 365; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 365;
                case TokenKind::StringCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 366; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 366;
                case TokenKind::UnsetCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 367; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 367;
                case TokenKind::MatchKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 368; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 368;

                // anonymous-function-creation-expression
                case TokenKind::StaticKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 369; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 369;
                case TokenKind::FunctionKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 370; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 370;
                case TokenKind::FnKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 371; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 371;
                case TokenKind::AttributeToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 372; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 372; return true; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 373; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 373; }
            return \in_array($token->kind, $this->reservedWordTokens, true);
        }; }
    }

    /**
     * Handles the fact that $token may either be getCurrentToken or the token immediately before it in isExpressionStartFn().
     * An expression can be namespace\CONST, namespace\fn(), or namespace\ClassName
     */
    private function isNamespaceKeywordStartOfExpression(Token $token) : bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 380; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 380; $nextToken = $this->getCurrentToken(); }
        if ($nextToken->kind === TokenKind::BackslashToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 376; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 376; return true; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 377; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 377;
        if ($nextToken !== $token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 378; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 378; return false; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 379; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 379;
        $oldPosition = $this->lexer->getCurrentPosition();
        $nextToken = $this->lexer->scanNextToken();
        $this->lexer->setCurrentPosition($oldPosition);
        return $nextToken->kind === TokenKind::BackslashToken;
    }

    /**
     * @param Node $parentNode
     * @return Token|MissingToken|Node
     */
    private function parsePrimaryExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 425; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 425; $token = $this->getCurrentToken(); }
        switch ($token->kind) {
            // variable-name
            case TokenKind::VariableName: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 381; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 381; // TODO special case $this
            case TokenKind::DollarToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 382; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 382; return $this->parseSimpleVariable($parentNode); }

            // qualified-name
            case TokenKind::Name: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 383; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 383; // TODO Qualified name
            case TokenKind::BackslashToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 384; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 384;
            case TokenKind::NamespaceKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 385; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 385; return $this->parseQualifiedName($parentNode); }

            case TokenKind::DecimalLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 386; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 386; // TODO merge dec, oct, hex, bin, float -> NumericLiteral
            case TokenKind::OctalLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 387; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 387;
            case TokenKind::HexadecimalLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 388; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 388;
            case TokenKind::BinaryLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 389; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 389;
            case TokenKind::FloatingLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 390; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 390;
            case TokenKind::InvalidOctalLiteralToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 391; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 391;
            case TokenKind::InvalidHexadecimalLiteral: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 392; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 392;
            case TokenKind::InvalidBinaryLiteral: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 393; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 393;
            case TokenKind::IntegerLiteralToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 394; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 394; return $this->parseNumericLiteralExpression($parentNode); }

            case TokenKind::StringLiteralToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 395; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 395; return $this->parseStringLiteralExpression($parentNode); }

            case TokenKind::DoubleQuoteToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 396; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 396;
            case TokenKind::SingleQuoteToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 397; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 397;
            case TokenKind::HeredocStart: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 398; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 398;
            case TokenKind::BacktickToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 399; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 399; return $this->parseStringLiteralExpression2($parentNode); }

            // TODO constant-expression

            // array-creation-expression
            case TokenKind::ArrayKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 400; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 400;
            case TokenKind::OpenBracketToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 401; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 401; return $this->parseArrayCreationExpression($parentNode); }

            // intrinsic-construct
            case TokenKind::ListKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 402; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 402; return $this->parseListIntrinsicExpression($parentNode); }

            // intrinsic-operator
            case TokenKind::EmptyKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 403; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 403; return $this->parseEmptyIntrinsicExpression($parentNode); }
            case TokenKind::EvalKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 404; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 404; return $this->parseEvalIntrinsicExpression($parentNode); }

            case TokenKind::ExitKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 405; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 405;
            case TokenKind::DieKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 406; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 406; return $this->parseExitIntrinsicExpression($parentNode); }

            case TokenKind::IsSetKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 407; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 407; return $this->parseIssetIntrinsicExpression($parentNode); }

            case TokenKind::PrintKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 408; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 408; return $this->parsePrintIntrinsicExpression($parentNode); }

            // ( expression )
            case TokenKind::OpenParenToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 409; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 409; return $this->parseParenthesizedExpression($parentNode); }

            // anonymous-function-creation-expression
            case TokenKind::AttributeToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 410; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 410; return $this->parseAttributeExpression($parentNode); }

            case TokenKind::StaticKeyword:
                // handle `static::`, `static(`, `new static;`, `instanceof static`
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 413; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 413; if (!$this->lookahead([TokenKind::FunctionKeyword, TokenKind::FnKeyword])) {
                    // TODO: Should this check the parent type to reject `$x = static;`, `$x = static();`, etc.
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 411; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 411; return $this->parseStaticQualifiedName($parentNode); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 412; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 412; }
                // Could be `static function` anonymous function creation expression, so flow through
            case TokenKind::FunctionKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 414; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 414;
            case TokenKind::FnKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 415; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 415; return $this->parseAnonymousFunctionCreationExpression($parentNode); }

            case TokenKind::TrueReservedWord: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 416; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 416;
            case TokenKind::FalseReservedWord: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 417; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 417;
            case TokenKind::NullReservedWord:
                // handle `true::`, `true(`, `true\`
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 420; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 420; if ($this->lookahead([TokenKind::BackslashToken, TokenKind::ColonColonToken, TokenKind::OpenParenToken])) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 418; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 418; return $this->parseQualifiedName($parentNode); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 419; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 419; }
                return $this->parseReservedWordExpression($parentNode);
            case TokenKind::MatchKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 421; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 421; return $this->parseMatchExpression($parentNode); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 422; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 422;
        if (\in_array($token->kind, TokenStringMaps::RESERVED_WORDS)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 423; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 423; return $this->parseQualifiedName($parentNode); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 424; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 424;

        return new MissingToken(TokenKind::Expression, $token->fullStart);
    }

    private function parseEmptyStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 426; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 426; $emptyStatement = new EmptyStatement(); }
        $emptyStatement->parent = $parentNode;
        $emptyStatement->semicolon = $this->eat1(TokenKind::SemicolonToken);
        return $emptyStatement;
    }

    private function parseStringLiteralExpression($parentNode) {
        // TODO validate input token
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 427; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 427; $expression = new StringLiteral(); }
        $expression->parent = $parentNode;
        $expression->children = $this->getCurrentToken(); // TODO - merge string types
        $this->advanceToken();
        return $expression;
    }

    private function parseStringLiteralExpression2($parentNode) {
        // TODO validate input token
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 440; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 440; $expression = new StringLiteral(); }
        $expression->parent = $parentNode;
        $expression->startQuote = $this->eat(TokenKind::SingleQuoteToken, TokenKind::DoubleQuoteToken, TokenKind::HeredocStart, TokenKind::BacktickToken);
        $expression->children = array();

        while (true) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 439; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 439; switch ($this->getCurrentToken()->kind) {
                case TokenKind::DollarOpenBraceToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 428; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 428;
                case TokenKind::OpenBraceDollarToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 432; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 432; $expression->children[] = $this->eat(TokenKind::DollarOpenBraceToken, TokenKind::OpenBraceDollarToken); }
                    // TODO: Reject ${var->prop} and ${(var->prop)} without rejecting ${var+otherVar}
                    // Currently, this fails to reject ${var->prop} (because `var` has TokenKind::Name instead of StringVarname)
                    if ($this->getCurrentToken()->kind === TokenKind::StringVarname) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 430; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 430; $expression->children[] = $this->parseComplexDollarTemplateStringExpression($expression); }
                    } else {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 429; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 429; $expression->children[] = $this->parseExpression($expression); }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 431; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 431;
                    $expression->children[] = $this->eat1(TokenKind::CloseBraceToken);
                    break;
                case $startQuoteKind = $expression->startQuote->kind: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 433; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 433;
                case TokenKind::EndOfFileToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 434; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 434;
                case TokenKind::HeredocEnd:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 435; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 435; $expression->endQuote = $this->eat($startQuoteKind, TokenKind::HeredocEnd); }
                    return $expression;
                case TokenKind::VariableName:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 436; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 436; $expression->children[] = $this->parseTemplateStringExpression($expression); }
                    break;
                default:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 437; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 437; $expression->children[] = $this->getCurrentToken(); }
                    $this->advanceToken();
                    break;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 438; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 438; }
        }
    }

    /**
     * This is used to parse the contents of `"${...}"` expressions.
     *
     * Supported: x, x[0], x[$y]
     * Not supported: $x->p1, x[0][1], etc.
     * @see parseTemplateStringExpression
     *
     * Precondition: getCurrentToken()->kind === TokenKind::StringVarname
     */
    private function parseComplexDollarTemplateStringExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 443; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 443; $var = $this->parseSimpleVariable($parentNode); }
        $token = $this->getCurrentToken();
        if ($token->kind === TokenKind::OpenBracketToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 441; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 441; return $this->parseTemplateStringSubscriptExpression($var); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 442; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 442;
        return $var;
    }

    /**
     * Double-quoted and heredoc strings support a basic set of expression types, described in http://php.net/manual/en/language.types.string.php#language.types.string.parsing
     * Supported: $x, $x->p, $x[0], $x[$y]
     * Not supported: $x->p1->p2, $x[0][1], etc.
     * Since there is a relatively small finite set of allowed forms, I implement it here rather than trying to reuse the general expression parsing code.
     */
    private function parseTemplateStringExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 453; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 453; $token = $this->getCurrentToken(); }
        if ($token->kind === TokenKind::VariableName) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 451; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 451; $var = $this->parseSimpleVariable($parentNode); }
            $token = $this->getCurrentToken();
            if ($token->kind === TokenKind::OpenBracketToken) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 449; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 449; return $this->parseTemplateStringSubscriptExpression($var); }
            } else { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 448; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 448; if ($token->kind === TokenKind::ArrowToken || \PhpFuzzer\FuzzingContext::traceBlock(444, $token->kind === TokenKind::QuestionArrowToken)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 446; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 446; return $this->parseTemplateStringMemberAccessExpression($var); }
            } else {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 445; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 445; return $var; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 447; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 447; $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 450; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 450; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 452; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 452;

        return null;
    }

    private function parseTemplateStringSubscriptExpression($postfixExpression) : SubscriptExpression {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 460; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 460; $subscriptExpression = new SubscriptExpression(); }
        $subscriptExpression->parent = $postfixExpression->parent;
        $postfixExpression->parent = $subscriptExpression;

        $subscriptExpression->postfixExpression = $postfixExpression;
        $subscriptExpression->openBracketOrBrace = $this->eat1(TokenKind::OpenBracketToken); // Only [] syntax is supported, not {}
        $token = $this->getCurrentToken();
        if ($token->kind === TokenKind::VariableName) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 458; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 458; $subscriptExpression->accessExpression = $this->parseSimpleVariable($subscriptExpression); }
        } elseif ($token->kind === TokenKind::IntegerLiteralToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 454; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 454; $subscriptExpression->accessExpression = $this->parseNumericLiteralExpression($subscriptExpression); }
        } elseif ($token->kind === TokenKind::StringLiteralToken) {
            // TODO: investigate if this should add other uncommon types of tokens for strings/numbers mentioned in parsePrimaryExpression()
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 455; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 455; $subscriptExpression->accessExpression = $this->parseStringLiteralExpression($subscriptExpression); }
        } elseif ($token->kind === TokenKind::Name) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 456; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 456; $subscriptExpression->accessExpression = $this->parseTemplateStringSubscriptStringLiteral($subscriptExpression); }
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 457; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 457; $subscriptExpression->accessExpression = new MissingToken(TokenKind::Expression, $token->fullStart); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 459; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 459;

        $subscriptExpression->closeBracketOrBrace = $this->eat1(TokenKind::CloseBracketToken);

        return $subscriptExpression;
    }

    private function parseTemplateStringSubscriptStringLiteral($parentNode) : StringLiteral {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 461; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 461; $expression = new StringLiteral(); }
        $expression->parent = $parentNode;
        $expression->children = $this->eat1(TokenKind::Name);
        return $expression;
    }

    private function parseTemplateStringMemberAccessExpression($expression) : MemberAccessExpression {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 462; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 462; $memberAccessExpression = new MemberAccessExpression(); }
        $memberAccessExpression->parent = $expression->parent;
        $expression->parent = $memberAccessExpression;

        $memberAccessExpression->dereferencableExpression = $expression;
        $memberAccessExpression->arrowToken = $this->eat(TokenKind::ArrowToken, TokenKind::QuestionArrowToken);
        $memberAccessExpression->memberName = $this->eat1(TokenKind::Name);

        return $memberAccessExpression;
    }

    private function parseNumericLiteralExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 463; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 463; $numericLiteral = new NumericLiteral(); }
        $numericLiteral->parent = $parentNode;
        $numericLiteral->children = $this->getCurrentToken();
        $this->advanceToken();
        return $numericLiteral;
    }

    private function parseReservedWordExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 464; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 464; $reservedWord = new ReservedWord(); }
        $reservedWord->parent = $parentNode;
        $reservedWord->children = $this->getCurrentToken();
        $this->advanceToken();
        return $reservedWord;
    }

    private function isModifier($token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 473; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 473; switch ($token->kind) {
            // class-modifier
            case TokenKind::AbstractKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 465; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 465;
            case TokenKind::FinalKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 466; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 466;

            // visibility-modifier
            case TokenKind::PublicKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 467; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 467;
            case TokenKind::ProtectedKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 468; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 468;
            case TokenKind::PrivateKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 469; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 469;

            // static-modifier
            case TokenKind::StaticKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 470; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 470;

            // var
            case TokenKind::VarKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 471; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 471; return true; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 472; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 472; }
        return false;
    }

    private function parseModifiers() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 475; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 475; $modifiers = array(); }
        $token = $this->getCurrentToken();
        while ($this->isModifier($token)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 474; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 474; $modifiers[] = $token; }
            $this->advanceToken();
            $token = $this->getCurrentToken();
        }
        return $modifiers;
    }

    private function isParameterStartFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 489; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 489; return function ($token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 488; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 488; switch ($token->kind) {
                case TokenKind::DotDotDotToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 476; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 476;

                // qualified-name
                case TokenKind::Name: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 477; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 477; // http://php.net/manual/en/language.namespaces.rules.php
                case TokenKind::BackslashToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 478; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 478;
                case TokenKind::NamespaceKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 479; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 479;

                case TokenKind::AmpersandToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 480; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 480;

                case TokenKind::VariableName: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 481; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 481;

                // nullable-type
                case TokenKind::QuestionToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 482; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 482;

                // parameter promotion
                case TokenKind::PublicKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 483; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 483;
                case TokenKind::ProtectedKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 484; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 484;
                case TokenKind::PrivateKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 485; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 485;
                case TokenKind::AttributeToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 486; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 486; return true; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 487; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 487; }

            // scalar-type
            return \in_array($token->kind, $this->parameterTypeDeclarationTokens, true);
        }; }
    }

    /**
     * @param string $className (name of subclass of DelimitedList)
     * @param int $delimiter
     * @param callable $isElementStartFn
     * @param callable $parseElementFn
     * @param Node $parentNode
     * @param bool $allowEmptyElements
     * @return DelimitedList|null instance of $className
     */
    private function parseDelimitedList($className, $delimiter, $isElementStartFn, $parseElementFn, $parentNode, $allowEmptyElements = false) {
        // TODO consider allowing empty delimiter to be more tolerant
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 501; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 501; $node = new $className(); }
        $token = $this->getCurrentToken();
        $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 497; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 497; do {
            if ($isElementStartFn($token)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 493; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 493; $node->addElement($parseElementFn($node)); }
            } elseif (!$allowEmptyElements || (\PhpFuzzer\FuzzingContext::traceBlock(491, $allowEmptyElements && \PhpFuzzer\FuzzingContext::traceBlock(490, !$this->checkToken($delimiter))))) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 492; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 492; break; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 494; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 494;

            $delimiterToken = $this->eatOptional($delimiter);
            if ($delimiterToken !== null) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 495; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 495; $node->addElement($delimiterToken); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 496; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 496;
            $token = $this->getCurrentToken();
            // TODO ERROR CASE - no delimiter, but a param follows
        } while ($delimiterToken !== null); $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 498; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 498;


        $node->parent = $parentNode;
        if ($node->children === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 499; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 499; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 500; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 500;
        return $node;
    }

    /**
     * @internal
     */
    const QUALIFIED_NAME_START_TOKENS = [
        TokenKind::BackslashToken,
        TokenKind::NamespaceKeyword,
        TokenKind::Name,
    ];

    private function isQualifiedNameStart($token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 502; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 502; return \in_array($token->kind, self::QUALIFIED_NAME_START_TOKENS, true); }
    }

    private function isQualifiedNameStartFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 504; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 504; return function ($token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 503; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 503; return \in_array($token->kind, self::QUALIFIED_NAME_START_TOKENS, true); }
        }; }
    }

    private function isQualifiedNameStartForCatchFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 507; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 507; return function ($token) {
            // Unfortunately, catch(int $x) is *syntactically valid* php which `php --syntax-check` would accept.
            // (tolerant-php-parser is concerned with syntax, not semantics)
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 506; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 506; return \in_array($token->kind, self::QUALIFIED_NAME_START_TOKENS, true) ||
                \PhpFuzzer\FuzzingContext::traceBlock(505, \in_array($token->kind, $this->reservedWordTokens, true)); }
        }; }
    }

    /**
     * @return QualifiedName
     */
    private function parseStaticQualifiedName($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 508; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 508; $node = new QualifiedName(); }
        $token = $this->eat(TokenKind::StaticKeyword);
        $token->kind = TokenKind::Name;
        $node->parent = $parentNode;
        $node->nameParts = [$token];
        return $node;
    }

    /**
     * @return QualifiedName|null - returns null for invalid qualified names such as `static\` (use parseStaticQualifiedName for that)
     */
    private function parseQualifiedName($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 509; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 509; return ($this->parseQualifiedNameFn())($parentNode); }
    }

    private function parseQualifiedNameFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 522; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 522; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 521; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 521; $node = new QualifiedName(); }
            $node->parent = $parentNode;
            $node->relativeSpecifier = $this->parseRelativeSpecifier($node);
            if (!isset($node->relativeSpecifier)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 510; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 510; $node->globalSpecifier = $this->eatOptional1(TokenKind::BackslashToken); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 511; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 511;

            $nameParts =
                $this->parseDelimitedList(
                    DelimitedList\QualifiedNameParts::class,
                    TokenKind::BackslashToken,
                    function ($token) {
                        // a\static() <- INVALID (but not checked for right now)
                        // new a\static() <- INVALID
                        // new static() <- VALID
                        // a\static\b <- INVALID
                        // a\function <- INVALID
                        // a\true\b <-VALID
                        // a\b\true <-VALID
                        // a\static::b <-VALID
                        // TODO more tests
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 513; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 513; return $this->lookahead(TokenKind::BackslashToken)
                            ? in_array($token->kind, $this->nameOrReservedWordTokens)
                            : \PhpFuzzer\FuzzingContext::traceBlock(512, in_array($token->kind, $this->nameOrStaticOrReservedWordTokens)); }
                    },
                    function ($parentNode) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 515; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 515; $name = $this->lookahead(TokenKind::BackslashToken)
                            ? $this->eat($this->nameOrReservedWordTokens)
                            : \PhpFuzzer\FuzzingContext::traceBlock(514, $this->eat($this->nameOrStaticOrReservedWordTokens)); } // TODO support keyword name
                        $name->kind = TokenKind::Name; // bool/true/null/static should not be treated as keywords in this case
                        return $name;
                    }, $node);
            if ($nameParts === null && \PhpFuzzer\FuzzingContext::traceBlock(516, $node->globalSpecifier === null) && \PhpFuzzer\FuzzingContext::traceBlock(517, $node->relativeSpecifier === null)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 518; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 518; return null; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 519; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 519;

            $node->nameParts = $nameParts ? $nameParts->children : \PhpFuzzer\FuzzingContext::traceBlock(520, []);

            return $node;
        }; }
    }

    private function parseRelativeSpecifier($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 527; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 527; $node = new RelativeSpecifier(); }
        $node->parent = $parentNode;
        $node->namespaceKeyword = $this->eatOptional1(TokenKind::NamespaceKeyword);
        if ($node->namespaceKeyword !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 523; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 523; $node->backslash = $this->eat1(TokenKind::BackslashToken); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 524; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 524;
        if (isset($node->backslash)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 525; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 525; return $node; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 526; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 526;
        return null;
    }

    /**
     * @param MethodDeclaration|FunctionDeclaration|AnonymousFunctionCreationExpression $functionDeclaration
     */
    private function parseFunctionType(Node $functionDeclaration, $canBeAbstract = false, $isAnonymous = false) {

        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 542; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 542; $functionDeclaration->functionKeyword = $this->eat1(TokenKind::FunctionKeyword); }
        $functionDeclaration->byRefToken = $this->eatOptional1(TokenKind::AmpersandToken);
        $functionDeclaration->name = $isAnonymous
            ? $this->eatOptional($this->nameOrKeywordOrReservedWordTokens)
            : \PhpFuzzer\FuzzingContext::traceBlock(528, $this->eat($this->nameOrKeywordOrReservedWordTokens));

        if (isset($functionDeclaration->name)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 529; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 529; $functionDeclaration->name->kind = TokenKind::Name; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 530; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 530;

        if ($isAnonymous && \PhpFuzzer\FuzzingContext::traceBlock(531, isset($functionDeclaration->name))) {
            // Anonymous functions should not have names
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 532; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 532; $functionDeclaration->name = new SkippedToken($functionDeclaration->name); } // TODO instead handle this during post-walk
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 533; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 533;

        $functionDeclaration->openParen = $this->eat1(TokenKind::OpenParenToken);
        $functionDeclaration->parameters = $this->parseDelimitedList(
            DelimitedList\ParameterDeclarationList::class,
            TokenKind::CommaToken,
            $this->isParameterStartFn(),
            $this->parseParameterFn(),
            $functionDeclaration);
        $functionDeclaration->closeParen = $this->eat1(TokenKind::CloseParenToken);
        if ($isAnonymous) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 534; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 534; $functionDeclaration->anonymousFunctionUseClause = $this->parseAnonymousFunctionUseClause($functionDeclaration); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 535; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 535;

        if ($this->checkToken(TokenKind::ColonToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 536; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 536; $functionDeclaration->colonToken = $this->eat1(TokenKind::ColonToken); }
            $functionDeclaration->questionToken = $this->eatOptional1(TokenKind::QuestionToken);
            $this->parseAndSetReturnTypeDeclarationList($functionDeclaration);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 537; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 537;

        if ($canBeAbstract) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 538; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 538; $functionDeclaration->compoundStatementOrSemicolon = $this->eatOptional1(TokenKind::SemicolonToken); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 539; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 539;

        if (!isset($functionDeclaration->compoundStatementOrSemicolon)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 540; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 540; $functionDeclaration->compoundStatementOrSemicolon = $this->parseCompoundStatement($functionDeclaration); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 541; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 541;
    }

    private function parseNamedLabelStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 543; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 543; $namedLabelStatement = new NamedLabelStatement(); }
        $namedLabelStatement->parent = $parentNode;
        $namedLabelStatement->name = $this->eat1(TokenKind::Name);
        $namedLabelStatement->colon = $this->eat1(TokenKind::ColonToken);
        // A named label is a statement on its own. E.g. `while (false) label: echo "test";`
        // is parsed as `while (false) { label: } echo "test";
        return $namedLabelStatement;
    }

    /**
     * @param int|int[] ...$expectedKinds an array of one or more kinds/sets of allowed kinds in each position
     */
    private function lookahead(...$expectedKinds) : bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 557; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 557; $startPos = $this->lexer->getCurrentPosition(); }
        $startToken = $this->token;
        $succeeded = true;
        foreach ($expectedKinds as $kind) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 555; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 555; $token = $this->lexer->scanNextToken(); }
            $currentPosition = $this->lexer->getCurrentPosition();
            $endOfFilePosition = $this->lexer->getEndOfFilePosition();
            if (\is_array($kind)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 553; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 553; $succeeded = false; }
                foreach ($kind as $kindOption) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 547; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 547; if ($currentPosition <= $endOfFilePosition && \PhpFuzzer\FuzzingContext::traceBlock(544, $token->kind === $kindOption)) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 545; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 545; $succeeded = true; }
                        break;
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 546; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 546; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 548; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 548;
            } else {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 552; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 552; if ($currentPosition > $endOfFilePosition || \PhpFuzzer\FuzzingContext::traceBlock(549, $token->kind !== $kind)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 550; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 550; $succeeded = false; }
                    break;
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 551; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 551; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 554; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 554;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 556; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 556;
        $this->lexer->setCurrentPosition($startPos);
        $this->token = $startToken;
        return $succeeded;
    }

    private function checkToken($expectedKind) : bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 558; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 558; return $this->getCurrentToken()->kind === $expectedKind; }
    }

    private function parseIfStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 569; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 569; $ifStatement = new IfStatementNode(); }
        $ifStatement->parent = $parentNode;
        $ifStatement->ifKeyword = $this->eat1(TokenKind::IfKeyword);
        $ifStatement->openParen = $this->eat1(TokenKind::OpenParenToken);
        $ifStatement->expression = $this->parseExpression($ifStatement);
        $ifStatement->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $curTokenKind = $this->getCurrentToken()->kind;
        if ($curTokenKind === TokenKind::ColonToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 562; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 562; $ifStatement->colon = $this->eat1(TokenKind::ColonToken); }
            $ifStatement->statements = $this->parseList($ifStatement, ParseContext::IfClause2Elements);
        } else { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 561; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 561; if ($curTokenKind !== TokenKind::ScriptSectionEndTag) {
            // Fix #246 : properly parse `if (false) ?\>echoed text\<?php`
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 559; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 559; $ifStatement->statements = $this->parseStatement($ifStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 560; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 560; $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 563; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 563; }
        $ifStatement->elseIfClauses = []; // TODO - should be some standard for empty arrays vs. null?
        while ($this->checkToken(TokenKind::ElseIfKeyword)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 564; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 564; $ifStatement->elseIfClauses[] = $this->parseElseIfClause($ifStatement); }
        }

        if ($this->checkToken(TokenKind::ElseKeyword)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 565; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 565; $ifStatement->elseClause = $this->parseElseClause($ifStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 566; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 566;

        $ifStatement->endifKeyword = $this->eatOptional1(TokenKind::EndIfKeyword);
        if ($ifStatement->endifKeyword) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 567; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 567; $ifStatement->semicolon = $this->eatSemicolonOrAbortStatement(); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 568; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 568;

        return $ifStatement;
    }

    private function parseElseIfClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 573; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 573; $elseIfClause = new ElseIfClauseNode(); }
        $elseIfClause->parent = $parentNode;
        $elseIfClause->elseIfKeyword = $this->eat1(TokenKind::ElseIfKeyword);
        $elseIfClause->openParen = $this->eat1(TokenKind::OpenParenToken);
        $elseIfClause->expression = $this->parseExpression($elseIfClause);
        $elseIfClause->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $curTokenKind = $this->getCurrentToken()->kind;
        if ($curTokenKind === TokenKind::ColonToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 571; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 571; $elseIfClause->colon = $this->eat1(TokenKind::ColonToken); }
            $elseIfClause->statements = $this->parseList($elseIfClause, ParseContext::IfClause2Elements);
        } elseif ($curTokenKind !== TokenKind::ScriptSectionEndTag) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 570; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 570; $elseIfClause->statements = $this->parseStatement($elseIfClause); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 572; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 572;
        return $elseIfClause;
    }

    private function parseElseClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 577; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 577; $elseClause = new ElseClauseNode(); }
        $elseClause->parent = $parentNode;
        $elseClause->elseKeyword = $this->eat1(TokenKind::ElseKeyword);
        $curTokenKind = $this->getCurrentToken()->kind;
        if ($curTokenKind === TokenKind::ColonToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 575; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 575; $elseClause->colon = $this->eat1(TokenKind::ColonToken); }
            $elseClause->statements = $this->parseList($elseClause, ParseContext::IfClause2Elements);
        } elseif ($curTokenKind !== TokenKind::ScriptSectionEndTag) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 574; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 574; $elseClause->statements = $this->parseStatement($elseClause); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 576; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 576;
        return $elseClause;
    }

    private function parseSwitchStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 581; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 581; $switchStatement = new SwitchStatementNode(); }
        $switchStatement->parent = $parentNode;
        $switchStatement->switchKeyword = $this->eat1(TokenKind::SwitchKeyword);
        $switchStatement->openParen = $this->eat1(TokenKind::OpenParenToken);
        $switchStatement->expression = $this->parseExpression($switchStatement);
        $switchStatement->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $switchStatement->openBrace = $this->eatOptional1(TokenKind::OpenBraceToken);
        $switchStatement->colon = $this->eatOptional1(TokenKind::ColonToken);
        $switchStatement->caseStatements = $this->parseList($switchStatement, ParseContext::SwitchStatementElements);
        if ($switchStatement->colon !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 579; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 579; $switchStatement->endswitch = $this->eat1(TokenKind::EndSwitchKeyword); }
            $switchStatement->semicolon = $this->eatSemicolonOrAbortStatement();
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 578; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 578; $switchStatement->closeBrace = $this->eat1(TokenKind::CloseBraceToken); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 580; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 580;

        return $switchStatement;
    }

    private function parseCaseOrDefaultStatement() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 585; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 585; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 584; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 584; $caseStatement = new CaseStatementNode(); }
            $caseStatement->parent = $parentNode;
            // TODO add error checking
            $caseStatement->caseKeyword = $this->eat(TokenKind::CaseKeyword, TokenKind::DefaultKeyword);
            if ($caseStatement->caseKeyword->kind === TokenKind::CaseKeyword) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 582; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 582; $caseStatement->expression = $this->parseExpression($caseStatement); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 583; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 583;
            $caseStatement->defaultLabelTerminator = $this->eat(TokenKind::ColonToken, TokenKind::SemicolonToken);
            $caseStatement->statementList = $this->parseList($caseStatement, ParseContext::CaseStatementElements);
            return $caseStatement;
        }; }
    }

    private function parseWhileStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 589; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 589; $whileStatement = new WhileStatement(); }
        $whileStatement->parent = $parentNode;
        $whileStatement->whileToken = $this->eat1(TokenKind::WhileKeyword);
        $whileStatement->openParen = $this->eat1(TokenKind::OpenParenToken);
        $whileStatement->expression = $this->parseExpression($whileStatement);
        $whileStatement->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $whileStatement->colon = $this->eatOptional1(TokenKind::ColonToken);
        if ($whileStatement->colon !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 587; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 587; $whileStatement->statements = $this->parseList($whileStatement, ParseContext::WhileStatementElements); }
            $whileStatement->endWhile = $this->eat1(TokenKind::EndWhileKeyword);
            $whileStatement->semicolon = $this->eatSemicolonOrAbortStatement();
        } elseif (!$this->checkToken(TokenKind::ScriptSectionEndTag)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 586; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 586; $whileStatement->statements = $this->parseStatement($whileStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 588; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 588;
        return $whileStatement;
    }

    /**
     * @param Node $parentNode
     * @param bool $force
     * @return Node|MissingToken|array - The expression, or a missing token, or (if $force) an array containing a missed and skipped token
     */
    private function parseExpression($parentNode, $force = false) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 595; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 595; $token = $this->getCurrentToken(); }
        if ($token->kind === TokenKind::EndOfFileToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 590; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 590; return new MissingToken(TokenKind::Expression, $token->fullStart); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 591; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 591;

        // Equivalent to (parseExpressionFn())($parentNode)
        $expression = $this->parseBinaryExpressionOrHigher(0, $parentNode);
        if ($force && \PhpFuzzer\FuzzingContext::traceBlock(592, $expression instanceof MissingToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 593; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 593; $expression = [$expression, new SkippedToken($token)]; }
            $this->advanceToken();
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 594; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 594;

        return $expression;
    }

    private function parseExpressionFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 597; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 597; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 596; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 596; return $this->parseBinaryExpressionOrHigher(0, $parentNode); }
        }; }
    }

    /**
     * @param Node $parentNode
     * @return Expression
     */
    private function parseUnaryExpressionOrHigher($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 625; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 625; $token = $this->getCurrentToken(); }
        switch ($token->kind) {
            // unary-op-expression
            case TokenKind::PlusToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 598; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 598;
            case TokenKind::MinusToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 599; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 599;
            case TokenKind::ExclamationToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 600; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 600;
            case TokenKind::TildeToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 601; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 601; return $this->parseUnaryOpExpression($parentNode); }

            // error-control-expression
            case TokenKind::AtSymbolToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 602; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 602; return $this->parseErrorControlExpression($parentNode); }

            // prefix-increment-expression
            case TokenKind::PlusPlusToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 603; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 603;
            // prefix-decrement-expression
            case TokenKind::MinusMinusToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 604; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 604; return $this->parsePrefixUpdateExpression($parentNode); }

            case TokenKind::ArrayCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 605; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 605;
            case TokenKind::BoolCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 606; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 606;
            case TokenKind::DoubleCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 607; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 607;
            case TokenKind::IntCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 608; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 608;
            case TokenKind::ObjectCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 609; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 609;
            case TokenKind::StringCastToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 610; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 610;
            case TokenKind::UnsetCastToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 611; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 611; return $this->parseCastExpression($parentNode); }

            case TokenKind::OpenParenToken:
                // TODO remove duplication
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 614; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 614; if ($this->lookahead(
                    [TokenKind::ArrayKeyword,
                    TokenKind::BinaryReservedWord,
                    TokenKind::BoolReservedWord,
                    TokenKind::BooleanReservedWord,
                    TokenKind::DoubleReservedWord,
                    TokenKind::IntReservedWord,
                    TokenKind::IntegerReservedWord,
                    TokenKind::FloatReservedWord,
                    TokenKind::ObjectReservedWord,
                    TokenKind::RealReservedWord,
                    TokenKind::StringReservedWord,
                    TokenKind::UnsetKeyword], TokenKind::CloseParenToken)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 612; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 612; return $this->parseCastExpressionGranular($parentNode); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 613; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 613; }
                break;

/*

            case TokenKind::BacktickToken:
                return $this->parseShellCommandExpression($parentNode);

            case TokenKind::OpenParenToken:
                // TODO
//                return $this->parseCastExpressionGranular($parentNode);
                break;*/

            // object-creation-expression (postfix-expression)
            case TokenKind::NewKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 615; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 615; return $this->parseObjectCreationExpression($parentNode); }

            // clone-expression (postfix-expression)
            case TokenKind::CloneKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 616; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 616; return $this->parseCloneExpression($parentNode); }

            case TokenKind::YieldKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 617; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 617;
            case TokenKind::YieldFromKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 618; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 618; return $this->parseYieldExpression($parentNode); }

            // include-expression
            // include-once-expression
            // require-expression
            // require-once-expression
            case TokenKind::IncludeKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 619; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 619;
            case TokenKind::IncludeOnceKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 620; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 620;
            case TokenKind::RequireKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 621; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 621;
            case TokenKind::RequireOnceKeyword:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 622; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 622; return $this->parseScriptInclusionExpression($parentNode); }
            case TokenKind::ThrowKeyword: // throw-statement will become an expression in php 8.0
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 623; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 623; return $this->parseThrowExpression($parentNode); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 624; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 624;

        $expression = $this->parsePrimaryExpression($parentNode);
        return $this->parsePostfixExpressionRest($expression);
    }

    /**
     * @param int $precedence
     * @param Node $parentNode
     * @return Expression
     */
    private function parseBinaryExpressionOrHigher($precedence, $parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 667; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 667; $leftOperand = $this->parseUnaryExpressionOrHigher($parentNode); }

        list($prevNewPrecedence, $prevAssociativity) = self::UNKNOWN_PRECEDENCE_AND_ASSOCIATIVITY;

        while (true) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 666; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 666; $token = $this->getCurrentToken(); }

            list($newPrecedence, $associativity) = $this->getBinaryOperatorPrecedenceAndAssociativity($token);

            // Expressions using operators w/o associativity (equality, relational, instanceof)
            // cannot reference identical expression types within one of their operands.
            //
            // Example:
            //   $a < $b < $c // CASE 1: INVALID
            //   $a < $b === $c < $d // CASE 2: VALID
            //
            // In CASE 1, it is expected that we stop parsing the expression after the $b token.
            if ($prevAssociativity === Associativity::None && \PhpFuzzer\FuzzingContext::traceBlock(626, $prevNewPrecedence === $newPrecedence)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 627; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 627; break; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 628; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 628;

            // Precedence and associativity properties determine whether we recurse, and continue
            // building up the current operand, or whether we pop out.
            //
            // Example:
            //   $a + $b + $c // CASE 1: additive-expression (left-associative)
            //   $a = $b = $c // CASE 2: equality-expression (right-associative)
            //
            // CASE 1:
            // The additive-expression is left-associative, which means we expect the grouping to be:
            //   ($a + $b) + $c
            //
            // Because both + operators have the same precedence, and the + operator is left associative,
            // we expect the second + operator NOT to be consumed because $newPrecedence > $precedence => FALSE
            //
            // CASE 2:
            // The equality-expression is right-associative, which means we expect the grouping to be:
            //   $a = ($b = $c)
            //
            // Because both = operators have the same precedence, and the = operator is right-associative,
            // we expect the second = operator to be consumed because $newPrecedence >= $precedence => TRUE
            $shouldConsumeCurrentOperator =
                $associativity === Associativity::Right ?
                    $newPrecedence >= $precedence:
                    \PhpFuzzer\FuzzingContext::traceBlock(629, $newPrecedence > $precedence);

            if (!$shouldConsumeCurrentOperator) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 630; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 630; break; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 631; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 631;

            // Unlike every other binary expression, exponentiation operators take precedence over unary operators.
            //
            // Example:
            //   -3**2 => -9
            //
            // In these cases, we strip the UnaryExpression operator, and reassign $leftOperand to
            // $unaryExpression->operand.
            //
            // After we finish building the BinaryExpression, we rebuild the UnaryExpression so that it includes
            // the original operator, and the newly constructed exponentiation-expression as the operand.
            $shouldOperatorTakePrecedenceOverUnary = false;
            switch ($token->kind) {
                case TokenKind::AsteriskAsteriskToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 632; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 632; $shouldOperatorTakePrecedenceOverUnary = $leftOperand instanceof UnaryExpression; }
                    break;
                case TokenKind::EqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 633; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 633;
                case TokenKind::AsteriskAsteriskEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 634; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 634;
                case TokenKind::AsteriskEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 635; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 635;
                case TokenKind::SlashEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 636; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 636;
                case TokenKind::PercentEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 637; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 637;
                case TokenKind::PlusEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 638; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 638;
                case TokenKind::MinusEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 639; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 639;
                case TokenKind::DotEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 640; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 640;
                case TokenKind::LessThanLessThanEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 641; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 641;
                case TokenKind::GreaterThanGreaterThanEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 642; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 642;
                case TokenKind::AmpersandEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 643; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 643;
                case TokenKind::CaretEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 644; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 644;
                case TokenKind::BarEqualsToken: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 645; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 645;
                case TokenKind::QuestionQuestionEqualsToken:
                    // Workarounds for https://github.com/Microsoft/tolerant-php-parser/issues/19#issue-201714377
                    // Parse `!$a = $b` as `!($a = $b)` - PHP constrains the Left Hand Side of an assignment to a variable. A unary operator (`@`, `!`, etc.) is not a variable.
                    // Instanceof has similar constraints for the LHS.
                    // So does `!$a += $b`
                    // TODO: Any other operators?
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 648; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 648; if ($leftOperand instanceof UnaryOpExpression) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 646; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 646; $shouldOperatorTakePrecedenceOverUnary = true; }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 647; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 647; }
                    break;
                case TokenKind::InstanceOfKeyword:
                    // Unlike assignment, the instanceof operator doesn't have restrictions on what can go in the left hand side.
                    // `!` is the only unary operator with lower precedence than instanceof.
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 653; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 653; if ($leftOperand instanceof UnaryOpExpression) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 651; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 651; if ($leftOperand->operator->kind === TokenKind::ExclamationToken) {
                            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 649; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 649; $shouldOperatorTakePrecedenceOverUnary = true; }
                        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 650; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 650; }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 652; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 652; }
                    break;
                case TokenKind::QuestionToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 656; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 656; if ($parentNode instanceof TernaryExpression) {
                        // Workaround to parse "a ? b : c ? d : e" as "(a ? b : c) ? d : e"
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 654; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 654; break 2; }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 655; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 655; }
                    break;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 657; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 657;

            if ($shouldOperatorTakePrecedenceOverUnary) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 658; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 658; $unaryExpression = $leftOperand; }
                $leftOperand = $unaryExpression->operand;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 659; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 659;

            $this->advanceToken();

            if ($token->kind === TokenKind::EqualsToken) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 660; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 660; $byRefToken = $this->eatOptional1(TokenKind::AmpersandToken); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 661; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 661;

            $leftOperand = $token->kind === TokenKind::QuestionToken ?
                $this->parseTernaryExpression($leftOperand, $token, $parentNode) :
                \PhpFuzzer\FuzzingContext::traceBlock(663, $this->makeBinaryExpression(
                    $leftOperand,
                    $token,
                    $byRefToken ?? \PhpFuzzer\FuzzingContext::traceBlock(662, null),
                    $this->parseBinaryExpressionOrHigher($newPrecedence, null),
                    $parentNode));

            // Rebuild the unary expression if we deconstructed it earlier.
            if ($shouldOperatorTakePrecedenceOverUnary) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 664; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 664; $leftOperand->parent = $unaryExpression; }
                $unaryExpression->operand = $leftOperand;
                $leftOperand = $unaryExpression;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 665; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 665;

            // Hold onto these values, so we know whether we've hit duplicate non-associative operators,
            // and need to terminate early.
            $prevNewPrecedence = $newPrecedence;
            $prevAssociativity = $associativity;
        }
        return $leftOperand;
    }

    const OPERATOR_PRECEDENCE_AND_ASSOCIATIVITY =
        [
            // logical-inc-OR-expression-2 (L)
            TokenKind::OrKeyword => [6, Associativity::Left],

            // logical-exc-OR-expression-2 (L)
            TokenKind::XorKeyword=> [7, Associativity::Left],

            // logical-AND-expression-2 (L)
            TokenKind::AndKeyword=> [8, Associativity::Left],

            // simple-assignment-expression (R)
            // TODO byref-assignment-expression
            TokenKind::EqualsToken => [9, Associativity::Right],

            // compound-assignment-expression (R)
            TokenKind::AsteriskAsteriskEqualsToken => [9, Associativity::Right],
            TokenKind::AsteriskEqualsToken => [9, Associativity::Right],
            TokenKind::SlashEqualsToken => [9, Associativity::Right],
            TokenKind::PercentEqualsToken => [9, Associativity::Right],
            TokenKind::PlusEqualsToken => [9, Associativity::Right],
            TokenKind::MinusEqualsToken => [9, Associativity::Right],
            TokenKind::DotEqualsToken => [9, Associativity::Right],
            TokenKind::LessThanLessThanEqualsToken => [9, Associativity::Right],
            TokenKind::GreaterThanGreaterThanEqualsToken => [9, Associativity::Right],
            TokenKind::AmpersandEqualsToken => [9, Associativity::Right],
            TokenKind::CaretEqualsToken => [9, Associativity::Right],
            TokenKind::BarEqualsToken => [9, Associativity::Right],
            TokenKind::QuestionQuestionEqualsToken => [9, Associativity::Right],

            // TODO conditional-expression (L)
            TokenKind::QuestionToken => [10, Associativity::Left],
//            TokenKind::ColonToken => [9, Associativity::Left],

            // TODO coalesce-expression (R)
            TokenKind::QuestionQuestionToken => [9, Associativity::Right],

            //logical-inc-OR-expression-1 (L)
            TokenKind::BarBarToken => [12, Associativity::Left],

            // logical-AND-expression-1 (L)
            TokenKind::AmpersandAmpersandToken => [13, Associativity::Left],

            // bitwise-inc-OR-expression (L)
            TokenKind::BarToken => [14, Associativity::Left],

            // bitwise-exc-OR-expression (L)
            TokenKind::CaretToken => [15, Associativity::Left],

            // bitwise-AND-expression (L)
            TokenKind::AmpersandToken => [16, Associativity::Left],

            // equality-expression (X)
            TokenKind::EqualsEqualsToken => [17, Associativity::None],
            TokenKind::ExclamationEqualsToken => [17, Associativity::None],
            TokenKind::LessThanGreaterThanToken => [17, Associativity::None],
            TokenKind::EqualsEqualsEqualsToken => [17, Associativity::None],
            TokenKind::ExclamationEqualsEqualsToken => [17, Associativity::None],
            TokenKind::LessThanEqualsGreaterThanToken => [17, Associativity::None],

            // relational-expression (X)
            TokenKind::LessThanToken => [18, Associativity::None],
            TokenKind::GreaterThanToken => [18, Associativity::None],
            TokenKind::LessThanEqualsToken => [18, Associativity::None],
            TokenKind::GreaterThanEqualsToken => [18, Associativity::None],

            // shift-expression (L)
            TokenKind::LessThanLessThanToken => [19, Associativity::Left],
            TokenKind::GreaterThanGreaterThanToken => [19, Associativity::Left],

            // additive-expression (L)
            TokenKind::PlusToken => [20, Associativity::Left],
            TokenKind::MinusToken => [20, Associativity::Left],
            TokenKind::DotToken =>[20, Associativity::Left],

            // multiplicative-expression (L)
            TokenKind::AsteriskToken => [21, Associativity::Left],
            TokenKind::SlashToken => [21, Associativity::Left],
            TokenKind::PercentToken => [21, Associativity::Left],

            // instanceof-expression (X)
            TokenKind::InstanceOfKeyword => [22, Associativity::None],

            // exponentiation-expression (R)
            TokenKind::AsteriskAsteriskToken => [23, Associativity::Right]
        ];

    const UNKNOWN_PRECEDENCE_AND_ASSOCIATIVITY = [-1, -1];

    private function getBinaryOperatorPrecedenceAndAssociativity($token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 669; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 669; return self::OPERATOR_PRECEDENCE_AND_ASSOCIATIVITY[$token->kind] ?? \PhpFuzzer\FuzzingContext::traceBlock(668, self::UNKNOWN_PRECEDENCE_AND_ASSOCIATIVITY); }
    }

    /**
     * @internal Do not use outside this class, this may be changed or removed.
     */
    const KNOWN_ASSIGNMENT_TOKEN_SET = [
        TokenKind::AsteriskAsteriskEqualsToken => true,
        TokenKind::AsteriskEqualsToken => true,
        TokenKind::SlashEqualsToken => true,
        TokenKind::PercentEqualsToken => true,
        TokenKind::PlusEqualsToken => true,
        TokenKind::MinusEqualsToken => true,
        TokenKind::DotEqualsToken => true,
        TokenKind::LessThanLessThanEqualsToken => true,
        TokenKind::GreaterThanGreaterThanEqualsToken => true,
        TokenKind::AmpersandEqualsToken => true,
        TokenKind::CaretEqualsToken => true,
        TokenKind::BarEqualsToken => true,
        TokenKind::QuestionQuestionEqualsToken => true,
        // InstanceOf has other remaining issues, but this heuristic is an improvement for many common cases such as `$x && $y = $z`
    ];

    private function makeBinaryExpression($leftOperand, $operatorToken, $byRefToken, $rightOperand, $parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 683; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 683; $assignmentExpression = $operatorToken->kind === TokenKind::EqualsToken; }
        if ($assignmentExpression || \PhpFuzzer\FuzzingContext::traceBlock(670, \array_key_exists($operatorToken->kind, self::KNOWN_ASSIGNMENT_TOKEN_SET))) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 677; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 677; if ($leftOperand instanceof BinaryExpression) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 675; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 675; if (!\array_key_exists($leftOperand->operator->kind, self::KNOWN_ASSIGNMENT_TOKEN_SET)) {
                    // Handle cases without parenthesis, such as $x ** $y === $z, as $x ** ($y === $z)
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 671; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 671; return $this->shiftBinaryOperands($leftOperand, $operatorToken, $byRefToken, $rightOperand, $parentNode); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 672; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 672; }
            } elseif ($leftOperand instanceof UnaryOpExpression || \PhpFuzzer\FuzzingContext::traceBlock(673, $leftOperand instanceof ErrorControlExpression)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 674; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 674; return $this->shiftUnaryOperands($leftOperand, $operatorToken, $byRefToken, $rightOperand, $parentNode); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 676; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 676; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 678; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 678;
        $binaryExpression = $assignmentExpression ? new AssignmentExpression() : \PhpFuzzer\FuzzingContext::traceBlock(679, new BinaryExpression());
        $binaryExpression->parent = $parentNode;
        $leftOperand->parent = $binaryExpression;
        $rightOperand->parent = $binaryExpression;
        $binaryExpression->leftOperand = $leftOperand;
        $binaryExpression->operator = $operatorToken;
        if ($binaryExpression instanceof AssignmentExpression && \PhpFuzzer\FuzzingContext::traceBlock(680, isset($byRefToken))) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 681; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 681; $binaryExpression->byRef = $byRefToken; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 682; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 682;
        $binaryExpression->rightOperand = $rightOperand;
        return $binaryExpression;
    }

    /**
     * @param ErrorControlExpression|UnaryOpExpression $leftOperand
     */
    private function shiftUnaryOperands(UnaryExpression $leftOperand, $operatorToken, $byRefToken, $rightOperand, $parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 684; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 684; $outerUnaryOpExpression = clone($leftOperand); }
        $inner = $this->makeBinaryExpression(
            $leftOperand->operand,
            $operatorToken,
            $byRefToken,
            $rightOperand,
            $outerUnaryOpExpression
        );
        // Either ErrorControlExpression or a UnaryOpExpression
        $outerUnaryOpExpression->parent = $parentNode;
        // TODO should this binaryExpression be wrapped in a UnaryExpression?
        $outerUnaryOpExpression->operand = $inner;

        return $outerUnaryOpExpression;
    }

    private function shiftBinaryOperands(BinaryExpression $leftOperand, $operatorToken, $byRefToken, $rightOperand, $parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 685; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 685; $inner = $this->makeBinaryExpression(
            $leftOperand->rightOperand,
            $operatorToken,
            $byRefToken,
            $rightOperand,
            $parentNode
        ); }
        $outer = $this->makeBinaryExpression(
            $leftOperand->leftOperand,
            $leftOperand->operator,
            null,
            $inner,
            $parentNode
        );
        $inner->parent = $outer;
        return $outer;
    }

    private function parseDoStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 686; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 686; $doStatement = new DoStatement(); }
        $doStatement->parent = $parentNode;
        $doStatement->do = $this->eat1(TokenKind::DoKeyword);
        $doStatement->statement = $this->parseStatement($doStatement);
        $doStatement->whileToken = $this->eat1(TokenKind::WhileKeyword);
        $doStatement->openParen = $this->eat1(TokenKind::OpenParenToken);
        $doStatement->expression = $this->parseExpression($doStatement);
        $doStatement->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $doStatement->semicolon = $this->eatSemicolonOrAbortStatement();
        return $doStatement;
    }

    private function parseForStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 690; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 690; $forStatement = new ForStatement(); }
        $forStatement->parent = $parentNode;
        $forStatement->for = $this->eat1(TokenKind::ForKeyword);
        $forStatement->openParen = $this->eat1(TokenKind::OpenParenToken);
        $forStatement->forInitializer = $this->parseExpressionList($forStatement); // TODO spec is redundant
        $forStatement->exprGroupSemicolon1 = $this->eat1(TokenKind::SemicolonToken);
        $forStatement->forControl = $this->parseExpressionList($forStatement);
        $forStatement->exprGroupSemicolon2 = $this->eat1(TokenKind::SemicolonToken);
        $forStatement->forEndOfLoop = $this->parseExpressionList($forStatement);
        $forStatement->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $forStatement->colon = $this->eatOptional1(TokenKind::ColonToken);
        if ($forStatement->colon !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 688; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 688; $forStatement->statements = $this->parseList($forStatement, ParseContext::ForStatementElements); }
            $forStatement->endFor = $this->eat1(TokenKind::EndForKeyword);
            $forStatement->endForSemicolon = $this->eatSemicolonOrAbortStatement();
        } elseif (!$this->checkToken(TokenKind::ScriptSectionEndTag)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 687; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 687; $forStatement->statements = $this->parseStatement($forStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 689; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 689;
        return $forStatement;
    }

    private function parseForeachStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 694; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 694; $foreachStatement = new ForeachStatement(); }
        $foreachStatement->parent = $parentNode;
        $foreachStatement->foreach = $this->eat1(TokenKind::ForeachKeyword);
        $foreachStatement->openParen = $this->eat1(TokenKind::OpenParenToken);
        $foreachStatement->forEachCollectionName = $this->parseExpression($foreachStatement);
        $foreachStatement->asKeyword = $this->eat1(TokenKind::AsKeyword);
        $foreachStatement->foreachKey = $this->tryParseForeachKey($foreachStatement);
        $foreachStatement->foreachValue = $this->parseForeachValue($foreachStatement);
        $foreachStatement->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $foreachStatement->colon = $this->eatOptional1(TokenKind::ColonToken);
        if ($foreachStatement->colon !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 692; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 692; $foreachStatement->statements = $this->parseList($foreachStatement, ParseContext::ForeachStatementElements); }
            $foreachStatement->endForeach = $this->eat1(TokenKind::EndForEachKeyword);
            $foreachStatement->endForeachSemicolon = $this->eatSemicolonOrAbortStatement();
        } elseif (!$this->checkToken(TokenKind::ScriptSectionEndTag)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 691; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 691; $foreachStatement->statements = $this->parseStatement($foreachStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 693; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 693;
        return $foreachStatement;
    }

    private function tryParseForeachKey($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 699; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 699; if (!$this->isExpressionStart($this->getCurrentToken())) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 695; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 695; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 696; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 696; }

        $startPos = $this->lexer->getCurrentPosition();
        $startToken = $this->getCurrentToken();
        $foreachKey = new ForeachKey();
        $foreachKey->parent = $parentNode;
        $foreachKey->expression = $this->parseExpression($foreachKey);

        if (!$this->checkToken(TokenKind::DoubleArrowToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 697; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 697; $this->lexer->setCurrentPosition($startPos); }
            $this->token = $startToken;
            return null;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 698; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 698;

        $foreachKey->arrow = $this->eat1(TokenKind::DoubleArrowToken);
        return $foreachKey;
    }

    private function parseForeachValue($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 700; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 700; $foreachValue = new ForeachValue(); }
        $foreachValue->parent = $parentNode;
        $foreachValue->ampersand = $this->eatOptional1(TokenKind::AmpersandToken);
        $foreachValue->expression = $this->parseExpression($foreachValue);
        return $foreachValue;
    }

    private function parseGotoStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 701; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 701; $gotoStatement = new GotoStatement(); }
        $gotoStatement->parent = $parentNode;
        $gotoStatement->goto = $this->eat1(TokenKind::GotoKeyword);
        $gotoStatement->name = $this->eat1(TokenKind::Name);
        $gotoStatement->semicolon = $this->eatSemicolonOrAbortStatement();
        return $gotoStatement;
    }

    private function parseBreakOrContinueStatement($parentNode) {
        // TODO should be error checking if on top level
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 704; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 704; $continueStatement = new BreakOrContinueStatement(); }
        $continueStatement->parent = $parentNode;
        $continueStatement->breakOrContinueKeyword = $this->eat(TokenKind::ContinueKeyword, TokenKind::BreakKeyword);

        if ($this->isExpressionStart($this->getCurrentToken())) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 702; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 702; $continueStatement->breakoutLevel = $this->parseExpression($continueStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 703; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 703;

        $continueStatement->semicolon = $this->eatSemicolonOrAbortStatement();

        return $continueStatement;
    }

    private function parseReturnStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 707; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 707; $returnStatement = new ReturnStatement(); }
        $returnStatement->parent = $parentNode;
        $returnStatement->returnKeyword = $this->eat1(TokenKind::ReturnKeyword);
        if ($this->isExpressionStart($this->getCurrentToken())) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 705; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 705; $returnStatement->expression = $this->parseExpression($returnStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 706; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 706;
        $returnStatement->semicolon = $this->eatSemicolonOrAbortStatement();

        return $returnStatement;
    }

    private function parseThrowStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 708; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 708; $throwStatement = new ThrowStatement(); }
        $throwStatement->parent = $parentNode;
        $throwStatement->throwKeyword = $this->eat1(TokenKind::ThrowKeyword);
        // TODO error for failures to parse expressions when not optional
        $throwStatement->expression = $this->parseExpression($throwStatement);
        $throwStatement->semicolon = $this->eatSemicolonOrAbortStatement();

        return $throwStatement;
    }

    private function parseThrowExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 709; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 709; $throwExpression = new ThrowExpression(); }
        $throwExpression->parent = $parentNode;
        $throwExpression->throwKeyword = $this->eat1(TokenKind::ThrowKeyword);
        // TODO error for failures to parse expressions when not optional
        $throwExpression->expression = $this->parseExpression($throwExpression);

        return $throwExpression;
    }

    private function parseTryStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 713; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 713; $tryStatement = new TryStatement(); }
        $tryStatement->parent = $parentNode;
        $tryStatement->tryKeyword = $this->eat1(TokenKind::TryKeyword);
        $tryStatement->compoundStatement = $this->parseCompoundStatement($tryStatement); // TODO verifiy this is only compound

        $tryStatement->catchClauses = array(); // TODO - should be some standard for empty arrays vs. null?
        while ($this->checkToken(TokenKind::CatchKeyword)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 710; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 710; $tryStatement->catchClauses[] = $this->parseCatchClause($tryStatement); }
        }

        if ($this->checkToken(TokenKind::FinallyKeyword)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 711; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 711; $tryStatement->finallyClause = $this->parseFinallyClause($tryStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 712; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 712;

        return $tryStatement;
    }

    private function parseCatchClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 716; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 716; $catchClause = new CatchClause(); }
        $catchClause->parent = $parentNode;
        $catchClause->catch = $this->eat1(TokenKind::CatchKeyword);
        $catchClause->openParen = $this->eat1(TokenKind::OpenParenToken);
        $qualifiedNameList = $this->parseQualifiedNameCatchList($catchClause)->children ?? \PhpFuzzer\FuzzingContext::traceBlock(714, []);
        $catchClause->qualifiedName = $qualifiedNameList[0] ?? \PhpFuzzer\FuzzingContext::traceBlock(715, null); // TODO generate missing token or error if null
        $catchClause->otherQualifiedNameList = array_slice($qualifiedNameList, 1);  // TODO: Generate error if the name list has missing tokens
        $catchClause->variableName = $this->eatOptional1(TokenKind::VariableName);
        $catchClause->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $catchClause->compoundStatement = $this->parseCompoundStatement($catchClause);

        return $catchClause;
    }

    private function parseFinallyClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 717; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 717; $finallyClause = new FinallyClause(); }
        $finallyClause->parent = $parentNode;
        $finallyClause->finallyToken = $this->eat1(TokenKind::FinallyKeyword);
        $finallyClause->compoundStatement = $this->parseCompoundStatement($finallyClause);

        return $finallyClause;
    }

    private function parseDeclareStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 722; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 722; $declareStatement = new DeclareStatement(); }
        $declareStatement->parent = $parentNode;
        $declareStatement->declareKeyword = $this->eat1(TokenKind::DeclareKeyword);
        $declareStatement->openParen = $this->eat1(TokenKind::OpenParenToken);
        $this->parseAndSetDeclareDirectiveList($declareStatement);
        $declareStatement->closeParen = $this->eat1(TokenKind::CloseParenToken);

        if ($this->checkToken(TokenKind::SemicolonToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 720; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 720; $declareStatement->semicolon = $this->eatSemicolonOrAbortStatement(); }
        } elseif ($this->checkToken(TokenKind::ColonToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 718; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 718; $declareStatement->colon = $this->eat1(TokenKind::ColonToken); }
            $declareStatement->statements = $this->parseList($declareStatement, ParseContext::DeclareStatementElements);
            $declareStatement->enddeclareKeyword = $this->eat1(TokenKind::EndDeclareKeyword);
            $declareStatement->semicolon = $this->eatSemicolonOrAbortStatement();
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 719; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 719; $declareStatement->statements = $this->parseStatement($declareStatement); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 721; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 721;

        return $declareStatement;
    }

    /**
     * @param DeclareStatement $parentNode
     */
    private function parseAndSetDeclareDirectiveList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 727; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 727; $declareDirectiveList = $this->parseDeclareDirectiveList($parentNode); }

        if (!$declareDirectiveList) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 723; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 723; $declareDirective = new DeclareDirective(); }
            $declareDirective->parent = $parentNode;

            $declareDirective->name = new MissingToken(TokenKind::Name, $this->token->fullStart);
            $declareDirective->equals = new MissingToken(TokenKind::EqualsToken, $this->token->fullStart);
            // TODO: This is matching the first token in $this::parseDeclareDirectiveFn.
            //       Probably best to emit a more general "literal error".
            $declareDirective->literal = new MissingToken(TokenKind::FloatingLiteralToken, $this->token->fullStart);

            $parentNode->declareDirective = $declareDirective;
            return;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 724; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 724;

        $declareDirective = array_shift($declareDirectiveList->children);
        $parentNode->declareDirective = $declareDirective;
        $declareDirective->parent = $parentNode;

        if ($declareDirectiveList->children) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 725; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 725; $parentNode->otherDeclareDirectives = $declareDirectiveList; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 726; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 726;
    }

    /**
     * @param DeclareStatement $parentNode
     * @return DelimitedList\DeclareDirectiveList|null
     */
    private function parseDeclareDirectiveList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 729; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 729; $declareDirectiveList = $this->parseDelimitedList(
            DelimitedList\DeclareDirectiveList::class,
            TokenKind::CommaToken,
            function ($token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 728; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 728; return $token->kind === TokenKind::Name; }
            },
            $this->parseDeclareDirectiveFn(),
            $parentNode,
            false
        ); }

        return $declareDirectiveList;
    }

    private function parseDeclareDirectiveFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 731; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 731; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 730; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 730; $declareDirective = new DeclareDirective(); }
            $declareDirective->parent = $parentNode;
            $declareDirective->name = $this->eat1(TokenKind::Name);
            $declareDirective->equals = $this->eat1(TokenKind::EqualsToken);
            $declareDirective->literal =
                $this->eat(
                    TokenKind::FloatingLiteralToken,
                    TokenKind::IntegerLiteralToken,
                    TokenKind::DecimalLiteralToken,
                    TokenKind::OctalLiteralToken,
                    TokenKind::HexadecimalLiteralToken,
                    TokenKind::BinaryLiteralToken,
                    TokenKind::InvalidOctalLiteralToken,
                    TokenKind::InvalidHexadecimalLiteral,
                    TokenKind::InvalidBinaryLiteral,
                    TokenKind::StringLiteralToken
                ); // TODO simplify

            return $declareDirective;
        }; }
    }

    private function parseSimpleVariable($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 732; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 732; return ($this->parseSimpleVariableFn())($parentNode); }
    }

    private function parseSimpleVariableFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 745; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 745; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 744; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 744; $token = $this->getCurrentToken(); }
            $variable = new Variable();
            $variable->parent = $parentNode;

            if ($token->kind === TokenKind::DollarToken) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 742; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 742; $variable->dollar = $this->eat1(TokenKind::DollarToken); }
                $token = $this->getCurrentToken();

                switch ($token->kind) {
                    case TokenKind::OpenBraceToken:
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 733; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 733; $variable->name = $this->parseBracedExpression($variable); }
                        break;
                    case TokenKind::VariableName: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 734; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 734;
                    case TokenKind::StringVarname: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 735; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 735;
                    case TokenKind::DollarToken:
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 736; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 736; $variable->name = $this->parseSimpleVariable($variable); }
                        break;
                    default:
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 737; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 737; $variable->name = new MissingToken(TokenKind::VariableName, $token->fullStart); }
                        break;
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 738; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 738;
            } elseif ($token->kind === TokenKind::VariableName || \PhpFuzzer\FuzzingContext::traceBlock(739, $token->kind === TokenKind::StringVarname)) {
                // TODO consider splitting into dollar and name.
                // StringVarname is the variable name without $, used in a template string e.g. `"${foo}"`
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 740; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 740; $variable->name = $this->eat(TokenKind::VariableName, TokenKind::StringVarname); }
            } else {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 741; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 741; $variable->name = new MissingToken(TokenKind::VariableName, $token->fullStart); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 743; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 743;

            return $variable;
        }; }
    }

    private function parseYieldExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 752; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 752; $yieldExpression = new YieldExpression(); }
        $yieldExpression->parent = $parentNode;
        $yieldExpression->yieldOrYieldFromKeyword = $this->eat(
            TokenKind::YieldFromKeyword,
            TokenKind::YieldKeyword
            );
        if ($yieldExpression->yieldOrYieldFromKeyword->kind === TokenKind::YieldFromKeyword) {
            // Don't use parseArrayElement. E.g. `yield from &$varName` or `yield from $key => $varName` are both syntax errors
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 750; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 750; $arrayElement = new ArrayElement(); }
            $arrayElement->parent = $yieldExpression;
            $arrayElement->elementValue = $this->parseExpression($arrayElement);
            $yieldExpression->arrayElement = $arrayElement;
        } else {
            // This is always an ArrayElement for backwards compatibilitiy.
            // TODO: Can this be changed to a non-ArrayElement in a future release?
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 749; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 749; if ($this->isExpressionStart($this->getCurrentToken())) {
                // Both `yield expr;` and `yield;` are possible.
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 747; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 747; $yieldExpression->arrayElement = $this->parseArrayElement($yieldExpression); }
            } else {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 746; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 746; $yieldExpression->arrayElement = null; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 748; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 748; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 751; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 751;

        return $yieldExpression;
    }

    private function parseScriptInclusionExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 753; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 753; $scriptInclusionExpression = new ScriptInclusionExpression(); }
        $scriptInclusionExpression->parent = $parentNode;
        $scriptInclusionExpression->requireOrIncludeKeyword =
            $this->eat(
                TokenKind::RequireKeyword, TokenKind::RequireOnceKeyword,
                TokenKind::IncludeKeyword, TokenKind::IncludeOnceKeyword
                );
        $scriptInclusionExpression->expression = $this->parseExpression($scriptInclusionExpression);
        return $scriptInclusionExpression;
    }

    private function parseEchoStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 754; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 754; $expressionStatement = new ExpressionStatement(); }

        // TODO: Could flatten into EchoStatement instead?
        $echoExpression = new EchoExpression();
        $echoExpression->parent = $expressionStatement;
        $echoExpression->echoKeyword = $this->eat1(TokenKind::EchoKeyword);
        $echoExpression->expressions =
            $this->parseExpressionList($echoExpression);

        $expressionStatement->parent = $parentNode;
        $expressionStatement->expression = $echoExpression;
        $expressionStatement->semicolon = $this->eatSemicolonOrAbortStatement();

        return $expressionStatement;
    }

    private function parseUnsetStatement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 755; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 755; $expressionStatement = new ExpressionStatement(); }

        // TODO: Could flatten into UnsetStatement instead?
        $unsetExpression = $this->parseUnsetIntrinsicExpression($expressionStatement);

        $expressionStatement->parent = $parentNode;
        $expressionStatement->expression = $unsetExpression;
        $expressionStatement->semicolon = $this->eatSemicolonOrAbortStatement();

        return $expressionStatement;
    }

    private function parseListIntrinsicExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 756; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 756; $listExpression = new ListIntrinsicExpression(); }
        $listExpression->parent = $parentNode;
        $listExpression->listKeyword = $this->eat1(TokenKind::ListKeyword);
        $listExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        // TODO - parse loosely as ArrayElementList, and validate parse tree later
        $listExpression->listElements =
            $this->parseArrayElementList($listExpression, DelimitedList\ListExpressionList::class);
        $listExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);

        return $listExpression;
    }

    private function isArrayElementStart($token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 757; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 757; return ($this->isArrayElementStartFn())($token); }
    }

    private function isArrayElementStartFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 761; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 761; return function ($token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 760; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 760; return $token->kind === TokenKind::AmpersandToken || \PhpFuzzer\FuzzingContext::traceBlock(758, $token->kind === TokenKind::DotDotDotToken) || \PhpFuzzer\FuzzingContext::traceBlock(759, $this->isExpressionStart($token)); }
        }; }
    }

    private function parseArrayElement($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 762; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 762; return ($this->parseArrayElementFn())($parentNode); }
    }

    private function parseArrayElementFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 771; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 771; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 770; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 770; $arrayElement = new ArrayElement(); }
            $arrayElement->parent = $parentNode;

            if ($this->checkToken(TokenKind::AmpersandToken)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 768; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 768; $arrayElement->byRef = $this->eat1(TokenKind::AmpersandToken); }
                $arrayElement->elementValue = $this->parseExpression($arrayElement);
            } elseif ($this->checkToken(TokenKind::DotDotDotToken)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 763; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 763; $arrayElement->dotDotDot = $this->eat1(TokenKind::DotDotDotToken); }
                $arrayElement->elementValue = $this->parseExpression($arrayElement);
            } else {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 767; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 767; $expression = $this->parseExpression($arrayElement); }
                if ($this->checkToken(TokenKind::DoubleArrowToken)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 765; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 765; $arrayElement->elementKey = $expression; }
                    $arrayElement->arrowToken = $this->eat1(TokenKind::DoubleArrowToken);
                    $arrayElement->byRef = $this->eatOptional1(TokenKind::AmpersandToken); // TODO not okay for list expressions
                    $arrayElement->elementValue = $this->parseExpression($arrayElement);
                } else {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 764; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 764; $arrayElement->elementValue = $expression; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 766; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 766;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 769; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 769;

            return $arrayElement;
        }; }
    }

    private function parseExpressionList($parentExpression) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 772; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 772; return $this->parseDelimitedList(
            DelimitedList\ExpressionList::class,
            TokenKind::CommaToken,
            $this->isExpressionStartFn(),
            $this->parseExpressionFn(),
            $parentExpression
        ); }
    }

    private function parseUnsetIntrinsicExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 773; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 773; $unsetExpression = new UnsetIntrinsicExpression(); }
        $unsetExpression->parent = $parentNode;

        $unsetExpression->unsetKeyword = $this->eat1(TokenKind::UnsetKeyword);
        $unsetExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        $unsetExpression->expressions = $this->parseExpressionList($unsetExpression);
        $unsetExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);

        return $unsetExpression;
    }

    private function parseArrayCreationExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 776; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 776; $arrayExpression = new ArrayCreationExpression(); }
        $arrayExpression->parent = $parentNode;

        $arrayExpression->arrayKeyword = $this->eatOptional1(TokenKind::ArrayKeyword);

        $arrayExpression->openParenOrBracket = $arrayExpression->arrayKeyword !== null
            ? $this->eat1(TokenKind::OpenParenToken)
            : \PhpFuzzer\FuzzingContext::traceBlock(774, $this->eat1(TokenKind::OpenBracketToken));

        $arrayExpression->arrayElements = $this->parseArrayElementList($arrayExpression, DelimitedList\ArrayElementList::class);

        $arrayExpression->closeParenOrBracket = $arrayExpression->arrayKeyword !== null
            ? $this->eat1(TokenKind::CloseParenToken)
            : \PhpFuzzer\FuzzingContext::traceBlock(775, $this->eat1(TokenKind::CloseBracketToken));

        return $arrayExpression;
    }

    private function parseArrayElementList($listExpression, $className) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 777; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 777; return $this->parseDelimitedList(
            $className,
            TokenKind::CommaToken,
            $this->isArrayElementStartFn(),
            $this->parseArrayElementFn(),
            $listExpression,
            true
        ); }
    }

    private function parseEmptyIntrinsicExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 778; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 778; $emptyExpression = new EmptyIntrinsicExpression(); }
        $emptyExpression->parent = $parentNode;

        $emptyExpression->emptyKeyword = $this->eat1(TokenKind::EmptyKeyword);
        $emptyExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        $emptyExpression->expression = $this->parseExpression($emptyExpression);
        $emptyExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);

        return $emptyExpression;
    }

    private function parseEvalIntrinsicExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 779; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 779; $evalExpression = new EvalIntrinsicExpression(); }
        $evalExpression->parent = $parentNode;

        $evalExpression->evalKeyword = $this->eat1(TokenKind::EvalKeyword);
        $evalExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        $evalExpression->expression = $this->parseExpression($evalExpression);
        $evalExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);

        return $evalExpression;
    }

    private function parseParenthesizedExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 780; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 780; $parenthesizedExpression = new ParenthesizedExpression(); }
        $parenthesizedExpression->parent = $parentNode;

        $parenthesizedExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        $parenthesizedExpression->expression = $this->parseExpression($parenthesizedExpression);
        $parenthesizedExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);

        return $parenthesizedExpression;
    }

    private function parseExitIntrinsicExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 785; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 785; $exitExpression = new ExitIntrinsicExpression(); }
        $exitExpression->parent = $parentNode;

        $exitExpression->exitOrDieKeyword = $this->eat(TokenKind::ExitKeyword, TokenKind::DieKeyword);
        $exitExpression->openParen = $this->eatOptional1(TokenKind::OpenParenToken);
        if ($exitExpression->openParen !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 783; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 783; if ($this->isExpressionStart($this->getCurrentToken())) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 781; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 781; $exitExpression->expression = $this->parseExpression($exitExpression); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 782; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 782; }
            $exitExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 784; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 784;

        return $exitExpression;
    }

    private function parsePrintIntrinsicExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 786; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 786; $printExpression = new PrintIntrinsicExpression(); }
        $printExpression->parent = $parentNode;

        $printExpression->printKeyword = $this->eat1(TokenKind::PrintKeyword);
        $printExpression->expression = $this->parseExpression($printExpression);

        return $printExpression;
    }

    private function parseIssetIntrinsicExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 787; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 787; $issetExpression = new IssetIntrinsicExpression(); }
        $issetExpression->parent = $parentNode;

        $issetExpression->issetKeyword = $this->eat1(TokenKind::IsSetKeyword);
        $issetExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        $issetExpression->expressions = $this->parseExpressionList($issetExpression);
        $issetExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);

        return $issetExpression;
    }

    private function parseUnaryOpExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 788; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 788; $unaryOpExpression = new UnaryOpExpression(); }
        $unaryOpExpression->parent = $parentNode;
        $unaryOpExpression->operator =
            $this->eat(TokenKind::PlusToken, TokenKind::MinusToken, TokenKind::ExclamationToken, TokenKind::TildeToken);
        $unaryOpExpression->operand = $this->parseUnaryExpressionOrHigher($unaryOpExpression);

        return $unaryOpExpression;
    }

    private function parseErrorControlExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 789; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 789; $errorControlExpression = new ErrorControlExpression(); }
        $errorControlExpression->parent = $parentNode;

        $errorControlExpression->operator = $this->eat1(TokenKind::AtSymbolToken);
        $errorControlExpression->operand = $this->parseUnaryExpressionOrHigher($errorControlExpression);

        return $errorControlExpression;
    }

    private function parsePrefixUpdateExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 792; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 792; $prefixUpdateExpression = new PrefixUpdateExpression(); }
        $prefixUpdateExpression->parent = $parentNode;

        $prefixUpdateExpression->incrementOrDecrementOperator = $this->eat(TokenKind::PlusPlusToken, TokenKind::MinusMinusToken);

        $prefixUpdateExpression->operand = $this->parsePrimaryExpression($prefixUpdateExpression);

        if (!($prefixUpdateExpression->operand instanceof MissingToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 790; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 790; $prefixUpdateExpression->operand = $this->parsePostfixExpressionRest($prefixUpdateExpression->operand, false); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 791; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 791;

        // TODO also check operand expression validity
        return $prefixUpdateExpression;
    }

    private function parsePostfixExpressionRest($expression, $allowUpdateExpression = true) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 826; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 826; $tokenKind = $this->getCurrentToken()->kind; }

        // `--$a++` is invalid
        if ($allowUpdateExpression &&
            (\PhpFuzzer\FuzzingContext::traceBlock(794, $tokenKind === TokenKind::PlusPlusToken ||
            \PhpFuzzer\FuzzingContext::traceBlock(793, $tokenKind === TokenKind::MinusMinusToken)))) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 795; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 795; return $this->parseParsePostfixUpdateExpression($expression); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 796; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 796;

        // TODO write tons of tests
        if (!($expression instanceof Variable ||
            \PhpFuzzer\FuzzingContext::traceBlock(797, $expression instanceof ParenthesizedExpression) ||
            \PhpFuzzer\FuzzingContext::traceBlock(798, $expression instanceof QualifiedName) ||
            \PhpFuzzer\FuzzingContext::traceBlock(799, $expression instanceof CallExpression) ||
            \PhpFuzzer\FuzzingContext::traceBlock(800, $expression instanceof MemberAccessExpression) ||
            \PhpFuzzer\FuzzingContext::traceBlock(801, $expression instanceof SubscriptExpression) ||
            \PhpFuzzer\FuzzingContext::traceBlock(802, $expression instanceof ScopedPropertyAccessExpression) ||
            \PhpFuzzer\FuzzingContext::traceBlock(803, $expression instanceof StringLiteral) ||
            \PhpFuzzer\FuzzingContext::traceBlock(804, $expression instanceof ArrayCreationExpression)
        )) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 805; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 805; return $expression; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 806; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 806;
        if ($tokenKind === TokenKind::ColonColonToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 807; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 807; $expression = $this->parseScopedPropertyAccessExpression($expression, null); }
            return $this->parsePostfixExpressionRest($expression);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 808; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 808;

        $tokenKind = $this->getCurrentToken()->kind;

        if ($tokenKind === TokenKind::OpenBraceToken ||
            \PhpFuzzer\FuzzingContext::traceBlock(809, $tokenKind === TokenKind::OpenBracketToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 810; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 810; $expression = $this->parseSubscriptExpression($expression); }
            return $this->parsePostfixExpressionRest($expression);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 811; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 811;

        if ($expression instanceof ArrayCreationExpression) {
            // Remaining postfix expressions are invalid, so abort
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 812; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 812; return $expression; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 813; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 813;

        if ($tokenKind === TokenKind::ArrowToken || \PhpFuzzer\FuzzingContext::traceBlock(814, $tokenKind === TokenKind::QuestionArrowToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 815; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 815; $expression = $this->parseMemberAccessExpression($expression); }
            return $this->parsePostfixExpressionRest($expression);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 816; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 816;

        if ($tokenKind === TokenKind::OpenParenToken && \PhpFuzzer\FuzzingContext::traceBlock(817, !$this->isParsingUnparenthesizedObjectCreationExpression($expression))) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 824; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 824; $expression = $this->parseCallExpressionRest($expression); }

            if (!$this->checkToken(TokenKind::OpenParenToken)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 818; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 818; return $this->parsePostfixExpressionRest($expression); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 819; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 819;
            if (
                $expression instanceof ParenthesizedExpression ||
                \PhpFuzzer\FuzzingContext::traceBlock(820, $expression instanceof CallExpression) ||
                \PhpFuzzer\FuzzingContext::traceBlock(821, $expression instanceof SubscriptExpression)) {
                // Continue parsing the remaining brackets for expressions
                // such as `(new Foo())()`, `foo()()`, `foo()['index']()`
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 822; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 822; return $this->parsePostfixExpressionRest($expression); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 823; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 823;
            return $expression;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 825; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 825;

        // Reached the end of the postfix-expression, so return
        return $expression;
    }

    private function parseMemberName($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 835; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 835; $token = $this->getCurrentToken(); }
        switch ($token->kind) {
            case TokenKind::Name:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 827; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 827; $this->advanceToken(); } // TODO all names should be Nodes
                return $token;
            case TokenKind::VariableName: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 828; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 828;
            case TokenKind::DollarToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 829; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 829; return $this->parseSimpleVariable($parentNode); } // TODO should be simple-variable
            case TokenKind::OpenBraceToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 830; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 830; return $this->parseBracedExpression($parentNode); }

            default:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 833; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 833; if (\in_array($token->kind, $this->nameOrKeywordOrReservedWordTokens)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 831; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 831; $this->advanceToken(); }
                    $token->kind = TokenKind::Name;
                    return $token;
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 832; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 832; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 834; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 834;
        return new MissingToken(TokenKind::MemberName, $token->fullStart);
    }

    private function isArgumentExpressionStartFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 838; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 838; return function ($token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 837; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 837; return
                isset($this->argumentStartTokensSet[$token->kind]) || \PhpFuzzer\FuzzingContext::traceBlock(836, $this->isExpressionStart($token)); }
        }; }
    }

    private function parseArgumentExpressionFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 849; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 849; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 848; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 848; $argumentExpression = new ArgumentExpression(); }
            $argumentExpression->parent = $parentNode;

            $nextToken = $this->lexer->getTokensArray()[$this->lexer->getCurrentPosition()] ?? \PhpFuzzer\FuzzingContext::traceBlock(839, null);
            if ($nextToken && \PhpFuzzer\FuzzingContext::traceBlock(840, $nextToken->kind === TokenKind::ColonToken)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 846; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 846; $name = $this->token; }
                $this->advanceToken();
                if ($name->kind === TokenKind::YieldFromKeyword || \PhpFuzzer\FuzzingContext::traceBlock(841, !\in_array($name->kind, $this->nameOrKeywordOrReservedWordTokens))) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 843; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 843; $name = new SkippedToken($name); }
                } else {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 842; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 842; $name->kind = TokenKind::Name; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 844; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 844;
                $argumentExpression->name = $name;
                $argumentExpression->colonToken = $this->eat1(TokenKind::ColonToken);
            } else {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 845; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 845; $argumentExpression->byRefToken = $this->eatOptional1(TokenKind::AmpersandToken); }
                $argumentExpression->dotDotDotToken = $this->eatOptional1(TokenKind::DotDotDotToken);
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 847; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 847;
            $argumentExpression->expression = $this->parseExpression($argumentExpression);
            return $argumentExpression;
        }; }
    }

    private function parseCallExpressionRest($expression) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 850; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 850; $callExpression = new CallExpression(); }
        $callExpression->parent = $expression->parent;
        $expression->parent = $callExpression;
        $callExpression->callableExpression = $expression;
        $callExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        $callExpression->argumentExpressionList =
            $this->parseArgumentExpressionList($callExpression);
        $callExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);
        return $callExpression;
    }

    private function parseParsePostfixUpdateExpression($prefixExpression) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 851; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 851; $postfixUpdateExpression = new PostfixUpdateExpression(); }
        $postfixUpdateExpression->operand = $prefixExpression;
        $postfixUpdateExpression->parent = $prefixExpression->parent;
        $prefixExpression->parent = $postfixUpdateExpression;
        $postfixUpdateExpression->incrementOrDecrementOperator =
            $this->eat(TokenKind::PlusPlusToken, TokenKind::MinusMinusToken);
        return $postfixUpdateExpression;
    }

    private function parseBracedExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 852; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 852; $bracedExpression = new BracedExpression(); }
        $bracedExpression->parent = $parentNode;

        $bracedExpression->openBrace = $this->eat1(TokenKind::OpenBraceToken);
        $bracedExpression->expression = $this->parseExpression($bracedExpression);
        $bracedExpression->closeBrace = $this->eat1(TokenKind::CloseBraceToken);

        return $bracedExpression;
    }

    private function parseSubscriptExpression($expression) : SubscriptExpression {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 857; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 857; $subscriptExpression = new SubscriptExpression(); }
        $subscriptExpression->parent = $expression->parent;
        $expression->parent = $subscriptExpression;

        $subscriptExpression->postfixExpression = $expression;
        $subscriptExpression->openBracketOrBrace = $this->eat(TokenKind::OpenBracketToken, TokenKind::OpenBraceToken);
        $subscriptExpression->accessExpression = $this->isExpressionStart($this->getCurrentToken())
            ? $this->parseExpression($subscriptExpression)
            : \PhpFuzzer\FuzzingContext::traceBlock(853, null); // TODO error if used in a getter

        if ($subscriptExpression->openBracketOrBrace->kind === TokenKind::OpenBraceToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 855; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 855; $subscriptExpression->closeBracketOrBrace = $this->eat1(TokenKind::CloseBraceToken); }
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 854; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 854; $subscriptExpression->closeBracketOrBrace = $this->eat1(TokenKind::CloseBracketToken); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 856; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 856;

        return $subscriptExpression;
    }

    private function parseMemberAccessExpression($expression):MemberAccessExpression {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 858; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 858; $memberAccessExpression = new MemberAccessExpression(); }
        $memberAccessExpression->parent = $expression->parent;
        $expression->parent = $memberAccessExpression;

        $memberAccessExpression->dereferencableExpression = $expression;
        $memberAccessExpression->arrowToken = $this->eat(TokenKind::ArrowToken, TokenKind::QuestionArrowToken);
        $memberAccessExpression->memberName = $this->parseMemberName($memberAccessExpression);

        return $memberAccessExpression;
    }

    /**
     * @param Node|null $expression
     * @param Node|null $fallbackParentNode (Workaround for the invalid AST `use TraitName::foo as ::x`)
     */
    private function parseScopedPropertyAccessExpression($expression, $fallbackParentNode): ScopedPropertyAccessExpression {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 862; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 862; $scopedPropertyAccessExpression = new ScopedPropertyAccessExpression(); }
        $scopedPropertyAccessExpression->parent = $expression->parent ?? \PhpFuzzer\FuzzingContext::traceBlock(859, $fallbackParentNode);
        if ($expression instanceof Node) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 860; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 860; $expression->parent = $scopedPropertyAccessExpression; }
            $scopedPropertyAccessExpression->scopeResolutionQualifier = $expression; // TODO ensure always a Node
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 861; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 861;

        $scopedPropertyAccessExpression->doubleColon = $this->eat1(TokenKind::ColonColonToken);
        $scopedPropertyAccessExpression->memberName = $this->parseMemberName($scopedPropertyAccessExpression);

        return $scopedPropertyAccessExpression;
    }

    public function isParsingUnparenthesizedObjectCreationExpression($expression) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 871; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 871; if (!$this->isParsingObjectCreationExpression) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 863; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 863; return false; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 864; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 864; }
        if ($expression instanceof Token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 865; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 865; return true; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 866; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 866;
        while ($expression->parent) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 870; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 870; $expression = $expression->parent; }
            if ($expression instanceof ObjectCreationExpression) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 868; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 868; return true; }
            } elseif ($expression instanceof ParenthesizedExpression) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 867; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 867; return false; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 869; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 869;
        }
    }

    private $isParsingObjectCreationExpression = false;

    private function parseObjectCreationExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 879; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 879; $objectCreationExpression = new ObjectCreationExpression(); }
        $objectCreationExpression->parent = $parentNode;
        $objectCreationExpression->newKeword = $this->eat1(TokenKind::NewKeyword);
        // TODO - add tests for this scenario
        $oldIsParsingObjectCreationExpression = $this->isParsingObjectCreationExpression;
        $this->isParsingObjectCreationExpression = true;

        if ($this->getCurrentToken()->kind === TokenKind::AttributeToken) {
            // Attributes such as `new #[MyAttr] class` can only be used with anonymous class declarations.
            // But handle this like $objectCreationExpression->classMembers and leave it up to the applications to detect the invalid combination.
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 872; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 872; $objectCreationExpression->attributes = $this->parseAttributeGroups($objectCreationExpression); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 873; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 873;
        $objectCreationExpression->classTypeDesignator =
            $this->eatOptional1(TokenKind::ClassKeyword) ??
            \PhpFuzzer\FuzzingContext::traceBlock(874, $this->parseExpression($objectCreationExpression));

        $this->isParsingObjectCreationExpression = $oldIsParsingObjectCreationExpression;

        $objectCreationExpression->openParen = $this->eatOptional1(TokenKind::OpenParenToken);
        if ($objectCreationExpression->openParen !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 875; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 875; $objectCreationExpression->argumentExpressionList = $this->parseArgumentExpressionList($objectCreationExpression); }
            $objectCreationExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 876; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 876;

        $objectCreationExpression->classBaseClause = $this->parseClassBaseClause($objectCreationExpression);
        $objectCreationExpression->classInterfaceClause = $this->parseClassInterfaceClause($objectCreationExpression);

        if ($this->getCurrentToken()->kind === TokenKind::OpenBraceToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 877; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 877; $objectCreationExpression->classMembers = $this->parseClassMembers($objectCreationExpression); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 878; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 878;

        return $objectCreationExpression;
    }

    private function parseArgumentExpressionList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 880; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 880; return $this->parseDelimitedList(
            DelimitedList\ArgumentExpressionList::class,
            TokenKind::CommaToken,
            $this->isArgumentExpressionStartFn(),
            $this->parseArgumentExpressionFn(),
            $parentNode
        ); }
    }

    /**
     * @param Node|Token $leftOperand (should only be a token for invalid ASTs)
     * @param Token $questionToken
     * @param Node $fallbackParentNode
     */
    private function parseTernaryExpression($leftOperand, $questionToken, $fallbackParentNode):TernaryExpression {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 885; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 885; $ternaryExpression = new TernaryExpression(); }
        if ($leftOperand instanceof Node) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 882; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 882; $ternaryExpression->parent = $leftOperand->parent; }
            $leftOperand->parent = $ternaryExpression;
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 881; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 881; $ternaryExpression->parent = $fallbackParentNode; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 883; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 883;
        $ternaryExpression->condition = $leftOperand;
        $ternaryExpression->questionToken = $questionToken;
        $ternaryExpression->ifExpression = $this->isExpressionStart($this->getCurrentToken()) ? $this->parseExpression($ternaryExpression) : \PhpFuzzer\FuzzingContext::traceBlock(884, null);
        $ternaryExpression->colonToken = $this->eat1(TokenKind::ColonToken);
        $ternaryExpression->elseExpression = $this->parseBinaryExpressionOrHigher(9, $ternaryExpression);
        $leftOperand = $ternaryExpression;
        return $leftOperand;
    }

    private function parseClassInterfaceClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 888; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 888; $classInterfaceClause = new ClassInterfaceClause(); }
        $classInterfaceClause->parent = $parentNode;
        $classInterfaceClause->implementsKeyword = $this->eatOptional1(TokenKind::ImplementsKeyword);

        if ($classInterfaceClause->implementsKeyword === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 886; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 886; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 887; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 887;

        $classInterfaceClause->interfaceNameList =
            $this->parseQualifiedNameList($classInterfaceClause);
        return $classInterfaceClause;
    }

    private function parseClassBaseClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 891; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 891; $classBaseClause = new ClassBaseClause(); }
        $classBaseClause->parent = $parentNode;

        $classBaseClause->extendsKeyword = $this->eatOptional1(TokenKind::ExtendsKeyword);
        if ($classBaseClause->extendsKeyword === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 889; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 889; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 890; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 890;
        $classBaseClause->baseClass = $this->parseQualifiedName($classBaseClause);

        return $classBaseClause;
    }

    private function parseClassConstDeclaration($parentNode, $modifiers) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 892; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 892; $classConstDeclaration = new ClassConstDeclaration(); }
        $classConstDeclaration->parent = $parentNode;

        $classConstDeclaration->modifiers = $modifiers;
        $classConstDeclaration->constKeyword = $this->eat1(TokenKind::ConstKeyword);
        $classConstDeclaration->constElements = $this->parseConstElements($classConstDeclaration);
        $classConstDeclaration->semicolon = $this->eat1(TokenKind::SemicolonToken);

        return $classConstDeclaration;
    }

    /**
     * @param Node $parentNode
     * @param Token[] $modifiers
     * @param Token|null $questionToken
     */
    private function parseRemainingPropertyDeclarationOrMissingMemberDeclaration($parentNode, $modifiers, $questionToken = null)
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 895; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 895; $typeDeclarationList = $this->tryParseParameterTypeDeclarationList(null); }
        if ($this->getCurrentToken()->kind !== TokenKind::VariableName) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 893; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 893; return $this->makeMissingMemberDeclaration($parentNode, $modifiers, $questionToken, $typeDeclarationList); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 894; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 894;
        return $this->parsePropertyDeclaration($parentNode, $modifiers, $questionToken, $typeDeclarationList);
    }

    /**
     * @param Node $parentNode
     * @param Token[] $modifiers
     * @param Token|null $questionToken
     * @param DelimitedList\QualifiedNameList|null $typeDeclarationList
     */
    private function parsePropertyDeclaration($parentNode, $modifiers, $questionToken = null, $typeDeclarationList = null) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 903; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 903; $propertyDeclaration = new PropertyDeclaration(); }
        $propertyDeclaration->parent = $parentNode;

        $propertyDeclaration->modifiers = $modifiers;
        $propertyDeclaration->questionToken = $questionToken;
        if ($typeDeclarationList) {
            /** $typeDeclarationList is a Node or a Token (e.g. IntKeyword) */
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 901; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 901; $typeDeclaration = \array_shift($typeDeclarationList->children); }
            $propertyDeclaration->typeDeclaration = $typeDeclaration;
            if ($typeDeclaration instanceof Node) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 896; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 896; $typeDeclaration->parent = $propertyDeclaration; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 897; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 897;
            if ($typeDeclarationList->children) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 898; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 898; $propertyDeclaration->otherTypeDeclarations = $typeDeclarationList; }
                $typeDeclarationList->parent = $propertyDeclaration;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 899; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 899;
        } elseif ($questionToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 900; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 900; $propertyDeclaration->typeDeclaration = new MissingToken(TokenKind::PropertyType, $this->token->fullStart); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 902; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 902;
        $propertyDeclaration->propertyElements = $this->parseExpressionList($propertyDeclaration);
        $propertyDeclaration->semicolon = $this->eat1(TokenKind::SemicolonToken);

        return $propertyDeclaration;
    }

    /**
     * @param Node $parentNode
     * @return DelimitedList\QualifiedNameList
     */
    private function parseQualifiedNameList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 904; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 904; return $this->parseDelimitedList(
            DelimitedList\QualifiedNameList::class,
            TokenKind::CommaToken,
            $this->isQualifiedNameStartFn(),
            $this->parseQualifiedNameFn(),
            $parentNode); }
    }

    private function parseQualifiedNameCatchList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 909; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 909; $result = $this->parseDelimitedList(
            DelimitedList\QualifiedNameList::class,
            TokenKind::BarToken,
            $this->isQualifiedNameStartForCatchFn(),
            $this->parseQualifiedNameFn(),
            $parentNode); }

        // Add a MissingToken so that this will Warn about `catch (T| $x) {}`
        // TODO: Make this a reusable abstraction?
        if ($result && \PhpFuzzer\FuzzingContext::traceBlock(906, (end($result->children)->kind ?? \PhpFuzzer\FuzzingContext::traceBlock(905, null)) === TokenKind::BarToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 907; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 907; $result->children[] = new MissingToken(TokenKind::Name, $this->token->fullStart); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 908; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 908;
        return $result;
    }

    private function parseInterfaceDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 910; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 910; $interfaceDeclaration = new InterfaceDeclaration(); } // TODO verify not nested
        $interfaceDeclaration->parent = $parentNode;
        $interfaceDeclaration->interfaceKeyword = $this->eat1(TokenKind::InterfaceKeyword);
        $interfaceDeclaration->name = $this->eat1(TokenKind::Name);
        $interfaceDeclaration->interfaceBaseClause = $this->parseInterfaceBaseClause($interfaceDeclaration);
        $interfaceDeclaration->interfaceMembers = $this->parseInterfaceMembers($interfaceDeclaration);
        return $interfaceDeclaration;
    }

    private function parseInterfaceMembers($parentNode) : Node {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 911; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 911; $interfaceMembers = new InterfaceMembers(); }
        $interfaceMembers->openBrace = $this->eat1(TokenKind::OpenBraceToken);
        $interfaceMembers->interfaceMemberDeclarations = $this->parseList($interfaceMembers, ParseContext::InterfaceMembers);
        $interfaceMembers->closeBrace = $this->eat1(TokenKind::CloseBraceToken);
        $interfaceMembers->parent = $parentNode;
        return $interfaceMembers;
    }

    private function isInterfaceMemberDeclarationStart(Token $token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 922; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 922; switch ($token->kind) {
            // visibility-modifier
            case TokenKind::PublicKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 912; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 912;
            case TokenKind::ProtectedKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 913; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 913;
            case TokenKind::PrivateKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 914; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 914;

            // static-modifier
            case TokenKind::StaticKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 915; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 915;

            // class-modifier
            case TokenKind::AbstractKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 916; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 916;
            case TokenKind::FinalKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 917; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 917;

            case TokenKind::ConstKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 918; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 918;

            case TokenKind::FunctionKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 919; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 919;

            case TokenKind::AttributeToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 920; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 920; return true; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 921; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 921; }
        return false;
    }

    private function parseInterfaceElementFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 929; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 929; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 928; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 928; $modifiers = $this->parseModifiers(); }

            $token = $this->getCurrentToken();
            switch ($token->kind) {
                case TokenKind::ConstKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 923; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 923; return $this->parseClassConstDeclaration($parentNode, $modifiers); }

                case TokenKind::FunctionKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 924; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 924; return $this->parseMethodDeclaration($parentNode, $modifiers); }

                case TokenKind::AttributeToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 925; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 925; return $this->parseAttributeStatement($parentNode); }

                default:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 926; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 926; $missingInterfaceMemberDeclaration = new MissingMemberDeclaration(); }
                    $missingInterfaceMemberDeclaration->parent = $parentNode;
                    $missingInterfaceMemberDeclaration->modifiers = $modifiers;
                    return $missingInterfaceMemberDeclaration;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 927; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 927;
        }; }
    }

    private function parseInterfaceBaseClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 933; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 933; $interfaceBaseClause = new InterfaceBaseClause(); }
        $interfaceBaseClause->parent = $parentNode;

        $interfaceBaseClause->extendsKeyword = $this->eatOptional1(TokenKind::ExtendsKeyword);
        if (isset($interfaceBaseClause->extendsKeyword)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 931; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 931; $interfaceBaseClause->interfaceNameList = $this->parseQualifiedNameList($interfaceBaseClause); }
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 930; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 930; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 932; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 932;

        return $interfaceBaseClause;
    }

    private function parseNamespaceDefinition($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 937; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 937; $namespaceDefinition = new NamespaceDefinition(); }
        $namespaceDefinition->parent = $parentNode;

        $namespaceDefinition->namespaceKeyword = $this->eat1(TokenKind::NamespaceKeyword);

        if (!$this->checkToken(TokenKind::NamespaceKeyword)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 934; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 934; $namespaceDefinition->name = $this->parseQualifiedName($namespaceDefinition); } // TODO only optional with compound statement block
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 935; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 935;

        $namespaceDefinition->compoundStatementOrSemicolon =
            $this->checkToken(TokenKind::OpenBraceToken) ?
                $this->parseCompoundStatement($namespaceDefinition) : \PhpFuzzer\FuzzingContext::traceBlock(936, $this->eatSemicolonOrAbortStatement());

        return $namespaceDefinition;
    }

    private function parseNamespaceUseDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 938; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 938; $namespaceUseDeclaration = new NamespaceUseDeclaration(); }
        $namespaceUseDeclaration->parent = $parentNode;
        $namespaceUseDeclaration->useKeyword = $this->eat1(TokenKind::UseKeyword);
        $namespaceUseDeclaration->functionOrConst = $this->eatOptional(TokenKind::FunctionKeyword, TokenKind::ConstKeyword);
        $namespaceUseDeclaration->useClauses = $this->parseNamespaceUseClauseList($namespaceUseDeclaration);
        $namespaceUseDeclaration->semicolon = $this->eatSemicolonOrAbortStatement();
        return $namespaceUseDeclaration;
    }

    private function parseNamespaceUseClauseList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 946; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 946; return $this->parseDelimitedList(
            DelimitedList\NamespaceUseClauseList::class,
            TokenKind::CommaToken,
            function ($token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 941; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 941; return $this->isQualifiedNameStart($token) || \PhpFuzzer\FuzzingContext::traceBlock(939, $token->kind === TokenKind::FunctionKeyword) || \PhpFuzzer\FuzzingContext::traceBlock(940, $token->kind === TokenKind::ConstKeyword); }
            },
            function ($parentNode) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 945; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 945; $namespaceUseClause = new NamespaceUseClause(); }
                $namespaceUseClause->parent = $parentNode;
                $namespaceUseClause->namespaceName = $this->parseQualifiedName($namespaceUseClause);
                if ($this->checkToken(TokenKind::AsKeyword)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 943; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 943; $namespaceUseClause->namespaceAliasingClause = $this->parseNamespaceAliasingClause($namespaceUseClause); }
                }
                elseif ($this->checkToken(TokenKind::OpenBraceToken)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 942; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 942; $namespaceUseClause->openBrace = $this->eat1(TokenKind::OpenBraceToken); }
                    $namespaceUseClause->groupClauses = $this->parseNamespaceUseGroupClauseList($namespaceUseClause);
                    $namespaceUseClause->closeBrace = $this->eat1(TokenKind::CloseBraceToken);
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 944; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 944;

                return $namespaceUseClause;
            },
            $parentNode
        ); }
    }

    private function parseNamespaceUseGroupClauseList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 953; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 953; return $this->parseDelimitedList(
            DelimitedList\NamespaceUseGroupClauseList::class,
            TokenKind::CommaToken,
            function ($token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 949; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 949; return $this->isQualifiedNameStart($token) || \PhpFuzzer\FuzzingContext::traceBlock(947, $token->kind === TokenKind::FunctionKeyword) || \PhpFuzzer\FuzzingContext::traceBlock(948, $token->kind === TokenKind::ConstKeyword); }
            },
            function ($parentNode) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 952; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 952; $namespaceUseGroupClause = new NamespaceUseGroupClause(); }
                $namespaceUseGroupClause->parent = $parentNode;

                $namespaceUseGroupClause->functionOrConst = $this->eatOptional(TokenKind::FunctionKeyword, TokenKind::ConstKeyword);
                $namespaceUseGroupClause->namespaceName = $this->parseQualifiedName($namespaceUseGroupClause);
                if ($this->checkToken(TokenKind::AsKeyword)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 950; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 950; $namespaceUseGroupClause->namespaceAliasingClause = $this->parseNamespaceAliasingClause($namespaceUseGroupClause); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 951; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 951;

                return $namespaceUseGroupClause;
            },
            $parentNode
        ); }
    }

    private function parseNamespaceAliasingClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 954; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 954; $namespaceAliasingClause = new NamespaceAliasingClause(); }
        $namespaceAliasingClause->parent = $parentNode;
        $namespaceAliasingClause->asKeyword = $this->eat1(TokenKind::AsKeyword);
        $namespaceAliasingClause->name = $this->eat1(TokenKind::Name);
        return $namespaceAliasingClause;
    }

    private function parseTraitDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 955; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 955; $traitDeclaration = new TraitDeclaration(); }
        $traitDeclaration->parent = $parentNode;

        $traitDeclaration->traitKeyword = $this->eat1(TokenKind::TraitKeyword);
        $traitDeclaration->name = $this->eat1(TokenKind::Name);

        $traitDeclaration->traitMembers = $this->parseTraitMembers($traitDeclaration);

        return $traitDeclaration;
    }

    private function parseTraitMembers($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 956; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 956; $traitMembers = new TraitMembers(); }
        $traitMembers->parent = $parentNode;

        $traitMembers->openBrace = $this->eat1(TokenKind::OpenBraceToken);

        $traitMembers->traitMemberDeclarations = $this->parseList($traitMembers, ParseContext::TraitMembers);

        $traitMembers->closeBrace = $this->eat1(TokenKind::CloseBraceToken);

        return $traitMembers;
    }

    private function isTraitMemberDeclarationStart($token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 969; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 969; switch ($token->kind) {
            // property-declaration
            case TokenKind::VariableName: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 957; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 957;

            // modifiers
            case TokenKind::PublicKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 958; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 958;
            case TokenKind::ProtectedKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 959; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 959;
            case TokenKind::PrivateKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 960; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 960;
            case TokenKind::VarKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 961; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 961;
            case TokenKind::StaticKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 962; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 962;
            case TokenKind::AbstractKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 963; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 963;
            case TokenKind::FinalKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 964; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 964;

            // method-declaration
            case TokenKind::FunctionKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 965; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 965;

            // trait-use-clauses
            case TokenKind::UseKeyword: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 966; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 966;

            // attributes
            case TokenKind::AttributeToken:
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 967; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 967; return true; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 968; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 968; }
        return false;
    }

    private function parseTraitElementFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 978; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 978; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 977; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 977; $modifiers = $this->parseModifiers(); }

            $token = $this->getCurrentToken();
            switch ($token->kind) {
                case TokenKind::FunctionKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 970; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 970; return $this->parseMethodDeclaration($parentNode, $modifiers); }

                case TokenKind::QuestionToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 971; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 971; return $this->parseRemainingPropertyDeclarationOrMissingMemberDeclaration(
                        $parentNode,
                        $modifiers,
                        $this->eat1(TokenKind::QuestionToken)
                    ); }
                case TokenKind::VariableName:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 972; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 972; return $this->parsePropertyDeclaration($parentNode, $modifiers); }

                case TokenKind::UseKeyword:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 973; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 973; return $this->parseTraitUseClause($parentNode); }

                case TokenKind::AttributeToken:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 974; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 974; return $this->parseAttributeStatement($parentNode); }

                default:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 975; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 975; return $this->parseRemainingPropertyDeclarationOrMissingMemberDeclaration($parentNode, $modifiers); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 976; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 976;
        }; }
    }

    /**
     * @param Node $parentNode
     * @param Token[] $modifiers
     * @param Token $questionToken
     * @param DelimitedList\QualifiedNameList|null $typeDeclarationList
     */
    private function makeMissingMemberDeclaration($parentNode, $modifiers, $questionToken = null, $typeDeclarationList = null) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 984; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 984; $missingTraitMemberDeclaration = new MissingMemberDeclaration(); }
        $missingTraitMemberDeclaration->parent = $parentNode;
        $missingTraitMemberDeclaration->modifiers = $modifiers;
        $missingTraitMemberDeclaration->questionToken = $questionToken;
        if ($typeDeclarationList) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 982; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 982; $missingTraitMemberDeclaration->typeDeclaration = \array_shift($typeDeclarationList->children); }
            $missingTraitMemberDeclaration->typeDeclaration->parent = $missingTraitMemberDeclaration;
            if ($typeDeclarationList->children) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 979; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 979; $missingTraitMemberDeclaration->otherTypeDeclarations = $typeDeclarationList; }
                $typeDeclarationList->parent = $missingTraitMemberDeclaration;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 980; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 980;
        } elseif ($questionToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 981; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 981; $missingTraitMemberDeclaration->typeDeclaration = new MissingToken(TokenKind::PropertyType, $this->token->fullStart); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 983; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 983;
        return $missingTraitMemberDeclaration;
    }

    private function parseTraitUseClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 987; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 987; $traitUseClause = new TraitUseClause(); }
        $traitUseClause->parent = $parentNode;

        $traitUseClause->useKeyword = $this->eat1(TokenKind::UseKeyword);
        $traitUseClause->traitNameList = $this->parseQualifiedNameList($traitUseClause);

        $traitUseClause->semicolonOrOpenBrace = $this->eat(TokenKind::OpenBraceToken, TokenKind::SemicolonToken);
        if ($traitUseClause->semicolonOrOpenBrace->kind === TokenKind::OpenBraceToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 985; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 985; $traitUseClause->traitSelectAndAliasClauses = $this->parseTraitSelectAndAliasClauseList($traitUseClause); }
            $traitUseClause->closeBrace = $this->eat1(TokenKind::CloseBraceToken);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 986; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 986;

        return $traitUseClause;
    }

    private function parseTraitSelectAndAliasClauseList($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 988; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 988; return $this->parseDelimitedList(
            DelimitedList\TraitSelectOrAliasClauseList::class,
            TokenKind::SemicolonToken,
            $this->isQualifiedNameStartFn(),
            $this->parseTraitSelectOrAliasClauseFn(),
            $parentNode
        ); }
    }

    private function parseTraitSelectOrAliasClauseFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 995; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 995; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 994; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 994; $traitSelectAndAliasClause = new TraitSelectOrAliasClause(); }
            $traitSelectAndAliasClause->parent = $parentNode;
            $traitSelectAndAliasClause->name = // TODO update spec
                $this->parseQualifiedNameOrScopedPropertyAccessExpression($traitSelectAndAliasClause);

            $traitSelectAndAliasClause->asOrInsteadOfKeyword = $this->eat(TokenKind::AsKeyword, TokenKind::InsteadOfKeyword);
            $traitSelectAndAliasClause->modifiers = $this->parseModifiers(); // TODO accept all modifiers, verify later

            if ($traitSelectAndAliasClause->asOrInsteadOfKeyword->kind === TokenKind::InsteadOfKeyword) {
                // https://github.com/Microsoft/tolerant-php-parser/issues/190
                // TODO: In the next backwards incompatible release, convert targetName to a list?
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 992; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 992; $interfaceNameList = $this->parseQualifiedNameList($traitSelectAndAliasClause)->children ?? \PhpFuzzer\FuzzingContext::traceBlock(989, []); }
                $traitSelectAndAliasClause->targetName = $interfaceNameList[0] ?? \PhpFuzzer\FuzzingContext::traceBlock(990, new MissingToken(TokenKind::BarToken, $this->token->fullStart));
                $traitSelectAndAliasClause->remainingTargetNames = array_slice($interfaceNameList, 1);
            } else {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 991; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 991; $traitSelectAndAliasClause->targetName =
                    $this->parseQualifiedNameOrScopedPropertyAccessExpression($traitSelectAndAliasClause); }
                $traitSelectAndAliasClause->remainingTargetNames = [];
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 993; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 993;

            // TODO errors for insteadof/as
            return $traitSelectAndAliasClause;
        }; }
    }

    private function parseQualifiedNameOrScopedPropertyAccessExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 998; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 998; $qualifiedNameOrScopedProperty = $this->parseQualifiedName($parentNode); }
        if ($this->getCurrentToken()->kind === TokenKind::ColonColonToken) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 996; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 996; $qualifiedNameOrScopedProperty = $this->parseScopedPropertyAccessExpression($qualifiedNameOrScopedProperty, $parentNode); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 997; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 997;
        return $qualifiedNameOrScopedProperty;
    }

    private function parseGlobalDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 999; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 999; $globalDeclaration = new GlobalDeclaration(); }
        $globalDeclaration->parent = $parentNode;

        $globalDeclaration->globalKeyword = $this->eat1(TokenKind::GlobalKeyword);
        $globalDeclaration->variableNameList = $this->parseDelimitedList(
            DelimitedList\VariableNameList::class,
            TokenKind::CommaToken,
            $this->isVariableNameStartFn(),
            $this->parseSimpleVariableFn(),
            $globalDeclaration
        );

        $globalDeclaration->semicolon = $this->eatSemicolonOrAbortStatement();

        return $globalDeclaration;
    }

    private function parseFunctionStaticDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1001; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1001; $functionStaticDeclaration = new FunctionStaticDeclaration(); }
        $functionStaticDeclaration->parent = $parentNode;

        $functionStaticDeclaration->staticKeyword = $this->eat1(TokenKind::StaticKeyword);
        $functionStaticDeclaration->staticVariableNameList = $this->parseDelimitedList(
            DelimitedList\StaticVariableNameList::class,
            TokenKind::CommaToken,
            function ($token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1000; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1000; return $token->kind === TokenKind::VariableName; }
            },
            $this->parseStaticVariableDeclarationFn(),
            $functionStaticDeclaration
        );
        $functionStaticDeclaration->semicolon = $this->eatSemicolonOrAbortStatement();

        return $functionStaticDeclaration;
    }

    private function isVariableNameStartFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1004; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1004; return function ($token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1003; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1003; return $token->kind === TokenKind::VariableName || \PhpFuzzer\FuzzingContext::traceBlock(1002, $token->kind === TokenKind::DollarToken); }
        }; }
    }

    private function parseStaticVariableDeclarationFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1008; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1008; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1007; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1007; $staticVariableDeclaration = new StaticVariableDeclaration(); }
            $staticVariableDeclaration->parent = $parentNode;
            $staticVariableDeclaration->variableName = $this->eat1(TokenKind::VariableName);
            $staticVariableDeclaration->equalsToken = $this->eatOptional1(TokenKind::EqualsToken);
            if ($staticVariableDeclaration->equalsToken !== null) {
                // TODO add post-parse rule that checks for invalid assignments
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1005; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1005; $staticVariableDeclaration->assignment = $this->parseExpression($staticVariableDeclaration); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1006; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1006;
            return $staticVariableDeclaration;
        }; }
    }

    private function parseConstDeclaration($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1009; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1009; $constDeclaration = new ConstDeclaration(); }
        $constDeclaration->parent = $parentNode;

        $constDeclaration->constKeyword = $this->eat1(TokenKind::ConstKeyword);
        $constDeclaration->constElements = $this->parseConstElements($constDeclaration);
        $constDeclaration->semicolon = $this->eatSemicolonOrAbortStatement();

        return $constDeclaration;
    }

    private function parseConstElements($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1011; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1011; return $this->parseDelimitedList(
            DelimitedList\ConstElementList::class,
            TokenKind::CommaToken,
            function ($token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1010; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1010; return \in_array($token->kind, $this->nameOrKeywordOrReservedWordTokens); }
            },
            $this->parseConstElementFn(),
            $parentNode
        ); }
    }

    private function parseConstElementFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1013; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1013; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1012; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1012; $constElement = new ConstElement(); }
            $constElement->parent = $parentNode;
            $constElement->name = $this->getCurrentToken();
            $this->advanceToken();
            $constElement->name->kind = TokenKind::Name; // to support keyword names
            $constElement->equalsToken = $this->eat1(TokenKind::EqualsToken);
            // TODO add post-parse rule that checks for invalid assignments
            $constElement->assignment = $this->parseExpression($constElement);
            return $constElement;
        }; }
    }

    private function parseCastExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1014; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1014; $castExpression = new CastExpression(); }
        $castExpression->parent = $parentNode;
        $castExpression->castType = $this->eat(
            TokenKind::ArrayCastToken,
            TokenKind::BoolCastToken,
            TokenKind::DoubleCastToken,
            TokenKind::IntCastToken,
            TokenKind::ObjectCastToken,
            TokenKind::StringCastToken,
            TokenKind::UnsetCastToken
        );

        $castExpression->operand = $this->parseUnaryExpressionOrHigher($castExpression);

        return $castExpression;
    }

    private function parseCastExpressionGranular($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1015; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1015; $castExpression = new CastExpression(); }
        $castExpression->parent = $parentNode;

        $castExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        $castExpression->castType = $this->eat(
            TokenKind::ArrayKeyword,
            TokenKind::BinaryReservedWord,
            TokenKind::BoolReservedWord,
            TokenKind::BooleanReservedWord,
            TokenKind::DoubleReservedWord,
            TokenKind::IntReservedWord,
            TokenKind::IntegerReservedWord,
            TokenKind::FloatReservedWord,
            TokenKind::ObjectReservedWord,
            TokenKind::RealReservedWord,
            TokenKind::StringReservedWord,
            TokenKind::UnsetKeyword
        );
        $castExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $castExpression->operand = $this->parseUnaryExpressionOrHigher($castExpression);

        return $castExpression;
    }

    private function parseAnonymousFunctionCreationExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1018; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1018; $staticModifier = $this->eatOptional1(TokenKind::StaticKeyword); }
        if ($this->getCurrentToken()->kind === TokenKind::FnKeyword) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1016; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1016; return $this->parseArrowFunctionCreationExpression($parentNode, $staticModifier); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1017; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1017;
        $anonymousFunctionCreationExpression = new AnonymousFunctionCreationExpression();
        $anonymousFunctionCreationExpression->parent = $parentNode;

        $anonymousFunctionCreationExpression->staticModifier = $staticModifier;
        $this->parseFunctionType($anonymousFunctionCreationExpression, false, true);

        return $anonymousFunctionCreationExpression;
    }

    private function parseArrowFunctionCreationExpression($parentNode, $staticModifier) : ArrowFunctionCreationExpression {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1023; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1023; $arrowFunction = new ArrowFunctionCreationExpression(); }
        $arrowFunction->parent = $parentNode;
        $arrowFunction->staticModifier = $staticModifier;

        $arrowFunction->functionKeyword = $this->eat1(TokenKind::FnKeyword);
        $arrowFunction->byRefToken = $this->eatOptional1(TokenKind::AmpersandToken);
        $arrowFunction->name = $this->eatOptional($this->nameOrKeywordOrReservedWordTokens);

        if (isset($arrowFunction->name)) {
            // Anonymous functions should not have names.
            // This is based on the code for AnonymousFunctionCreationExpression.
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1019; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1019; $arrowFunction->name->kind = TokenKind::Name; }
            $arrowFunction->name = new SkippedToken($arrowFunction->name); // TODO instead handle this during post-walk
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1020; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1020;

        $arrowFunction->openParen = $this->eat1(TokenKind::OpenParenToken);
        $arrowFunction->parameters = $this->parseDelimitedList(
            DelimitedList\ParameterDeclarationList::class,
            TokenKind::CommaToken,
            $this->isParameterStartFn(),
            $this->parseParameterFn(),
            $arrowFunction);
        $arrowFunction->closeParen = $this->eat1(TokenKind::CloseParenToken);

        if ($this->checkToken(TokenKind::ColonToken)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1021; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1021; $arrowFunction->colonToken = $this->eat1(TokenKind::ColonToken); }
            $arrowFunction->questionToken = $this->eatOptional1(TokenKind::QuestionToken);
            $this->parseAndSetReturnTypeDeclarationList($arrowFunction);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1022; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1022;

        $arrowFunction->arrowToken = $this->eat1(TokenKind::DoubleArrowToken);
        $arrowFunction->resultExpression = $this->parseExpression($arrowFunction);

        return $arrowFunction;
    }

    private function parseAnonymousFunctionUseClause($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1030; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1030; $anonymousFunctionUseClause = new AnonymousFunctionUseClause(); }
        $anonymousFunctionUseClause->parent = $parentNode;

        $anonymousFunctionUseClause->useKeyword = $this->eatOptional1(TokenKind::UseKeyword);
        if ($anonymousFunctionUseClause->useKeyword === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1024; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1024; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1025; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1025;
        $anonymousFunctionUseClause->openParen = $this->eat1(TokenKind::OpenParenToken);
        $anonymousFunctionUseClause->useVariableNameList = $this->parseDelimitedList(
            DelimitedList\UseVariableNameList::class,
            TokenKind::CommaToken,
            function ($token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1027; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1027; return $token->kind === TokenKind::AmpersandToken || \PhpFuzzer\FuzzingContext::traceBlock(1026, $token->kind === TokenKind::VariableName); }
            },
            function ($parentNode) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1028; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1028; $useVariableName = new UseVariableName(); }
                $useVariableName->parent = $parentNode;
                $useVariableName->byRef = $this->eatOptional1(TokenKind::AmpersandToken);
                $useVariableName->variableName = $this->eat1(TokenKind::VariableName);
                return $useVariableName;
            },
            $anonymousFunctionUseClause
        ) ?: (\PhpFuzzer\FuzzingContext::traceBlock(1029, new MissingToken(TokenKind::VariableName, $this->token->fullStart)));
        $anonymousFunctionUseClause->closeParen = $this->eat1(TokenKind::CloseParenToken);

        return $anonymousFunctionUseClause;
    }

    private function parseMatchExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1031; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1031; $matchExpression = new MatchExpression(); }
        $matchExpression->parent = $parentNode;
        $matchExpression->matchToken = $this->eat1(TokenKind::MatchKeyword);
        $matchExpression->openParen = $this->eat1(TokenKind::OpenParenToken);
        $matchExpression->expression = $this->parseExpression($matchExpression);
        $matchExpression->closeParen = $this->eat1(TokenKind::CloseParenToken);
        $matchExpression->openBrace = $this->eat1(TokenKind::OpenBraceToken);
        $matchExpression->arms = $this->parseDelimitedList(
            DelimitedList\MatchExpressionArmList::class,
            TokenKind::CommaToken,
            $this->isMatchConditionStartFn(),
            $this->parseMatchArmFn(),
            $matchExpression);
        $matchExpression->closeBrace = $this->eat1(TokenKind::CloseBraceToken);
        return $matchExpression;
    }

    private function isMatchConditionStartFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1034; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1034; return function ($token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1033; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1033; return $token->kind === TokenKind::DefaultKeyword ||
                \PhpFuzzer\FuzzingContext::traceBlock(1032, $this->isExpressionStart($token)); }
        }; }
    }

    private function parseMatchArmFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1036; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1036; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1035; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1035; $matchArm = new MatchArm(); }
            $matchArm->parent = $parentNode;
            $matchArmConditionList = $this->parseDelimitedList(
                DelimitedList\MatchArmConditionList::class,
                TokenKind::CommaToken,
                $this->isMatchConditionStartFn(),
                $this->parseMatchConditionFn(),
                $matchArm
            );
            $matchArmConditionList->parent = $matchArm;
            $matchArm->conditionList = $matchArmConditionList;
            $matchArm->arrowToken = $this->eat1(TokenKind::DoubleArrowToken);
            $matchArm->body = $this->parseExpression($matchArm);
            return $matchArm;
        }; }
    }

    private function parseMatchConditionFn() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1040; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1040; return function ($parentNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1039; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1039; if ($this->token->kind === TokenKind::DefaultKeyword) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1037; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1037; return $this->eat1(TokenKind::DefaultKeyword); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1038; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1038; }
            return $this->parseExpression($parentNode);
        }; }
    }

    private function parseCloneExpression($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1041; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1041; $cloneExpression = new CloneExpression(); }
        $cloneExpression->parent = $parentNode;

        $cloneExpression->cloneKeyword = $this->eat1(TokenKind::CloneKeyword);
        $cloneExpression->expression = $this->parseUnaryExpressionOrHigher($cloneExpression);

        return $cloneExpression;
    }

    private function eatSemicolonOrAbortStatement() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1044; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1044; if ($this->getCurrentToken()->kind !== TokenKind::ScriptSectionEndTag) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1042; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1042; return $this->eat1(TokenKind::SemicolonToken); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1043; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1043; }
        return null;
    }

    private function parseInlineHtml($parentNode) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1049; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1049; $inlineHtml = new InlineHtml(); }
        $inlineHtml->parent = $parentNode;
        $inlineHtml->scriptSectionEndTag = $this->eatOptional1(TokenKind::ScriptSectionEndTag);
        $inlineHtml->text = $this->eatOptional1(TokenKind::InlineHtml);
        $inlineHtml->scriptSectionStartTag = $this->eatOptional(TokenKind::ScriptSectionStartTag, TokenKind::ScriptSectionStartWithEchoTag);

        // This is the easiest way to represent `<?= "expr", "other" `
        if (($inlineHtml->scriptSectionStartTag->kind ?? \PhpFuzzer\FuzzingContext::traceBlock(1045, null)) === TokenKind::ScriptSectionStartWithEchoTag)  {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1047; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1047; $echoStatement = new ExpressionStatement(); }

            $echoExpression = new EchoExpression();
            $expressionList = $this->parseExpressionList($echoExpression) ?? (\PhpFuzzer\FuzzingContext::traceBlock(1046, new MissingToken(TokenKind::Expression, $this->token->fullStart)));
            $echoExpression->expressions = $expressionList;
            $echoExpression->parent = $echoStatement;

            $echoStatement->expression = $echoExpression;
            $echoStatement->semicolon = $this->eatSemicolonOrAbortStatement();
            $echoStatement->parent = $inlineHtml;
            // Deliberately leave echoKeyword as null instead of MissingToken

            $inlineHtml->echoStatement = $echoStatement;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1048; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1048;

        return $inlineHtml;
    }
}

class Associativity {
    const None = 0;
    const Left = 1;
    const Right = 2;
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

class TokenKind {
    const Unknown = 0;
    const EndOfFileToken = 1;

    const Name = 2;
    const VariableName = 3;

    const SkippedToken = 4;
    const MissingToken = 5;
    const QualifiedName = 6;


    const AbstractKeyword = 101;
    const AndKeyword = 102;
    const ArrayKeyword = 103;
    const AsKeyword = 104;
    const BreakKeyword = 105;
    const CallableKeyword = 106;
    const CaseKeyword = 107;
    const CatchKeyword = 108;
    const ClassKeyword = 109;
    const CloneKeyword = 110;
    const ConstKeyword = 111;
    const ContinueKeyword = 112;
    const DeclareKeyword = 113;
    const DefaultKeyword = 114;
    const DieKeyword = 115;
    const DoKeyword = 116;
    const EchoKeyword = 117;
    const ElseKeyword = 118;
    const ElseIfKeyword = 119;
    const EmptyKeyword = 120;
    const EndDeclareKeyword = 121;
    const EndForKeyword = 122;
    const EndForEachKeyword = 123;
    const EndIfKeyword = 124;
    const EndSwitchKeyword = 125;
    const EndWhileKeyword = 126;
    const EvalKeyword = 127;
    const ExitKeyword = 128;
    const ExtendsKeyword = 129;
    const FinalKeyword = 130;
    const FinallyKeyword = 131;
    const ForKeyword = 132;
    const ForeachKeyword = 133;
    const FunctionKeyword = 134;
    const GlobalKeyword = 135;
    const GotoKeyword = 136;
    const IfKeyword = 137;
    const ImplementsKeyword = 138;
    const IncludeKeyword = 139;
    const IncludeOnceKeyword = 140;
    const InstanceOfKeyword = 141;
    const InsteadOfKeyword = 142;
    const InterfaceKeyword = 143;
    const IsSetKeyword = 144;
    const ListKeyword = 145;
    const NamespaceKeyword = 146;
    const NewKeyword = 147;
    const OrKeyword = 148;
    const PrintKeyword = 149;
    const PrivateKeyword = 150;
    const ProtectedKeyword = 151;
    const PublicKeyword = 152;
    const RequireKeyword = 153;
    const RequireOnceKeyword = 154;
    const ReturnKeyword = 155;
    const StaticKeyword = 156;
    const SwitchKeyword = 157;
    const ThrowKeyword = 158;
    const TraitKeyword = 159;
    const TryKeyword = 160;
    const UnsetKeyword = 161;
    const UseKeyword = 162;
    const VarKeyword = 163;
    const WhileKeyword = 164;
    const XorKeyword = 165;
    const YieldKeyword = 166;
    const YieldFromKeyword = 167;
    const FnKeyword = 168;
    const MatchKeyword = 169;

    const OpenBracketToken = 201;
    const CloseBracketToken = 202;
    const OpenParenToken = 203;
    const CloseParenToken = 204;
    const OpenBraceToken = 205;
    const CloseBraceToken = 206;
    const DotToken = 207;
    const ArrowToken = 208;
    const PlusPlusToken = 209;
    const MinusMinusToken = 210;
    const AsteriskAsteriskToken = 211;
    const AsteriskToken = 212;
    const PlusToken = 213;
    const MinusToken = 214;
    const TildeToken = 215;
    const ExclamationToken = 216;
    const DollarToken = 217;
    const SlashToken = 218;
    const PercentToken = 220;
    const LessThanLessThanToken = 221;
    const GreaterThanGreaterThanToken = 222;
    const LessThanToken = 223;
    const GreaterThanToken = 224;
    const LessThanEqualsToken = 225;
    const GreaterThanEqualsToken = 226;
    const EqualsEqualsToken = 227;
    const EqualsEqualsEqualsToken = 228;
    const ExclamationEqualsToken = 229;
    const ExclamationEqualsEqualsToken = 230;
    const CaretToken = 231;
    const BarToken = 232;
    const AmpersandToken = 233;
    const AmpersandAmpersandToken = 234;
    const BarBarToken = 235;
    const ColonToken = 236;
    const SemicolonToken = 237;
    const EqualsToken = 238;
    const AsteriskAsteriskEqualsToken = 239;
    const AsteriskEqualsToken = 240;
    const SlashEqualsToken = 241;
    const PercentEqualsToken = 242;
    const PlusEqualsToken = 243;
    const MinusEqualsToken = 244;
    const DotEqualsToken = 245;
    const LessThanLessThanEqualsToken = 246;
    const GreaterThanGreaterThanEqualsToken = 247;
    const AmpersandEqualsToken = 248;
    const CaretEqualsToken = 249;
    const BarEqualsToken = 250;
    const CommaToken = 251;
    const QuestionQuestionToken = 252;
    const LessThanEqualsGreaterThanToken = 253;
    const DotDotDotToken = 254;
    const BackslashToken = 255;
    const ColonColonToken = 256;
    const DoubleArrowToken = 257; // TODO missing from spec
    const LessThanGreaterThanToken = 258; // TODO missing from spec
    const AtSymbolToken = 259;
    const BacktickToken = 260;
    const QuestionToken = 261;
    const QuestionQuestionEqualsToken = 262;
    const QuestionArrowToken = 263;
    const AttributeToken = 264;

    const DecimalLiteralToken = 301;
    const OctalLiteralToken = 302;
    const HexadecimalLiteralToken = 303;
    const BinaryLiteralToken = 304;
    const FloatingLiteralToken = 305;
    const InvalidOctalLiteralToken = 306;
    const InvalidHexadecimalLiteral = 307;
    const InvalidBinaryLiteral = 308;
    const StringLiteralToken = 309;

    // RESERVED WORDS
    const IntReservedWord = 317;
    const FloatReservedWord = 318;
    const TrueReservedWord = 319;
    const StringReservedWord = 320;
    const BoolReservedWord = 321;
    const NullReservedWord = 322;

    const ScriptSectionStartTag = 323;
    const ScriptSectionEndTag = 324;
    const ScriptSectionStartWithEchoTag = 419;

    // TODO how to handle incremental parsing w/ this?
    const ScriptSectionPrependedText = 325;
    const VoidReservedWord = 326;
    const FalseReservedWord = 327;

    const MemberName = 328;
    const Expression = 329;

    const BinaryReservedWord = 330; // TODO better way
    const BooleanReservedWord = 331;
    const DoubleReservedWord = 332;
    const IntegerReservedWord = 333;
    const ObjectReservedWord = 334;
    const RealReservedWord = 335;
    const ReturnType = 336;
    const InlineHtml = 337;
    const PropertyType = 338;

//    const DollarOpenCurly = 339;
    const EncapsedAndWhitespace = 400;
    const SingleQuoteToken = 401;
    const DoubleQuoteToken = 402;
    const DollarOpenBraceToken = 403;
    const OpenBraceDollarToken = 404;
    const CastToken = 405;
    const HeredocStart = 406;
    const HeredocEnd = 407;
    const StringVarname = 408;
    const UnsetCastToken = 409;
    const StringCastToken = 410;
    const ObjectCastToken = 411;
    const IntCastToken = 412;
    const DoubleCastToken = 413;
    const BoolCastToken = 414;
    const ArrayCastToken = 415;
    const IntegerLiteralToken = 416;
    const CommentToken = 417;
    const DocCommentToken = 418;

    // TODO type annotations - PHP7
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

use Microsoft\PhpParser\TokenKind;

class TokenStringMaps {
    const KEYWORDS = array(
        "abstract" => TokenKind::AbstractKeyword,
        "and" => TokenKind::AndKeyword,
        "array" => TokenKind::ArrayKeyword,
        "as" => TokenKind::AsKeyword,
        "break" => TokenKind::BreakKeyword,
        "callable" => TokenKind::CallableKeyword,
        "case" => TokenKind::CaseKeyword,
        "catch" => TokenKind::CatchKeyword,
        "class" => TokenKind::ClassKeyword,
        "clone" => TokenKind::CloneKeyword,
        "const" => TokenKind::ConstKeyword,
        "continue" => TokenKind::ContinueKeyword,
        "declare" => TokenKind::DeclareKeyword,
        "default" => TokenKind::DefaultKeyword,
        "die" => TokenKind::DieKeyword,
        "do" => TokenKind::DoKeyword,
        "echo" => TokenKind::EchoKeyword,
        "else" => TokenKind::ElseKeyword,
        "elseif" => TokenKind::ElseIfKeyword,
        "empty" => TokenKind::EmptyKeyword,
        "enddeclare" => TokenKind::EndDeclareKeyword,
        "endfor" => TokenKind::EndForKeyword,
        "endforeach" => TokenKind::EndForEachKeyword,
        "endif" => TokenKind::EndIfKeyword,
        "endswitch" => TokenKind::EndSwitchKeyword,
        "endwhile" => TokenKind::EndWhileKeyword,
        "eval" => TokenKind::EvalKeyword,
        "exit" => TokenKind::ExitKeyword,
        "extends" => TokenKind::ExtendsKeyword,
        "final" => TokenKind::FinalKeyword,
        "finally" => TokenKind::FinallyKeyword,
        "for" => TokenKind::ForKeyword,
        "foreach" => TokenKind::ForeachKeyword,
        "fn" => TokenKind::FnKeyword,
        "function" => TokenKind::FunctionKeyword,
        "global" => TokenKind::GlobalKeyword,
        "goto" => TokenKind::GotoKeyword,
        "if" => TokenKind::IfKeyword,
        "implements" => TokenKind::ImplementsKeyword,
        "include" => TokenKind::IncludeKeyword,
        "include_once" => TokenKind::IncludeOnceKeyword,
        "instanceof" => TokenKind::InstanceOfKeyword,
        "insteadof" => TokenKind::InsteadOfKeyword,
        "interface" => TokenKind::InterfaceKeyword,
        "isset" => TokenKind::IsSetKeyword,
        "list" => TokenKind::ListKeyword,
        "namespace" => TokenKind::NamespaceKeyword,
        "new" => TokenKind::NewKeyword,
        "or" => TokenKind::OrKeyword,
        "print" => TokenKind::PrintKeyword,
        "private" => TokenKind::PrivateKeyword,
        "protected" => TokenKind::ProtectedKeyword,
        "public" => TokenKind::PublicKeyword,
        "require" => TokenKind::RequireKeyword,
        "require_once" => TokenKind::RequireOnceKeyword,
        "return" => TokenKind::ReturnKeyword,
        "static" => TokenKind::StaticKeyword,
        "switch" => TokenKind::SwitchKeyword,
        "throw" => TokenKind::ThrowKeyword,
        "trait" => TokenKind::TraitKeyword,
        "try" => TokenKind::TryKeyword,
        "unset" => TokenKind::UnsetKeyword,
        "use" => TokenKind::UseKeyword,
        "var" => TokenKind::VarKeyword,
        "while" => TokenKind::WhileKeyword,
        "xor" => TokenKind::XorKeyword,
        "yield" => TokenKind::YieldKeyword,
        "yield from" => TokenKind::YieldFromKeyword,


        // TODO soft reserved words?
    );

    const RESERVED_WORDS = [
        // http://php.net/manual/en/reserved.constants.php
        // TRUE, FALSE, NULL are special predefined constants
        // TODO - also consider adding other constants
        "true" => TokenKind::TrueReservedWord,
        "false" => TokenKind::FalseReservedWord,
        "null" => TokenKind::NullReservedWord,

        // RESERVED WORDS:
        // http://php.net/manual/en/reserved.other-reserved-words.php
        "int" => TokenKind::IntReservedWord,
        "float" => TokenKind::FloatReservedWord,
        "bool" => TokenKind::BoolReservedWord,
        "string" => TokenKind::StringReservedWord,
        "binary" => TokenKind::BinaryReservedWord,
        "boolean" => TokenKind::BooleanReservedWord,
        "double" => TokenKind::DoubleReservedWord,
        "integer" => TokenKind::IntegerReservedWord,
        "object" => TokenKind::ObjectReservedWord,
        "real" => TokenKind::RealReservedWord,
        "void" => TokenKind::VoidReservedWord
    ];

    const OPERATORS_AND_PUNCTUATORS = array(
        "[" => TokenKind::OpenBracketToken,
        "]" => TokenKind::CloseBracketToken,
        "(" => TokenKind::OpenParenToken,
        ")" => TokenKind::CloseParenToken,
        "{" => TokenKind::OpenBraceToken,
        "}" => TokenKind::CloseBraceToken,
        "." => TokenKind::DotToken,
        "->" => TokenKind::ArrowToken,
        "=>" => TokenKind::DoubleArrowToken,
        "++" => TokenKind::PlusPlusToken,
        "--" => TokenKind::MinusMinusToken,
        "**" => TokenKind::AsteriskAsteriskToken,
        "*" => TokenKind::AsteriskToken,
        "+" => TokenKind::PlusToken,
        "-" => TokenKind::MinusToken,
        "~" => TokenKind::TildeToken,
        "!" => TokenKind::ExclamationToken,
        "$" => TokenKind::DollarToken,
        "/" => TokenKind::SlashToken,
        "%" => TokenKind::PercentToken,
        "<<" => TokenKind::LessThanLessThanToken,
        ">>" => TokenKind::GreaterThanGreaterThanToken,
        "<" => TokenKind::LessThanToken,
        ">" => TokenKind::GreaterThanToken,
        "<=" => TokenKind::LessThanEqualsToken,
        ">=" => TokenKind::GreaterThanEqualsToken,
        "==" => TokenKind::EqualsEqualsToken,
        "===" => TokenKind::EqualsEqualsEqualsToken,
        "!=" => TokenKind::ExclamationEqualsToken,
        "!==" => TokenKind::ExclamationEqualsEqualsToken,
        "^" => TokenKind::CaretToken,
        "|" => TokenKind::BarToken,
        "&" => TokenKind::AmpersandToken,
        "&&" => TokenKind::AmpersandAmpersandToken,
        "||" => TokenKind::BarBarToken,
        "?" => TokenKind::QuestionToken,
        ":" => TokenKind::ColonToken,
        "::" => TokenKind::ColonColonToken,
        ";" => TokenKind::SemicolonToken,
        "=" => TokenKind::EqualsToken,
        "**=" => TokenKind::AsteriskAsteriskEqualsToken,
        "*=" => TokenKind::AsteriskEqualsToken,
        "/=" => TokenKind::SlashEqualsToken,
        "%=" => TokenKind::PercentEqualsToken,
        "+=" => TokenKind::PlusEqualsToken,
        "-=" => TokenKind::MinusEqualsToken,
        ".=" => TokenKind::DotEqualsToken,
        "<<=" => TokenKind::LessThanLessThanEqualsToken,
        ">>=" => TokenKind::GreaterThanGreaterThanEqualsToken,
        "&=" => TokenKind::AmpersandEqualsToken,
        "^=" => TokenKind::CaretEqualsToken,
        "|=" => TokenKind::BarEqualsToken,
        "," => TokenKind::CommaToken,
        "?->" => TokenKind::QuestionArrowToken,
        "??" => TokenKind::QuestionQuestionToken,
        "??=" => TokenKind::QuestionQuestionEqualsToken,
        "<=>" => TokenKind::LessThanEqualsGreaterThanToken,
        "<>" => TokenKind::LessThanGreaterThanToken,
        "..." => TokenKind::DotDotDotToken,
        "\\" => TokenKind::BackslashToken,
        "<?=" => TokenKind::ScriptSectionStartWithEchoTag, // TODO, technically not an operator
        "<?php " => TokenKind::ScriptSectionStartTag, // TODO, technically not an operator
        "<?php\t" => TokenKind::ScriptSectionStartTag, // TODO add tests
        "<?php\n" => TokenKind::ScriptSectionStartTag,
        "<?php\r" => TokenKind::ScriptSectionStartTag,
        "<?php\r\n" => TokenKind::ScriptSectionStartTag,
        "?>" => TokenKind::ScriptSectionEndTag, // TODO, technically not an operator
        "?>\n" => TokenKind::ScriptSectionEndTag, // TODO, technically not an operator
        "?>\r\n" => TokenKind::ScriptSectionEndTag, // TODO, technically not an operator
        "?>\r" => TokenKind::ScriptSectionEndTag, // TODO, technically not an operator
        "@" => TokenKind::AtSymbolToken, // TODO not in spec
        "`" => TokenKind::BacktickToken
    );

// TODO add new tokens
}
<?php
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

class TokenStreamProviderFactory {
    public static function GetTokenStreamProvider($content) {
        //    return new Lexer($content);
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1050; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1050; return new PhpTokenizer($content); }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

// If this predates PHP 7.4, T_COALESCE_EQUAL and T_FN are unavailable.
// The replacement value is arbitrary - it just has to be different from other values of token constants.
define(__NAMESPACE__ . '\T_COALESCE_EQUAL', defined('T_COALESCE_EQUAL') ? constant('T_COALESCE_EQUAL') : \PhpFuzzer\FuzzingContext::traceBlock(1051, 'T_COALESCE_EQUAL'));
define(__NAMESPACE__ . '\T_FN', defined('T_FN') ? constant('T_FN') : \PhpFuzzer\FuzzingContext::traceBlock(1052, 'T_FN'));
// If this predates PHP 8.0, T_MATCH is unavailable. The replacement value is arbitrary - it just has to be different from other values of token constants.
define(__NAMESPACE__ . '\T_MATCH', defined('T_MATCH') ? constant('T_MATCH') : \PhpFuzzer\FuzzingContext::traceBlock(1053, 'T_MATCH'));
define(__NAMESPACE__ . '\T_NULLSAFE_OBJECT_OPERATOR', defined('T_NULLSAFE_OBJECT_OPERATOR') ? constant('T_NULLSAFE_OBJECT_OPERATOR') : \PhpFuzzer\FuzzingContext::traceBlock(1054, 'T_MATCH'));
define(__NAMESPACE__ . '\T_ATTRIBUTE', defined('T_ATTRIBUTE') ? constant('T_ATTRIBUTE') : \PhpFuzzer\FuzzingContext::traceBlock(1055, 'T_ATTRIBUTE'));

/**
 * Tokenizes content using PHP's built-in `token_get_all`, and converts to "lightweight" Token representation.
 *
 * Initially we tried hand-spinning the lexer (see `experiments/Lexer.php`), but we had difficulties optimizing
 * performance (especially when working with Unicode characters.)
 *
 * Class PhpTokenizer
 * @package Microsoft\PhpParser
 */
class PhpTokenizer implements TokenStreamProviderInterface {
    public $pos;
    public $endOfFilePos;

    private $tokensArray;

    public function __construct($content) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1056; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1056; $this->tokensArray = $this->getTokensArrayFromContent($content); }
        $this->endOfFilePos = \count($this->tokensArray) - 1;
        $this->pos = 0;
    }

    public function scanNextToken() : Token {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1058; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1058; return $this->pos >= $this->endOfFilePos
            ? $this->tokensArray[$this->endOfFilePos]
            : \PhpFuzzer\FuzzingContext::traceBlock(1057, $this->tokensArray[$this->pos++]); }
    }

    public function getCurrentPosition() : int {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1059; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1059; return $this->pos; }
    }

    public function setCurrentPosition(int $pos) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1060; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1060; $this->pos = $pos; }
    }

    public function getEndOfFilePosition() : int {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1061; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1061; return $this->endOfFilePos; }
    }

    public function getTokensArray() : array {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1062; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1062; return $this->tokensArray; }
    }

    /**
     * Return an array of Token object instances created from $content.
     *
     * This method is optimized heavily - this processes every single token being created.
     *
     * @param string $content the raw php code
     * @param ?int $parseContext can be SourceElements when extracting doc comments
     * @param int $initialPos
     * @param bool $treatCommentsAsTrivia
     * @return Token[]
     */
    public static function getTokensArrayFromContent(
        $content, $parseContext = null, $initialPos = 0, $treatCommentsAsTrivia = true
    ) : array {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1107; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1107; if ($parseContext !== null) {
            // If needed, add a prefix so that token_get_all will tokenize the remaining $contents
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1063; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1063; $prefix = self::PARSE_CONTEXT_TO_PREFIX[$parseContext]; }
            $content = $prefix . $content;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1064; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1064; }

        $tokens = static::tokenGetAll($content, $parseContext);

        $arr = array();
        $fullStart = $start = $pos = $initialPos;
        if ($parseContext !== null) {
            // If needed, skip over the prefix we added for token_get_all and remove those tokens.
            // This was moved out of the below main loop as an optimization.
            // (the common case of parsing an entire file uses a null parseContext)
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1072; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1072; foreach ($tokens as $i => $token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1070; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1070; unset($tokens[$i]); }
                if (\is_array($token)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1066; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1066; $pos += \strlen($token[1]); }
                } else {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1065; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1065; $pos += \strlen($token); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1067; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1067;
                if (\strlen($prefix) < $pos) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1068; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1068; $fullStart = $start = $pos = $initialPos; }
                    break;
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1069; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1069;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1071; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1071; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1073; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1073;

        // Convert tokens from token_get_all to Token instances,
        // skipping whitespace and (usually, when parseContext is null) comments.
        foreach ($tokens as $token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1105; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1105; if (\is_array($token)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1076; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1076; $tokenKind = $token[0]; }
                $strlen = \strlen($token[1]);
            } else {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1075; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1075; $pos += \strlen($token); }
                $newTokenKind = self::TOKEN_MAP[$token] ?? \PhpFuzzer\FuzzingContext::traceBlock(1074, TokenKind::Unknown);
                $arr[] = new Token($newTokenKind, $fullStart, $start, $pos - $fullStart);
                $start = $fullStart = $pos;
                continue;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1077; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1077; }

            $pos += $strlen;

            // Optimization note: In PHP < 7.2, the switch statement would check case by case,
            // so putting the most common cases first is slightly faster
            switch ($tokenKind) {
                case \T_WHITESPACE:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1078; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1078; $start += $strlen; }
                    break;
                case \T_STRING:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1080; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1080; $name = \strtolower($token[1]); }
                    $newTokenKind = TokenStringMaps::RESERVED_WORDS[$name] ?? \PhpFuzzer\FuzzingContext::traceBlock(1079, TokenKind::Name);
                    $arr[] = new Token($newTokenKind, $fullStart, $start, $pos - $fullStart);
                    $start = $fullStart = $pos;
                    break;
                case \T_OPEN_TAG:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1081; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1081; $arr[] = new Token(TokenKind::ScriptSectionStartTag, $fullStart, $start, $pos-$fullStart); }
                    $start = $fullStart = $pos;
                    break;
                case \PHP_VERSION_ID >= 80000 ? \T_NAME_QUALIFIED : \PhpFuzzer\FuzzingContext::traceBlock(1082, -1000): $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1083; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1083;
                case \PHP_VERSION_ID >= 80000 ? \T_NAME_FULLY_QUALIFIED : \PhpFuzzer\FuzzingContext::traceBlock(1084, -1001):
                    // NOTE: This switch is called on every token of every file being parsed, so this traded performance for readability.
                    //
                    // PHP's Opcache is able to optimize switches that are exclusively known longs,
                    // but not switches that mix strings and longs or have unknown longs.
                    // Longs are only known if they're declared within the same *class* or an internal constant (tokenizer).
                    //
                    // For some reason, the SWITCH_LONG opcode was not generated when the expression was part of a class constant.
                    // (seen with php -d opcache.opt_debug_level=0x20000)
                    //
                    // Use negative values because that's not expected to overlap with token kinds that token_get_all() will return.
                    //
                    // T_NAME_* was added in php 8.0 to forbid whitespace between parts of names.
                    // Here, emulate the tokenization of php 7 by splitting it up into 1 or more tokens.
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1091; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1091; foreach (\explode('\\', $token[1]) as $i => $name) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1089; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1089; if ($i) {
                            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1085; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1085; $arr[] = new Token(TokenKind::BackslashToken, $fullStart, $start, 1 + $start - $fullStart); }
                            $start++;
                            $fullStart = $start;
                        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1086; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1086; }
                        if ($name === '') {
                            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1087; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1087; continue; }
                        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1088; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1088;
                        // TODO: TokenStringMaps::RESERVED_WORDS[$name] ?? TokenKind::Name for compatibility?
                        $len = \strlen($name);
                        $arr[] = new Token(TokenKind::Name, $fullStart, $start, $len + $start - $fullStart);
                        $start += $len;
                        $fullStart = $start;
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1090; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1090; }
                    break;
                case \PHP_VERSION_ID >= 80000 ? \T_NAME_RELATIVE : \PhpFuzzer\FuzzingContext::traceBlock(1092, -1002):
                    // This is a namespace-relative name: namespace\...
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1097; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1097; foreach (\explode('\\', $token[1]) as $i => $name) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1095; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1095; $len = \strlen($name); }
                        if (!$i) {
                            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1093; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1093; $arr[] = new Token(TokenKind::NamespaceKeyword, $fullStart, $start, $len + $start - $fullStart); }
                            $start += $len;
                            $fullStart = $start;
                            continue;
                        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1094; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1094;
                        $arr[] = new Token(TokenKind::BackslashToken, $fullStart, $start, 1);
                        $start++;

                        // TODO: TokenStringMaps::RESERVED_WORDS[$name] ?? TokenKind::Name for compatibility?
                        $arr[] = new Token(TokenKind::Name, $start, $start, $len);

                        $start += $len;
                        $fullStart = $start;
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1096; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1096; }
                    break;
                case \T_COMMENT: $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1098; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1098;
                case \T_DOC_COMMENT:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1101; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1101; if ($treatCommentsAsTrivia) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1099; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1099; $start += $strlen; }
                        break;
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1100; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1100; }
                    // fall through
                default:
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1103; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1103; $newTokenKind = self::TOKEN_MAP[$tokenKind] ?? \PhpFuzzer\FuzzingContext::traceBlock(1102, TokenKind::Unknown); }
                    $arr[] = new Token($newTokenKind, $fullStart, $start, $pos - $fullStart);
                    $start = $fullStart = $pos;
                    break;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1104; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1104;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1106; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1106;

        $arr[] = new Token(TokenKind::EndOfFileToken, $fullStart, $start, $pos - $fullStart);
        return $arr;
    }

    /**
     * @param string $content the raw php code
     * @param ?int $parseContext can be SourceElements when extracting doc comments.
     *                           Having this available may be useful for subclasses to decide whether or not to post-process results, cache results, etc.
     * @return array[]|string[] an array of tokens. When concatenated, these tokens must equal $content.
     *
     * This exists so that it can be overridden in subclasses, e.g. to cache the result of tokenizing entire files.
     * Applications using tolerant-php-parser may often end up needing to use the token stream for other reasons that are hard to do in the resulting AST,
     * such as iterating over T_COMMENTS, checking for inline html,
     * looking up all tokens (including skipped tokens) on a given line, etc.
     */
    protected static function tokenGetAll(string $content, $parseContext): array
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1108; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1108; return @\token_get_all($content); }
    }

    const TOKEN_MAP = [
        T_CLASS_C => TokenKind::Name,
        T_DIR => TokenKind::Name,
        T_FILE => TokenKind::Name,
        T_FUNC_C => TokenKind::Name,
        T_HALT_COMPILER => TokenKind::Name,
        T_METHOD_C => TokenKind::Name,
        T_NS_C => TokenKind::Name,
        T_TRAIT_C => TokenKind::Name,
        T_LINE => TokenKind::Name,

        T_STRING => TokenKind::Name,
        T_VARIABLE => TokenKind::VariableName,

        T_ABSTRACT => TokenKind::AbstractKeyword,
        T_LOGICAL_AND => TokenKind::AndKeyword,
        T_ARRAY => TokenKind::ArrayKeyword,
        T_AS => TokenKind::AsKeyword,
        T_BREAK => TokenKind::BreakKeyword,
        T_CALLABLE => TokenKind::CallableKeyword,
        T_CASE => TokenKind::CaseKeyword,
        T_CATCH => TokenKind::CatchKeyword,
        T_CLASS => TokenKind::ClassKeyword,
        T_CLONE => TokenKind::CloneKeyword,
        T_CONST => TokenKind::ConstKeyword,
        T_CONTINUE => TokenKind::ContinueKeyword,
        T_DECLARE => TokenKind::DeclareKeyword,
        T_DEFAULT => TokenKind::DefaultKeyword,
        T_DO => TokenKind::DoKeyword,
        T_ECHO => TokenKind::EchoKeyword,
        T_ELSE => TokenKind::ElseKeyword,
        T_ELSEIF => TokenKind::ElseIfKeyword,
        T_EMPTY => TokenKind::EmptyKeyword,
        T_ENDDECLARE => TokenKind::EndDeclareKeyword,
        T_ENDFOR => TokenKind::EndForKeyword,
        T_ENDFOREACH => TokenKind::EndForEachKeyword,
        T_ENDIF => TokenKind::EndIfKeyword,
        T_ENDSWITCH => TokenKind::EndSwitchKeyword,
        T_ENDWHILE => TokenKind::EndWhileKeyword,
        T_EVAL => TokenKind::EvalKeyword,
        T_EXIT => TokenKind::ExitKeyword,
        T_EXTENDS => TokenKind::ExtendsKeyword,
        T_FINAL => TokenKind::FinalKeyword,
        T_FINALLY => TokenKind::FinallyKeyword,
        T_FOR => TokenKind::ForKeyword,
        T_FOREACH => TokenKind::ForeachKeyword,
        T_FN => TokenKind::FnKeyword,
        T_FUNCTION => TokenKind::FunctionKeyword,
        T_GLOBAL => TokenKind::GlobalKeyword,
        T_GOTO => TokenKind::GotoKeyword,
        T_IF => TokenKind::IfKeyword,
        T_IMPLEMENTS => TokenKind::ImplementsKeyword,
        T_INCLUDE => TokenKind::IncludeKeyword,
        T_INCLUDE_ONCE => TokenKind::IncludeOnceKeyword,
        T_INSTANCEOF => TokenKind::InstanceOfKeyword,
        T_INSTEADOF => TokenKind::InsteadOfKeyword,
        T_INTERFACE => TokenKind::InterfaceKeyword,
        T_ISSET => TokenKind::IsSetKeyword,
        T_LIST => TokenKind::ListKeyword,
        T_MATCH => TokenKind::MatchKeyword,
        T_NAMESPACE => TokenKind::NamespaceKeyword,
        T_NEW => TokenKind::NewKeyword,
        T_LOGICAL_OR => TokenKind::OrKeyword,
        T_PRINT => TokenKind::PrintKeyword,
        T_PRIVATE => TokenKind::PrivateKeyword,
        T_PROTECTED => TokenKind::ProtectedKeyword,
        T_PUBLIC => TokenKind::PublicKeyword,
        T_REQUIRE => TokenKind::RequireKeyword,
        T_REQUIRE_ONCE => TokenKind::RequireOnceKeyword,
        T_RETURN => TokenKind::ReturnKeyword,
        T_STATIC => TokenKind::StaticKeyword,
        T_SWITCH => TokenKind::SwitchKeyword,
        T_THROW => TokenKind::ThrowKeyword,
        T_TRAIT => TokenKind::TraitKeyword,
        T_TRY => TokenKind::TryKeyword,
        T_UNSET => TokenKind::UnsetKeyword,
        T_USE => TokenKind::UseKeyword,
        T_VAR => TokenKind::VarKeyword,
        T_WHILE => TokenKind::WhileKeyword,
        T_LOGICAL_XOR => TokenKind::XorKeyword,
        T_YIELD => TokenKind::YieldKeyword,
        T_YIELD_FROM => TokenKind::YieldFromKeyword,

        "[" => TokenKind::OpenBracketToken,
        "]" => TokenKind::CloseBracketToken,
        "(" => TokenKind::OpenParenToken,
        ")" => TokenKind::CloseParenToken,
        "{" => TokenKind::OpenBraceToken,
        "}" => TokenKind::CloseBraceToken,
        "." => TokenKind::DotToken,
        T_OBJECT_OPERATOR => TokenKind::ArrowToken,
        T_NULLSAFE_OBJECT_OPERATOR => TokenKind::QuestionArrowToken,
        T_ATTRIBUTE => TokenKind::AttributeToken,
        T_INC => TokenKind::PlusPlusToken,
        T_DEC => TokenKind::MinusMinusToken,
        T_POW => TokenKind::AsteriskAsteriskToken,
        "*" => TokenKind::AsteriskToken,
        "+" => TokenKind::PlusToken,
        "-" => TokenKind::MinusToken,
        "~" => TokenKind::TildeToken,
        "!" => TokenKind::ExclamationToken,
        "$" => TokenKind::DollarToken,
        "/" => TokenKind::SlashToken,
        "%" => TokenKind::PercentToken,
        T_SL => TokenKind::LessThanLessThanToken,
        T_SR => TokenKind::GreaterThanGreaterThanToken,
        "<" => TokenKind::LessThanToken,
        ">" => TokenKind::GreaterThanToken,
        T_IS_SMALLER_OR_EQUAL => TokenKind::LessThanEqualsToken,
        T_IS_GREATER_OR_EQUAL => TokenKind::GreaterThanEqualsToken,
        T_IS_EQUAL => TokenKind::EqualsEqualsToken,
        T_IS_IDENTICAL => TokenKind::EqualsEqualsEqualsToken,
        T_IS_NOT_EQUAL => TokenKind::ExclamationEqualsToken,
        T_IS_NOT_IDENTICAL => TokenKind::ExclamationEqualsEqualsToken,
        "^" => TokenKind::CaretToken,
        "|" => TokenKind::BarToken,
        "&" => TokenKind::AmpersandToken,
        T_BOOLEAN_AND => TokenKind::AmpersandAmpersandToken,
        T_BOOLEAN_OR => TokenKind::BarBarToken,
        ":" => TokenKind::ColonToken,
        ";" => TokenKind::SemicolonToken,
        "=" => TokenKind::EqualsToken,
        T_POW_EQUAL => TokenKind::AsteriskAsteriskEqualsToken,
        T_MUL_EQUAL => TokenKind::AsteriskEqualsToken,
        T_DIV_EQUAL => TokenKind::SlashEqualsToken,
        T_MOD_EQUAL => TokenKind::PercentEqualsToken,
        T_PLUS_EQUAL => TokenKind::PlusEqualsToken,
        T_MINUS_EQUAL => TokenKind::MinusEqualsToken,
        T_CONCAT_EQUAL => TokenKind::DotEqualsToken,
        T_SL_EQUAL => TokenKind::LessThanLessThanEqualsToken,
        T_SR_EQUAL => TokenKind::GreaterThanGreaterThanEqualsToken,
        T_AND_EQUAL => TokenKind::AmpersandEqualsToken,
        T_XOR_EQUAL => TokenKind::CaretEqualsToken,
        T_OR_EQUAL => TokenKind::BarEqualsToken,
        "," => TokenKind::CommaToken,
        namespace\T_COALESCE_EQUAL => TokenKind::QuestionQuestionEqualsToken,
        T_COALESCE => TokenKind::QuestionQuestionToken,
        T_SPACESHIP => TokenKind::LessThanEqualsGreaterThanToken,
        T_ELLIPSIS => TokenKind::DotDotDotToken,
        T_NS_SEPARATOR => TokenKind::BackslashToken,
        T_PAAMAYIM_NEKUDOTAYIM => TokenKind::ColonColonToken,
        T_DOUBLE_ARROW => TokenKind::DoubleArrowToken, // TODO missing from spec

        "@" => TokenKind::AtSymbolToken,
        "`" => TokenKind::BacktickToken,
        "?" => TokenKind::QuestionToken,

        T_LNUMBER => TokenKind::IntegerLiteralToken,

        T_DNUMBER => TokenKind::FloatingLiteralToken,

        T_OPEN_TAG => TokenKind::ScriptSectionStartTag,
        T_OPEN_TAG_WITH_ECHO => TokenKind::ScriptSectionStartWithEchoTag,
        T_CLOSE_TAG => TokenKind::ScriptSectionEndTag,

        T_INLINE_HTML => TokenKind::InlineHtml,

        "\"" => TokenKind::DoubleQuoteToken,
        "'" => TokenKind::SingleQuoteToken,
        T_ENCAPSED_AND_WHITESPACE => TokenKind::EncapsedAndWhitespace,
        T_DOLLAR_OPEN_CURLY_BRACES => TokenKind::DollarOpenBraceToken,
        T_CURLY_OPEN => TokenKind::OpenBraceDollarToken,
        T_CONSTANT_ENCAPSED_STRING => TokenKind::StringLiteralToken,

        T_ARRAY_CAST        => TokenKind::ArrayCastToken,
        T_BOOL_CAST         => TokenKind::BoolCastToken,
        T_DOUBLE_CAST       => TokenKind::DoubleCastToken,
        T_INT_CAST          => TokenKind::IntCastToken,
        T_OBJECT_CAST       => TokenKind::ObjectCastToken,
        T_STRING_CAST       => TokenKind::StringCastToken,
        T_UNSET_CAST        => TokenKind::UnsetCastToken,

        T_START_HEREDOC     => TokenKind::HeredocStart,
        T_END_HEREDOC       => TokenKind::HeredocEnd,
        T_STRING_VARNAME    => TokenKind::StringVarname,
        T_COMMENT           => TokenKind::CommentToken,
        T_DOC_COMMENT       => TokenKind::DocCommentToken,
        T_NUM_STRING        => TokenKind::IntegerLiteralToken
    ];

    const PARSE_CONTEXT_TO_PREFIX = [
        ParseContext::SourceElements => "<?php "
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

interface TokenStreamProviderInterface {
    public function scanNextToken() : Token;

    public function getCurrentPosition() : int;

    public function setCurrentPosition(int $pos);

    public function getEndOfFilePosition() : int;

    public function getTokensArray() : array;
}
<?php
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

class ParseContext {
    const SourceElements = 0;
    const BlockStatements = 1;
    const ClassMembers = 2;
    const IfClause2Elements = 3;
    const SwitchStatementElements = 4;
    const CaseStatementElements = 5;
    const WhileStatementElements = 6;
    const ForStatementElements = 7;
    const ForeachStatementElements = 8;
    const DeclareStatementElements = 9;
    const InterfaceMembers = 10;
    const TraitMembers = 11;
    const Count = 12;
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

use function substr;

class Token implements \JsonSerializable {
    // TODO optimize memory - ideally this would be a struct of 4 ints
    /** @var int */
    public $kind;
    /** @var int */
    public $fullStart;
    /** @var int */
    public $start;
    /** @var int */
    public $length;

    /**
     * @param int $kind
     * @param int $fullStart
     * @param int $start
     * @param int $length
     */
    public function __construct($kind, $fullStart, $start, $length) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1109; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1109; $this->kind = $kind; }
        $this->fullStart = $fullStart;
        $this->start = $start;
        $this->length = $length;
    }

    public function getLeadingCommentsAndWhitespaceText(string $document) : string {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1110; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1110; return substr($document, $this->fullStart, $this->start - $this->fullStart); }
    }

    /**
     * @param string|null $document
     * @return bool|null|string
     */
    public function getText(string $document = null) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1113; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1113; if ($document === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1111; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1111; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1112; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1112; }
        return substr($document, $this->start, $this->length - ($this->start - $this->fullStart));
    }

    public function getFullText(string $document) : string {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1114; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1114; return substr($document, $this->fullStart, $this->length); }
    }

    /**
     * @return int
     */
    public function getStartPosition() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1115; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1115; return $this->start; }
    }

    /**
     * @return int
     */
    public function getFullStart() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1116; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1116; return $this->fullStart; }
    }

    /**
     * @return int
     */
    public function getWidth() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1117; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1117; return $this->length + $this->fullStart - $this->start; }
    }

    /**
     * @return int
     */
    public function getFullWidth() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1118; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1118; return $this->length; }
    }

    /**
     * @return int
     */
    public function getEndPosition() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1119; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1119; return $this->fullStart + $this->length; }
    }

    /**
     * @return string[] - A hash map of the format [int $tokenKind => string $tokenName]
     */
    private static function getTokenKindNameFromValueMap() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1122; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1122; static $mapToKindName; }
        if ($mapToKindName === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1120; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1120; $constants = (new \ReflectionClass("Microsoft\\PhpParser\\TokenKind"))->getConstants(); }
            $mapToKindName = \array_flip($constants);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1121; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1121;
        return $mapToKindName;
    }

    /**
     * Returns the token kind name as a string, or the token number if the name
     * was not found.
     *
     * @param int $kind
     * @return int|string
     */
    public static function getTokenKindNameFromValue($kind) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1124; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1124; $mapToKindName = self::getTokenKindNameFromValueMap(); }
        return $mapToKindName[$kind] ?? \PhpFuzzer\FuzzingContext::traceBlock(1123, $kind);
    }

    public function jsonSerialize() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1130; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1130; $kindName = $this->getTokenKindNameFromValue($this->kind); }

        if (!isset($GLOBALS["SHORT_TOKEN_SERIALIZE"])) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1125; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1125; $GLOBALS["SHORT_TOKEN_SERIALIZE"] = false; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1126; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1126;

        if ($GLOBALS["SHORT_TOKEN_SERIALIZE"]) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1128; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1128; return [
                "kind" => $kindName,
                "textLength" => $this->length - ($this->start - $this->fullStart)
            ]; }
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1127; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1127; return [
                "kind" => $kindName,
                "fullStart" => $this->fullStart,
                "start" => $this->start,
                "length" => $this->length
            ]; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1129; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1129;
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class SourceFileNode extends Node {
    /** @var string */
    public $fileContents;

    /** @var string */
    public $uri;

    /** @var Node[] */
    public $statementList;

    /** @var Token */
    public $endOfFileToken;

    const CHILD_NAMES = ['statementList', 'endOfFileToken'];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

use Microsoft\PhpParser\Node\NamespaceUseClause;
use Microsoft\PhpParser\Node\NamespaceUseGroupClause;
use Microsoft\PhpParser\Node\SourceFileNode;
use Microsoft\PhpParser\Node\Statement\NamespaceDefinition;
use Microsoft\PhpParser\Node\Statement\NamespaceUseDeclaration;

abstract class Node implements \JsonSerializable {
    const CHILD_NAMES = [];

    /** @var array[] Map from node class to array of child keys */
    private static $childNames = [];

    /** @var Node|null */
    public $parent;

    public function getNodeKindName() : string {
        // Use strrpos (rather than explode) to avoid creating a temporary array.
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1131; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1131; return substr(static::class, strrpos(static::class, "\\") + 1); }
    }

    /**
     * Gets start position of Node, not including leading comments and whitespace.
     * @return int
     * @throws \Exception
     */
    public function getStart() : int {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1135; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1135; $child = $this->getChildNodesAndTokens()->current(); }
        if ($child instanceof Node) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1133; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1133; return $child->getStart(); }
        } elseif ($child instanceof Token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1132; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1132; return $child->start; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1134; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1134;
        throw new \Exception("Unknown type in AST");
    }

    /**
     * Gets start position of Node, including leading comments and whitespace
     * @return int
     * @throws \Exception
     */
    public function getFullStart() : int {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1148; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1148; foreach($this::CHILD_NAMES as $name) {

            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1146; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1146; if (($child = $this->$name) !== null) {

                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1144; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1144; if (\is_array($child)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1138; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1138; if(!isset($child[0])) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1136; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1136; continue; }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1137; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1137; }
                    $child = $child[0];
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1139; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1139; }

                if ($child instanceof Node) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1140; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1140; return $child->getFullStart(); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1141; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1141;

                if ($child instanceof Token) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1142; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1142; return $child->fullStart; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1143; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1143;

                throw new \Exception("Unknown type in AST: " . \gettype($child));
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1145; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1145; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1147; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1147; };

        throw new \RuntimeException("Could not resolve full start position");
    }

    /**
     * Gets parent of current node (returns null if has no parent)
     * @return null|Node
     */
    public function getParent() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1149; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1149; return $this->parent; }
    }

    /**
     * Gets first ancestor that is an instance of one of the provided classes.
     * Returns null if there is no match.
     *
     * @param string ...$classNames
     * @return Node|null
     */
    public function getFirstAncestor(...$classNames) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1155; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1155; $ancestor = $this; }
        while (($ancestor = $ancestor->parent) !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1154; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1154; foreach ($classNames as $className) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1152; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1152; if ($ancestor instanceof $className) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1150; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1150; return $ancestor; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1151; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1151; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1153; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1153; }
        }
        return null;
    }

    /**
     * Gets first child that is an instance of one of the provided classes.
     * Returns null if there is no match.
     *
     * @param array ...$classNames
     * @return Node|null
     */
    public function getFirstChildNode(...$classNames) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1167; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1167; foreach ($this::CHILD_NAMES as $name) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1165; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1165; $val = $this->$name; }
            foreach ($classNames as $className) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1163; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1163; if (\is_array($val)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1161; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1161; foreach ($val as $child) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1158; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1158; if ($child instanceof $className) {
                            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1156; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1156; return $child; }
                        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1157; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1157; }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1159; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1159; }
                    continue;
                } elseif ($val instanceof $className) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1160; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1160; return $val; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1162; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1162; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1164; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1164;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1166; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1166; }
        return null;
    }

    /**
     * Gets first descendant node that is an instance of one of the provided classes.
     * Returns null if there is no match.
     *
     * @param array ...$classNames
     * @return Node|null
     */
    public function getFirstDescendantNode(...$classNames) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1174; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1174; foreach ($this->getDescendantNodes() as $descendant) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1172; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1172; foreach ($classNames as $className) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1170; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1170; if ($descendant instanceof $className) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1168; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1168; return $descendant; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1169; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1169; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1171; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1171; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1173; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1173; }
        return null;
    }

    /**
     * Gets root of the syntax tree (returns self if has no parents)
     * @return SourceFileNode (expect root to be SourceFileNode unless the tree was manipulated)
     */
    public function getRoot() : Node {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1176; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1176; $node = $this; }
        while ($node->parent !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1175; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1175; $node = $node->parent; }
        }
        return $node;
    }

    /**
     * Gets generator containing all descendant Nodes and Tokens.
     *
     * @param callable|null $shouldDescendIntoChildrenFn
     * @return \Generator|Node[]|Token[]
     */
    public function getDescendantNodesAndTokens(callable $shouldDescendIntoChildrenFn = null) {
        // TODO - write unit tests to prove invariants
        // (concatenating all descendant Tokens should produce document, concatenating all Nodes should produce document)
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1188; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1188; foreach ($this->getChildNodesAndTokens() as $child) {
            // Check possible types of $child, most frequent first
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1186; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1186; if ($child instanceof Node) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1184; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1184; \PhpFuzzer\FuzzingContext::traceBlock(1177, yield $child); }
                if ($shouldDescendIntoChildrenFn === null || \PhpFuzzer\FuzzingContext::traceBlock(1178, $shouldDescendIntoChildrenFn($child))) {
                   { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1180; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1180; \PhpFuzzer\FuzzingContext::traceBlock(1179, yield from $child->getDescendantNodesAndTokens($shouldDescendIntoChildrenFn)); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1181; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1181;
            } elseif ($child instanceof Token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1183; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1183; \PhpFuzzer\FuzzingContext::traceBlock(1182, yield $child); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1185; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1185; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1187; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1187; }
    }

    /**
     * Iterate over all descendant Nodes and Tokens, calling $callback.
     * This can often be faster than getDescendantNodesAndTokens
     * if you just need to call something and don't need a generator.
     *
     * @param callable $callback a callback that accepts Node|Token
     * @param callable|null $shouldDescendIntoChildrenFn
     * @return void
     */
    public function walkDescendantNodesAndTokens(callable $callback, callable $shouldDescendIntoChildrenFn = null) {
        // TODO - write unit tests to prove invariants
        // (concatenating all descendant Tokens should produce document, concatenating all Nodes should produce document)
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1206; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1206; foreach (static::CHILD_NAMES as $name) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1204; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1204; $child = $this->$name; }
            // Check possible types of $child, most frequent first
            if ($child instanceof Token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1202; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1202; $callback($child); }
            } elseif ($child instanceof Node) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1192; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1192; $callback($child); }
                if ($shouldDescendIntoChildrenFn === null || \PhpFuzzer\FuzzingContext::traceBlock(1189, $shouldDescendIntoChildrenFn($child))) {
                   { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1190; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1190; $child->walkDescendantNodesAndTokens($callback, $shouldDescendIntoChildrenFn); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1191; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1191;
            } elseif (\is_array($child)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1201; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1201; foreach ($child as $childElement) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1199; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1199; if ($childElement instanceof Token) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1197; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1197; $callback($childElement); }
                    } elseif ($childElement instanceof Node) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1196; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1196; $callback($childElement); }
                        if ($shouldDescendIntoChildrenFn === null || \PhpFuzzer\FuzzingContext::traceBlock(1193, $shouldDescendIntoChildrenFn($childElement))) {
                           { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1194; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1194; $childElement->walkDescendantNodesAndTokens($callback, $shouldDescendIntoChildrenFn); }
                        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1195; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1195;
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1198; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1198; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1200; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1200; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1203; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1203;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1205; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1205; }
    }

    /**
     * Gets a generator containing all descendant Nodes.
     * @param callable|null $shouldDescendIntoChildrenFn
     * @return \Generator|Node[]
     */
    public function getDescendantNodes(callable $shouldDescendIntoChildrenFn = null) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1214; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1214; foreach ($this->getChildNodes() as $child) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1212; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1212; \PhpFuzzer\FuzzingContext::traceBlock(1207, yield $child); }
            if ($shouldDescendIntoChildrenFn === null || \PhpFuzzer\FuzzingContext::traceBlock(1208, $shouldDescendIntoChildrenFn($child))) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1210; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1210; \PhpFuzzer\FuzzingContext::traceBlock(1209, yield from $child->getDescendantNodes($shouldDescendIntoChildrenFn)); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1211; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1211;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1213; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1213; }
    }

    /**
     * Gets generator containing all descendant Tokens.
     * @param callable|null $shouldDescendIntoChildrenFn
     * @return \Generator|Token[]
     */
    public function getDescendantTokens(callable $shouldDescendIntoChildrenFn = null) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1225; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1225; foreach ($this->getChildNodesAndTokens() as $child) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1223; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1223; if ($child instanceof Node) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1221; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1221; if ($shouldDescendIntoChildrenFn == null || \PhpFuzzer\FuzzingContext::traceBlock(1215, $shouldDescendIntoChildrenFn($child))) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1217; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1217; \PhpFuzzer\FuzzingContext::traceBlock(1216, yield from $child->getDescendantTokens($shouldDescendIntoChildrenFn)); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1218; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1218; }
            } elseif ($child instanceof Token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1220; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1220; \PhpFuzzer\FuzzingContext::traceBlock(1219, yield $child); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1222; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1222; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1224; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1224; }
    }

    /**
     * Gets generator containing all child Nodes and Tokens (direct descendants).
     * Does not return null elements.
     *
     * @return \Generator|Token[]|Node[]
     */
    public function getChildNodesAndTokens() : \Generator {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1238; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1238; foreach ($this::CHILD_NAMES as $name) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1236; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1236; $val = $this->$name; }

            if (\is_array($val)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1231; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1231; foreach ($val as $child) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1229; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1229; if ($child !== null) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1227; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1227; \PhpFuzzer\FuzzingContext::traceBlock(1226, yield $name => $child); }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1228; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1228; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1230; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1230; }
                continue;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1232; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1232;
            if ($val !== null) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1234; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1234; \PhpFuzzer\FuzzingContext::traceBlock(1233, yield $name => $val); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1235; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1235;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1237; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1237; }
    }

    /**
     * Gets generator containing all child Nodes (direct descendants)
     * @return \Generator|Node[]
     */
    public function getChildNodes() : \Generator {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1250; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1250; foreach ($this::CHILD_NAMES as $name) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1248; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1248; $val = $this->$name; }
            if (\is_array($val)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1246; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1246; foreach ($val as $child) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1242; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1242; if ($child instanceof Node) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1240; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1240; \PhpFuzzer\FuzzingContext::traceBlock(1239, yield $child); }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1241; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1241; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1243; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1243; }
                continue;
            } elseif ($val instanceof Node) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1245; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1245; \PhpFuzzer\FuzzingContext::traceBlock(1244, yield $val); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1247; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1247;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1249; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1249; }
    }

    /**
     * Gets generator containing all child Tokens (direct descendants)
     *
     * @return \Generator|Token[]
     */
    public function getChildTokens() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1262; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1262; foreach ($this::CHILD_NAMES as $name) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1260; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1260; $val = $this->$name; }
            if (\is_array($val)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1258; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1258; foreach ($val as $child) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1254; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1254; if ($child instanceof Token) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1252; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1252; \PhpFuzzer\FuzzingContext::traceBlock(1251, yield $child); }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1253; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1253; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1255; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1255; }
                continue;
            } elseif ($val instanceof Token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1257; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1257; \PhpFuzzer\FuzzingContext::traceBlock(1256, yield $val); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1259; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1259;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1261; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1261; }
    }

    /**
     * Gets array of declared child names (cached).
     *
     * This is used as an optimization when iterating over nodes: For direct iteration
     * PHP will create a properties hashtable on the object, thus doubling memory usage.
     * We avoid this by iterating over just the names instead.
     *
     * @return string[]
     */
    public function getChildNames() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1263; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1263; return $this::CHILD_NAMES; }
    }

    /**
     * Gets width of a Node (not including comment / whitespace trivia)
     *
     * @return int
     */
    public function getWidth() : int {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1264; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1264; $first = $this->getStart(); }
        $last = $this->getEndPosition();

        return $last - $first;
    }

    /**
     * Gets width of a Node (including comment / whitespace trivia)
     *
     * @return int
     */
    public function getFullWidth() : int {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1265; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1265; $first = $this->getFullStart(); }
        $last = $this->getEndPosition();

        return $last - $first;
    }

    /**
     * Gets string representing Node text (not including leading comment + whitespace trivia)
     * @return string
     */
    public function getText() : string {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1266; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1266; $start = $this->getStart(); }
        $end = $this->getEndPosition();

        $fileContents = $this->getFileContents();
        return \substr($fileContents, $start, $end - $start);
    }

    /**
     * Gets full text of Node (including leading comment + whitespace trivia)
     * @return string
     */
    public function getFullText() : string {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1267; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1267; $start = $this->getFullStart(); }
        $end = $this->getEndPosition();

        $fileContents = $this->getFileContents();
        return \substr($fileContents, $start, $end - $start);

    }

    /**
     * Gets string representing Node's leading comment and whitespace text.
     * @return string
     */
    public function getLeadingCommentAndWhitespaceText() : string {
        // TODO re-tokenize comments and whitespace
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1270; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1270; $fileContents = $this->getFileContents(); }
        foreach ($this->getDescendantTokens() as $token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1268; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1268; return $token->getLeadingCommentsAndWhitespaceText($fileContents); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1269; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1269;
        return '';
    }

    protected function getChildrenKvPairs() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1273; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1273; $result = array(); }
        foreach ($this::CHILD_NAMES as $name) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1271; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1271; $result[$name] = $this->$name; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1272; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1272;
        return $result;
    }

    public function jsonSerialize() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1274; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1274; $kindName = $this->getNodeKindName(); }
        return ["$kindName" => $this->getChildrenKvPairs()];
    }

    /**
     * Get the end index of a Node.
     * @return int
     * @throws \Exception
     */
    public function getEndPosition() {
        // TODO test invariant - start of next node is end of previous node
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1282; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1282; for ($i = \count($childKeys = $this::CHILD_NAMES) - 1; $i >= 0; $i--) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1280; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1280; $lastChildKey = $childKeys[$i]; }
            $lastChild = $this->$lastChildKey;

            if (\is_array($lastChild)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1275; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1275; $lastChild = \end($lastChild); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1276; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1276;

            if ($lastChild instanceof Token) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1278; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1278; return $lastChild->fullStart + $lastChild->length; }
            } elseif ($lastChild instanceof Node) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1277; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1277; return $lastChild->getEndPosition(); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1279; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1279;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1281; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1281; }

        throw new \Exception("Unhandled node type");
    }

    public function getFileContents() : string {
        // TODO consider renaming to getSourceText
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1283; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1283; return $this->getRoot()->fileContents; }
    }

    public function getUri() : string {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1284; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1284; return $this->getRoot()->uri; }
    }

    public function getLastChild() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1285; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1285; $a = iterator_to_array($this->getChildNodesAndTokens()); }
        return \end($a);
    }

    /**
     * Searches descendants to find a Node at the given position.
     *
     * @param int $pos
     * @return Node
     */
    public function getDescendantNodeAtPosition(int $pos) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1292; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1292; foreach ($this->getChildNodes() as $child) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1290; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1290; if ($child->containsPosition($pos)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1288; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1288; $node = $child->getDescendantNodeAtPosition($pos); }
                if (!is_null($node)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1286; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1286; return $node; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1287; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1287;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1289; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1289; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1291; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1291; }

        return $this;
    }

    /**
     * Returns true if the given Node or Token contains the given position.
     * @param int $pos
     * @return bool
     */
    private function containsPosition(int $pos): bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1294; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1294; return $this->getStart() <= $pos && \PhpFuzzer\FuzzingContext::traceBlock(1293, $pos <= $this->getEndPosition()); }
    }

    /**
     * Gets leading PHP Doc Comment text corresponding to the current Node.
     * Returns last doc comment in leading comment / whitespace trivia,
     * and returns null if there is no preceding doc comment.
     *
     * @return string|null
     */
    public function getDocCommentText() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1299; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1299; $leadingTriviaText = $this->getLeadingCommentAndWhitespaceText(); }
        $leadingTriviaTokens = PhpTokenizer::getTokensArrayFromContent(
            $leadingTriviaText, ParseContext::SourceElements, $this->getFullStart(), false
        );
        for ($i = \count($leadingTriviaTokens) - 1; $i >= 0; $i--) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1297; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1297; $token = $leadingTriviaTokens[$i]; }
            if ($token->kind === TokenKind::DocCommentToken) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1295; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1295; return $token->getText($this->getFileContents()); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1296; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1296;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1298; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1298;
        return null;
    }

    public function __toString() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1300; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1300; return $this->getText(); }
    }

    /**
     * @return array|ResolvedName[][]
     * @throws \Exception
     */
    public function getImportTablesForCurrentScope() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1327; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1327; $namespaceDefinition = $this->getNamespaceDefinition(); }

        // Use declarations can exist in either the global scope, or inside namespace declarations.
        // http://php.net/manual/en/language.namespaces.importing.php#language.namespaces.importing.scope
        //
        // The only code allowed before a namespace declaration is a declare statement, and sub-namespaces are
        // additionally unaffected by by import rules of higher-level namespaces. Therefore, we can make the assumption
        // that we need not travel up the spine any further once we've found the current namespace.
        // http://php.net/manual/en/language.namespaces.definition.php
        if ($namespaceDefinition instanceof NamespaceDefinition) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1303; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1303; $topLevelNamespaceStatements = $namespaceDefinition->compoundStatementOrSemicolon instanceof Token
                ? $namespaceDefinition->parent->statementList // we need to start from the namespace definition.
                : \PhpFuzzer\FuzzingContext::traceBlock(1301, $namespaceDefinition->compoundStatementOrSemicolon->statements); }
            $namespaceFullStart = $namespaceDefinition->getFullStart();
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1302; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1302; $topLevelNamespaceStatements = $this->getRoot()->statementList; }
            $namespaceFullStart = 0;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1304; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1304;

        $nodeFullStart = $this->getFullStart();

        // TODO optimize performance
        // Currently we rebuild the import tables on every call (and therefore every name resolution operation)
        // It is likely that a consumer will attempt many consecutive name resolution requests within the same file.
        // Therefore, we can consider optimizing on the basis of the "most recently used" import table set.
        // The idea: Keep a single set of import tables cached based on a unique root node id, and invalidate
        // cache whenever we attempt to resolve a qualified name with a different root node.
        //
        // In order to make this work, it will probably make sense to change the way we parse namespace definitions.
        // https://github.com/Microsoft/tolerant-php-parser/issues/81
        //
        // Currently the namespace definition only includes a compound statement or semicolon token as one if it's children.
        // Instead, we should move to a model where we parse future statements as a child rather than as a separate
        // statement. This would enable us to retrieve all the information we would need to find the fully qualified
        // name by simply traveling up the spine to find the first ancestor of type NamespaceDefinition.
        $namespaceImportTable = $functionImportTable = $constImportTable = [];
        $contents = $this->getFileContents();

        foreach ($topLevelNamespaceStatements as $useDeclaration) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1325; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1325; if ($useDeclaration->getFullStart() <= $namespaceFullStart) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1305; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1305; continue; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1306; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1306; }
            if ($useDeclaration->getFullStart() > $nodeFullStart) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1308; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1308; break; }
            } elseif (!($useDeclaration instanceof NamespaceUseDeclaration)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1307; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1307; continue; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1309; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1309;

            // TODO fix getValues
            foreach ((isset($useDeclaration->useClauses) ? $useDeclaration->useClauses->getValues() : \PhpFuzzer\FuzzingContext::traceBlock(1310, [])) as $useClause) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1323; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1323; $namespaceNamePartsPrefix = $useClause->namespaceName !== null ? $useClause->namespaceName->nameParts : \PhpFuzzer\FuzzingContext::traceBlock(1311, []); }

                if ($useClause->groupClauses !== null && \PhpFuzzer\FuzzingContext::traceBlock(1312, $useClause instanceof NamespaceUseClause)) {
                    // use A\B\C\{D\E};                 namespace import: ["E" => [A,B,C,D,E]]
                    // use A\B\C\{D\E as F};            namespace import: ["F" => [A,B,C,D,E]]
                    // use function A\B\C\{A, B}        function import: ["A" => [A,B,C,A], "B" => [A,B,C]]
                    // use function A\B\C\{const A}     const import: ["A" => [A,B,C,A]]
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1321; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1321; foreach ($useClause->groupClauses->children as $groupClause) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1317; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1317; if (!($groupClause instanceof NamespaceUseGroupClause)) {
                            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1313; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1313; continue; }
                        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1314; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1314; }
                        $namespaceNameParts = \array_merge($namespaceNamePartsPrefix, $groupClause->namespaceName->nameParts);
                        $functionOrConst = $groupClause->functionOrConst ?? \PhpFuzzer\FuzzingContext::traceBlock(1315, $useDeclaration->functionOrConst);
                        $alias = $groupClause->namespaceAliasingClause === null
                            ? $groupClause->namespaceName->getLastNamePart()->getText($contents)
                            : \PhpFuzzer\FuzzingContext::traceBlock(1316, $groupClause->namespaceAliasingClause->name->getText($contents));

                        $this->addToImportTable(
                            $alias, $functionOrConst, $namespaceNameParts, $contents,
                            $namespaceImportTable, $functionImportTable, $constImportTable
                        );
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1318; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1318; }
                } else {
                    // use A\B\C;               namespace import: ["C" => [A,B,C]]
                    // use A\B\C as D;          namespace import: ["D" => [A,B,C]]
                    // use function A\B\C as D  function import: ["D" => [A,B,C]]
                    // use A\B, C\D;            namespace import: ["B" => [A,B], "D" => [C,D]]
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1320; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1320; $alias = $useClause->namespaceAliasingClause === null
                        ? $useClause->namespaceName->getLastNamePart()->getText($contents)
                        : \PhpFuzzer\FuzzingContext::traceBlock(1319, $useClause->namespaceAliasingClause->name->getText($contents)); }
                    $functionOrConst = $useDeclaration->functionOrConst;
                    $namespaceNameParts = $namespaceNamePartsPrefix;

                    $this->addToImportTable(
                        $alias, $functionOrConst, $namespaceNameParts, $contents,
                        $namespaceImportTable, $functionImportTable, $constImportTable
                    );
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1322; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1322;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1324; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1324;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1326; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1326;

        return [$namespaceImportTable, $functionImportTable, $constImportTable];
    }

    /**
     * Gets corresponding NamespaceDefinition for Node. Returns null if in global namespace.
     *
     * @return NamespaceDefinition|null
     */
    public function getNamespaceDefinition() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1345; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1345; $namespaceDefinition = $this instanceof NamespaceDefinition
            ? $this
            : \PhpFuzzer\FuzzingContext::traceBlock(1328, $this->getFirstAncestor(NamespaceDefinition::class, SourceFileNode::class)); }

        if ($namespaceDefinition instanceof NamespaceDefinition && \PhpFuzzer\FuzzingContext::traceBlock(1329, !($namespaceDefinition->parent instanceof SourceFileNode))) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1330; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1330; $namespaceDefinition = $namespaceDefinition->getFirstAncestor(SourceFileNode::class); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1331; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1331;

        if ($namespaceDefinition === null) {
            // TODO provide a way to throw errors without crashing consumer
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1332; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1332; throw new \Exception("Invalid tree - SourceFileNode must always exist at root of tree."); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1333; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1333;

        $fullStart = $this->getFullStart();
        $lastNamespaceDefinition = null;
        if ($namespaceDefinition instanceof SourceFileNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1339; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1339; foreach ($namespaceDefinition->getChildNodes() as $childNode) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1337; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1337; if ($childNode instanceof NamespaceDefinition && \PhpFuzzer\FuzzingContext::traceBlock(1334, $childNode->getFullStart() < $fullStart)) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1335; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1335; $lastNamespaceDefinition = $childNode; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1336; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1336; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1338; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1338; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1340; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1340;

        if ($lastNamespaceDefinition !== null && \PhpFuzzer\FuzzingContext::traceBlock(1341, $lastNamespaceDefinition->compoundStatementOrSemicolon instanceof Token)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1343; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1343; $namespaceDefinition = $lastNamespaceDefinition; }
        } elseif ($namespaceDefinition instanceof SourceFileNode) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1342; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1342; $namespaceDefinition = null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1344; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1344;

        return $namespaceDefinition;
    }

    public function getPreviousSibling() {
        // TODO make more efficient
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1360; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1360; $parent = $this->parent; }
        if ($parent === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1346; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1346; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1347; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1347;

        $prevSibling = null;

        foreach ($parent::CHILD_NAMES as $name) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1358; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1358; $val = $parent->$name; }
            if (\is_array($val)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1356; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1356; foreach ($val as $sibling) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1351; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1351; if ($sibling === $this) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1349; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1349; return $prevSibling; }
                    } elseif ($sibling instanceof Node) {
                        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1348; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1348; $prevSibling = $sibling; }
                    } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1350; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1350; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1352; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1352; }
                continue;
            } elseif ($val instanceof Node) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1355; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1355; if ($val === $this) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1353; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1353; return $prevSibling; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1354; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1354; }
                $prevSibling = $val;
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1357; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1357;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1359; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1359;
        return null;
    }

    /**
     * Add the alias and resolved name to the corresponding namespace, function, or const import table.
     * If the alias already exists, it will get replaced by the most recent using.
     *
     * TODO - worth throwing an error here in stead?
     */
    private function addToImportTable($alias, $functionOrConst, $namespaceNameParts, $contents, & $namespaceImportTable, & $functionImportTable, & $constImportTable):array
    {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1367; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1367; if ($alias !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1365; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1365; if ($functionOrConst === null) {
                // namespaces are case-insensitive
//                $alias = \strtolower($alias);
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1363; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1363; $namespaceImportTable[$alias] = ResolvedName::buildName($namespaceNameParts, $contents); }
                return array($namespaceImportTable, $functionImportTable, $constImportTable);
            } elseif ($functionOrConst->kind === TokenKind::FunctionKeyword) {
                // functions are case-insensitive
//                $alias = \strtolower($alias);
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1361; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1361; $functionImportTable[$alias] = ResolvedName::buildName($namespaceNameParts, $contents); }
                return array($namespaceImportTable, $functionImportTable, $constImportTable);
            } elseif ($functionOrConst->kind === TokenKind::ConstKeyword) {
                // constants are case-sensitive
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1362; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1362; $constImportTable[$alias] = ResolvedName::buildName($namespaceNameParts, $contents); }
                return array($namespaceImportTable, $functionImportTable, $constImportTable);
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1364; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1364; }
            return array($namespaceImportTable, $functionImportTable, $constImportTable);
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1366; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1366; }
        return array($namespaceImportTable, $functionImportTable, $constImportTable);
    }

    /**
     * This is overridden in subclasses
     * @return Diagnostic|null - Callers should use DiagnosticsProvider::getDiagnostics instead
     * @internal
     */
    public function getDiagnosticForNode() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1368; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1368; return null; }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class InlineHtml extends StatementNode {
    /** @var Token|null */
    public $scriptSectionEndTag;

    /** @var Token */
    public $text;

    /** @var Token|null */
    public $scriptSectionStartTag;

    /**
     * @var ExpressionStatement|null used to represent the expression echoed by `<?=` while parsing.
     *
     * This should always be null in the returned AST,
     * and is deliberately excluded from CHILD_NAMES.
     *
     * This will be null under any of these conditions:
     *
     * - The scriptSectionStartTag isn't TokenKind::ScriptSectionStartWithEchoTag,
     * - The echoStatement was normalized and moved into a statement list.
     *   If a caller doesn't do this, that's a bug.
     */
    public $echoStatement;

    const CHILD_NAMES = [
        'scriptSectionEndTag',
        'text',
        'scriptSectionStartTag',
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;

abstract class StatementNode extends Node {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class ExpressionStatement extends StatementNode {
    /** @var Expression */
    public $expression;
    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'expression',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Token;

class ErrorControlExpression extends UnaryExpression {

    /** @var Token */
    public $operator;

    /** @var UnaryExpression */
    public $operand;

    const CHILD_NAMES = [
        'operator',
        'operand'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;

class UnaryExpression extends Expression {
    /** @var UnaryExpression|Variable */
    public $operand;

    const CHILD_NAMES = [
        'operand'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;

abstract class Expression extends Node {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

class MissingToken extends Token {
    public function __construct(int $kind, int $fullStart) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1369; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1369; parent::__construct($kind, $fullStart, $fullStart, 0); }
    }

    public function jsonSerialize() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1370; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1370; return array_merge(
            ["error" => $this->getTokenKindNameFromValue(TokenKind::MissingToken)],
            parent::jsonSerialize()
        ); }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

class SkippedToken extends Token {
    public function __construct(Token $token) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1371; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1371; parent::__construct($token->kind, $token->fullStart, $token->start, $token->length); }
    }

    public function jsonSerialize() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1372; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1372; return array_merge(
            ["error" => $this->getTokenKindNameFromValue(TokenKind::SkippedToken)],
            parent::jsonSerialize()
        ); }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\NamespacedNameInterface;
use Microsoft\PhpParser\NamespacedNameTrait;
use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Node\Expression\AnonymousFunctionCreationExpression;
use Microsoft\PhpParser\Node\Expression\ArrowFunctionCreationExpression;
use Microsoft\PhpParser\Node\Expression\CallExpression;
use Microsoft\PhpParser\Node\Expression\ObjectCreationExpression;
use Microsoft\PhpParser\ResolvedName;
use Microsoft\PhpParser\Token;
use Microsoft\PhpParser\TokenKind;

class QualifiedName extends Node implements NamespacedNameInterface {
    use NamespacedNameTrait;

    /** @var Token */
    public $globalSpecifier; // \_opt
    /** @var RelativeSpecifier */
    public $relativeSpecifier; // namespace\
    /** @var array */
    public $nameParts;

    const CHILD_NAMES = [
        'globalSpecifier',
        'relativeSpecifier',
        'nameParts'
    ];

    /**
     * Checks whether a QualifiedName is prefixed with a backslash global specifier.
     * @return bool
     */
    public function isFullyQualifiedName() : bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1373; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1373; return isset($this->globalSpecifier); }
    }

    /**
     * Checks whether a QualifiedName begins with a "namespace" keyword
     * @return bool
     */
    public function isRelativeName() : bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1374; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1374; return isset($this->relativeSpecifier); }
    }

    /**
     * Checks whether a Name includes at least one namespace separator (and is neither fully-qualified nor relative)
     * @return bool
     */
    public function isQualifiedName() : bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1377; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1377; return
            !$this->isFullyQualifiedName() &&
            \PhpFuzzer\FuzzingContext::traceBlock(1375, !$this->isRelativeName()) &&
            \PhpFuzzer\FuzzingContext::traceBlock(1376, \count($this->nameParts) > 1); } // at least one namespace separator
    }

    /**
     * Checks whether a name is does not include a namespace separator.
     * @return bool
     */
    public function isUnqualifiedName() : bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1380; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1380; return !($this->isFullyQualifiedName() || \PhpFuzzer\FuzzingContext::traceBlock(1378, $this->isRelativeName()) || \PhpFuzzer\FuzzingContext::traceBlock(1379, $this->isQualifiedName())); }
    }

    /**
     * Gets resolved name based on name resolution rules defined in:
     * http://php.net/manual/en/language.namespaces.rules.php
     *
     * Returns null if one of the following conditions is met:
     * - name resolution is not valid for this element (e.g. part of the name in a namespace definition)
     * - name cannot be resolved (unqualified namespaced function/constant names that are not explicitly imported.)
     *
     * @return null|string|ResolvedName
     * @throws \Exception
     */
    public function getResolvedName($namespaceDefinition = null) {
        // Name resolution not applicable to constructs that define symbol names or aliases.
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1413; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1413; if (($this->parent instanceof Node\Statement\NamespaceDefinition && \PhpFuzzer\FuzzingContext::traceBlock(1381, $this->parent->name->getStart() === $this->getStart())) ||
            \PhpFuzzer\FuzzingContext::traceBlock(1382, $this->parent instanceof Node\Statement\NamespaceUseDeclaration) ||
            \PhpFuzzer\FuzzingContext::traceBlock(1383, $this->parent instanceof Node\NamespaceUseClause) ||
            \PhpFuzzer\FuzzingContext::traceBlock(1384, $this->parent instanceof Node\NamespaceUseGroupClause) ||
            \PhpFuzzer\FuzzingContext::traceBlock(1385, $this->parent->parent instanceof Node\TraitUseClause) ||
            \PhpFuzzer\FuzzingContext::traceBlock(1386, $this->parent instanceof Node\TraitSelectOrAliasClause) ||
            (\PhpFuzzer\FuzzingContext::traceBlock(1389, $this->parent instanceof TraitSelectOrAliasClause &&
            (\PhpFuzzer\FuzzingContext::traceBlock(1388, $this->parent->asOrInsteadOfKeyword == null || \PhpFuzzer\FuzzingContext::traceBlock(1387, $this->parent->asOrInsteadOfKeyword->kind === TokenKind::AsKeyword)))))
        ) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1390; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1390; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1391; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1391; }

        if (in_array($lowerText = strtolower($this->getText()), ["self", "static", "parent"])) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1392; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1392; return $lowerText; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1393; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1393;

        // FULLY QUALIFIED NAMES
        // - resolve to the name without leading namespace separator.
        if ($this->isFullyQualifiedName()) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1394; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1394; return ResolvedName::buildName($this->nameParts, $this->getFileContents()); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1395; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1395;

        // RELATIVE NAMES
        // - resolve to the name with namespace replaced by the current namespace.
        // - if current namespace is global, strip leading namespace\ prefix.
        if ($this->isRelativeName()) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1396; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1396; return $this->getNamespacedName(); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1397; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1397;

        list($namespaceImportTable, $functionImportTable, $constImportTable) = $this->getImportTablesForCurrentScope();

        // QUALIFIED NAMES
        // - first segment of the name is translated according to the current class/namespace import table.
        // - If no import rule applies, the current namespace is prepended to the name.
        if ($this->isQualifiedName()) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1399; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1399; return $this->tryResolveFromImportTable($namespaceImportTable) ?? \PhpFuzzer\FuzzingContext::traceBlock(1398, $this->getNamespacedName()); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1400; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1400;

        // UNQUALIFIED NAMES
        // - translated according to the current import table for the respective symbol type.
        //   (class-like => namespace import table, constant => const import table, function => function import table)
        // - if no import rule applies:
        //   - all symbol types: if current namespace is global, resolve to global namespace.
        //   - class-like symbols: resolve from current namespace.
        //   - function or const: resolved at runtime (from current namespace, with fallback to global namespace).
        if ($this->isConstantName()) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1410; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1410; $resolvedName = $this->tryResolveFromImportTable($constImportTable, /* case-sensitive */ true); }
            $namespaceDefinition = $this->getNamespaceDefinition();
            if ($namespaceDefinition !== null && \PhpFuzzer\FuzzingContext::traceBlock(1401, $namespaceDefinition->name === null)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1403; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1403; $resolvedName = $resolvedName ?? \PhpFuzzer\FuzzingContext::traceBlock(1402, ResolvedName::buildName($this->nameParts, $this->getFileContents())); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1404; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1404;
            return $resolvedName;
        } elseif ($this->parent instanceof CallExpression) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1409; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1409; $resolvedName = $this->tryResolveFromImportTable($functionImportTable); }
            if (($namespaceDefinition = $this->getNamespaceDefinition()) === null || \PhpFuzzer\FuzzingContext::traceBlock(1405, $namespaceDefinition->name === null)) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1407; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1407; $resolvedName = $resolvedName ?? \PhpFuzzer\FuzzingContext::traceBlock(1406, ResolvedName::buildName($this->nameParts, $this->getFileContents())); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1408; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1408;
            return $resolvedName;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1411; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1411;

        return $this->tryResolveFromImportTable($namespaceImportTable) ?? \PhpFuzzer\FuzzingContext::traceBlock(1412, $this->getNamespacedName());
    }

    public function getLastNamePart() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1418; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1418; $parts = $this->nameParts; }
        for ($i = \count($parts) - 1; $i >= 0; $i--) {
            // TODO - also handle reserved word tokens
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1416; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1416; if ($parts[$i]->kind === TokenKind::Name) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1414; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1414; return $parts[$i]; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1415; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1415; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1417; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1417;
        return null;
    }

    /**
     * @param ResolvedName[] $importTable
     * @param bool $isCaseSensitive
     * @return string|null
     */
    private function tryResolveFromImportTable($importTable, bool $isCaseSensitive = false) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1421; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1421; $content = $this->getFileContents(); }
        $index = $this->nameParts[0]->getText($content);
//        if (!$isCaseSensitive) {
//            $index = strtolower($index);
//        }
        if(isset($importTable[$index])) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1419; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1419; $resolvedName = $importTable[$index]; }
            $resolvedName->addNameParts(\array_slice($this->nameParts, 1), $content);
            return $resolvedName;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1420; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1420;
        return null;
    }

    private function isConstantName() : bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1431; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1431; return
            ($this->parent instanceof Node\Statement\ExpressionStatement || \PhpFuzzer\FuzzingContext::traceBlock(1422, $this->parent instanceof Expression)) &&
            \PhpFuzzer\FuzzingContext::traceBlock(1430, !(
                $this->parent instanceof Node\Expression\MemberAccessExpression || \PhpFuzzer\FuzzingContext::traceBlock(1423, $this->parent instanceof CallExpression) ||
                \PhpFuzzer\FuzzingContext::traceBlock(1424, $this->parent instanceof ObjectCreationExpression) ||
                \PhpFuzzer\FuzzingContext::traceBlock(1425, $this->parent instanceof Node\Expression\ScopedPropertyAccessExpression) || \PhpFuzzer\FuzzingContext::traceBlock(1426, $this->parent instanceof AnonymousFunctionCreationExpression) ||
                \PhpFuzzer\FuzzingContext::traceBlock(1427, $this->parent instanceof ArrowFunctionCreationExpression) ||
                (\PhpFuzzer\FuzzingContext::traceBlock(1429, $this->parent instanceof Node\Expression\BinaryExpression && \PhpFuzzer\FuzzingContext::traceBlock(1428, $this->parent->operator->kind === TokenKind::InstanceOfKeyword)))
            )); }
    }

    public function getNameParts() : array {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1432; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1432; return $this->nameParts; }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

interface NamespacedNameInterface {
    public function getNamespacedName() : ResolvedName;
}
<?php
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

use Microsoft\PhpParser\Node\NamespaceUseClause;
use Microsoft\PhpParser\Node\NamespaceUseGroupClause;
use Microsoft\PhpParser\Node\QualifiedName;
use Microsoft\PhpParser\Node\Statement\NamespaceDefinition;
use Microsoft\PhpParser\Node\Statement\NamespaceUseDeclaration;

trait NamespacedNameTrait {
    public abstract function getNamespaceDefinition();
    public abstract function getFileContents() : string;
    public abstract function getNameParts() : array;

    /**
     * Gets resolved name from current namespace. Note that this is not necessarily the *actual* name
     * that is resolved during compilation or at runtime. For that, see QualifiedName::getResolvedName().
     *
     * @return ResolvedName
     */
    public function getNamespacedName() : ResolvedName {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1444; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1444; $namespaceDefinition = $this->getNamespaceDefinition(); }
        $content = $this->getFileContents();
        if ($namespaceDefinition === null) {
            // global namespace -> strip namespace\ prefix
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1433; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1433; return ResolvedName::buildName($this->getNameParts(), $content); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1434; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1434;

        if ($namespaceDefinition->name !== null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1436; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1436; $resolvedName = ResolvedName::buildName($namespaceDefinition->name->nameParts, $content); }
        } else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1435; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1435; $resolvedName = ResolvedName::buildName([], $content); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1437; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1437;
        if (
            !($this instanceof QualifiedName && (
            \PhpFuzzer\FuzzingContext::traceBlock(1441, ($this->parent instanceof NamespaceDefinition) ||
            (\PhpFuzzer\FuzzingContext::traceBlock(1438, $this->parent instanceof NamespaceUseDeclaration)) ||
            (\PhpFuzzer\FuzzingContext::traceBlock(1439, $this->parent instanceof NamespaceUseClause)) ||
            (\PhpFuzzer\FuzzingContext::traceBlock(1440, $this->parent instanceof NamespaceUseGroupClause)))))
        ) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1442; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1442; $resolvedName->addNameParts($this->getNameParts(), $content); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1443; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1443;
        return $resolvedName;
    }
}<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class RelativeSpecifier extends Node {
    /** @var Token */
    public $namespaceKeyword;

    /** @var Token */
    public $backslash;

    const CHILD_NAMES = [
        'namespaceKeyword',
        'backslash'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class QualifiedNameParts extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;
use Microsoft\PhpParser\TokenKind;

abstract class DelimitedList extends Node {
    /** @var Token[]|Node[] */
    public $children;

    const CHILD_NAMES = [
        'children'
    ];

    const DELIMITERS = [TokenKind::CommaToken, TokenKind::BarToken, TokenKind::SemicolonToken];

    public function getElements() : \Generator {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1453; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1453; foreach ($this->children as $child) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1451; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1451; if ($child instanceof Node) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1449; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1449; \PhpFuzzer\FuzzingContext::traceBlock(1445, yield $child); }
            } elseif ($child instanceof Token && \PhpFuzzer\FuzzingContext::traceBlock(1446, !\in_array($child->kind, self::DELIMITERS))) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1448; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1448; \PhpFuzzer\FuzzingContext::traceBlock(1447, yield $child); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1450; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1450; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1452; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1452; }
    }

    public function getValues() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1459; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1459; foreach ($this->children as $idx=>$value) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1457; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1457; if ($idx % 2 == 0) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1455; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1455; \PhpFuzzer\FuzzingContext::traceBlock(1454, yield $value); }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1456; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1456; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1458; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1458; }
    }

    public function addElement($node) {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1464; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1464; if ($node === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1460; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1460; return; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1461; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1461; }
        if ($this->children === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1462; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1462; $this->children = [$node]; }
            return;
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1463; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1463;
        $this->children[] = $node;
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\FunctionLike;
use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\FunctionHeader;
use Microsoft\PhpParser\Node\FunctionReturnType;
use Microsoft\PhpParser\Token;

class ArrowFunctionCreationExpression extends Expression implements FunctionLike {
    /** @var Token|null */
    public $staticModifier;

    use FunctionHeader, FunctionReturnType;

    /** @var Token `=>` */
    public $arrowToken;

    /** @var Node|Token */
    public $resultExpression;

    const CHILD_NAMES = [
        'attributes',
        'staticModifier',

        // FunctionHeader
        'functionKeyword',
        'byRefToken',
        'name',
        'openParen',
        'parameters',
        'closeParen',

        // FunctionReturnType
        'colonToken',
        'questionToken',
        'returnType',
        'otherReturnTypes',

        // body
        'arrowToken',
        'resultExpression',
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

use Microsoft\PhpParser\Node\AttributeGroup;

/**
 * Interface for recognizing functions easily.
 * Each Node that implements this interface can be considered a function.
 *
 * @property AttributeGroup[] $attributes
 */
interface FunctionLike {}<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Token;

trait FunctionHeader {
    /** @var AttributeGroup[]|null */
    public $attributes;
    /** @var Token */
    public $functionKeyword;
    /** @var Token */
    public $byRefToken;
    /** @var null|Token */
    public $name;
    /** @var Token */
    public $openParen;
    /** @var DelimitedList\ParameterDeclarationList */
    public $parameters;
    /** @var Token */
    public $closeParen;
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Token;

trait FunctionReturnType {
    /** @var Token */
    public $colonToken;
    /** @var Token|null */
    public $questionToken;
    /** @var Token|QualifiedName */
    public $returnType;
    /** @var DelimitedList\QualifiedNameList|null TODO: Merge with returnType in a future backwards incompatible release */
    public $otherReturnTypes;
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class ParameterDeclarationList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\DelimitedList\ExpressionList;
use Microsoft\PhpParser\Token;

/**
 * This represents either a literal echo expression (`echo expr`)
 * or a short echo tag (`<?= expr...`)
 *
 * TODO: An echo statement cannot be used as an expression.
 * Consider refactoring this to become EchoStatement in a future backwards incompatible release.
 */
class EchoExpression extends Expression {

    /**
     * @var Token|null this is null if generated from `<?=`
     */
    public $echoKeyword;

    /** @var ExpressionList */
    public $expressions;

    const CHILD_NAMES = [
        'echoKeyword',
        'expressions'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class ExpressionList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\ClassLike;
use Microsoft\PhpParser\NamespacedNameInterface;
use Microsoft\PhpParser\NamespacedNameTrait;
use Microsoft\PhpParser\Node\AttributeGroup;
use Microsoft\PhpParser\Node\ClassBaseClause;
use Microsoft\PhpParser\Node\ClassInterfaceClause;
use Microsoft\PhpParser\Node\ClassMembersNode;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class ClassDeclaration extends StatementNode implements NamespacedNameInterface, ClassLike {
    use NamespacedNameTrait;

    /** @var AttributeGroup[]|null */
    public $attributes;

    /** @var Token */
    public $abstractOrFinalModifier;

    /** @var Token */
    public $classKeyword;

    /** @var Token */
    public $name;

    /** @var ClassBaseClause */
    public $classBaseClause;

    /** @var ClassInterfaceClause */
    public $classInterfaceClause;

    /** @var ClassMembersNode */
    public $classMembers;

    const CHILD_NAMES = [
        'attributes',
        'abstractOrFinalModifier',
        'classKeyword',
        'name',
        'classBaseClause',
        'classInterfaceClause',
        'classMembers'
    ];

    public function getNameParts() : array {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1465; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1465; return [$this->name]; }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

/**
 * Represents Classes, Interfaces and Traits.
 */
interface ClassLike {}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class ClassBaseClause extends Node {
    /** @var Token */
    public $extendsKeyword;

    /** @var QualifiedName */
    public $baseClass;

    const CHILD_NAMES = [
        'extendsKeyword',
        'baseClass'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class ClassInterfaceClause extends Node {
    /** @var Token */
    public $implementsKeyword;

    /** @var DelimitedList\QualifiedNameList|null */
    public $interfaceNameList;

    const CHILD_NAMES = [
        'implementsKeyword',
        'interfaceNameList'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class ClassMembersNode extends Node {
    /** @var Token */
    public $openBrace;

    /** @var Node[] */
    public $classMemberDeclarations;

    /** @var Token */
    public $closeBrace;

    const CHILD_NAMES = [
        'openBrace',
        'classMemberDeclarations',
        'closeBrace'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class AssignmentExpression extends BinaryExpression {

    /** @var Expression */
    public $leftOperand;

    /** @var Token */
    public $operator;

    /** @var Token */
    public $byRef;

    /** @var Expression */
    public $rightOperand;

    const CHILD_NAMES = [
        'leftOperand',
        'operator',
        'byRef',
        'rightOperand'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class BinaryExpression extends Expression {

    /** @var Expression */
    public $leftOperand;

    /** @var Token */
    public $operator;

    /** @var Expression */
    public $rightOperand;

    const CHILD_NAMES = [
        'leftOperand',
        'operator',
        'rightOperand'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class CallExpression extends Expression {
    /** @var Expression */
    public $callableExpression;

    /** @var Token */
    public $openParen;

    /** @var DelimitedList\ArgumentExpressionList|null */
    public $argumentExpressionList;

    /** @var Token */
    public $closeParen;

    const CHILD_NAMES = [
        'callableExpression',
        'openParen',
        'argumentExpressionList',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class ArgumentExpressionList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class ArgumentExpression extends Expression {
    /** @var Token|null for php named arguments. If this is set, byRefToken and dotDotDotToken will not be set. */
    public $name;

    /** @var Token|null */
    public $colonToken;

    /** @var Token|null */
    public $byRefToken; // TODO removed in newer versions of PHP. Also only accept variable, not expression if byRef

    /** @var Token|null */
    public $dotDotDotToken;

    /** @var Expression */
    public $expression;

    const CHILD_NAMES = [
        'name',
        'colonToken',
        'byRefToken',
        'dotDotDotToken',
        'expression'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\AttributeGroup;
use Microsoft\PhpParser\Node\ClassBaseClause;
use Microsoft\PhpParser\Node\ClassInterfaceClause;
use Microsoft\PhpParser\Node\ClassMembersNode;
use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\QualifiedName;
use Microsoft\PhpParser\Token;

class ObjectCreationExpression extends Expression {

    /** @var Token */
    public $newKeword;

    /** @var AttributeGroup[]|null optional attributes of an anonymous class. */
    public $attributes;

    /** @var QualifiedName|Variable|Token */
    public $classTypeDesignator;

    /** @var Token|null */
    public $openParen;

    /** @var DelimitedList\ArgumentExpressionList|null  */
    public $argumentExpressionList;

    /** @var Token|null */
    public $closeParen;

    /** @var ClassBaseClause|null */
    public $classBaseClause;

    /** @var ClassInterfaceClause|null */
    public $classInterfaceClause;

    /** @var ClassMembersNode|null */
    public $classMembers;

    const CHILD_NAMES = [
        'newKeword',
        'attributes',
        'classTypeDesignator',
        'openParen',
        'argumentExpressionList',
        'closeParen',
        'classBaseClause',
        'classInterfaceClause',
        'classMembers'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class TernaryExpression extends Expression {

    /** @var Expression|Token (only a token when token before '?' is invalid/missing) */
    public $condition;

    /** @var Token */
    public $questionToken;

    /** @var Expression */
    public $ifExpression;

    /** @var Token */
    public $colonToken;

    /** @var Expression */
    public $elseExpression;

    const CHILD_NAMES = [
        'condition',
        'questionToken',
        'ifExpression',
        'colonToken',
        'elseExpression'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class ParenthesizedExpression extends Expression {

    /** @var Token */
    public $openParen;

    /** @var Expression */
    public $expression;

    /** @var Token */
    public $closeParen;

    const CHILD_NAMES = [
        'openParen',
        'expression',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class IssetIntrinsicExpression extends Expression {

    /** @var Token */
    public $issetKeyword;

    /** @var Token */
    public $openParen;

    /** @var DelimitedList\ExpressionList */
    public $expressions;

    /** @var Token */
    public $closeParen;

    const CHILD_NAMES = [
        'issetKeyword',
        'openParen',
        'expressions',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\ForeachKey;
use Microsoft\PhpParser\Node\ForeachValue;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class ForeachStatement extends StatementNode {
    /** @var Token */
    public $foreach;
    /** @var Token */
    public $openParen;
    /** @var Expression */
    public $forEachCollectionName;
    /** @var Token */
    public $asKeyword;
    /** @var ForeachKey|null */
    public $foreachKey;
    /** @var ForeachValue */
    public $foreachValue;
    /** @var Token */
    public $closeParen;
    /** @var Token|null */
    public $colon;
    /** @var StatementNode|StatementNode[] */
    public $statements;
    /** @var Token|null */
    public $endForeach;
    /** @var Token|null */
    public $endForeachSemicolon;

    const CHILD_NAMES = [
        'foreach',
        'openParen',
        'forEachCollectionName',
        'asKeyword',
        'foreachKey',
        'foreachValue',
        'closeParen',
        'colon',
        'statements',
        'endForeach',
        'endForeachSemicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class ForeachValue extends Node {
    /** @var Token|null */
    public $ampersand;
    /** @var Expression */
    public $expression;

    const CHILD_NAMES = [
        'ampersand',
        'expression'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class StringLiteral extends Expression {
    /** @var Token */
    public $startQuote;

    /** @var Token[]|Node[]|Token */
    public $children;

    /** @var Token */
    public $endQuote;

    const CHILD_NAMES = [
        'startQuote',
        'children',
        'endQuote',
    ];

    public function getStringContentsText() {
        // TODO add tests
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1471; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1471; $stringContents = ""; }
        if (isset($this->startQuote)) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1469; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1469; foreach ($this->children as $child) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1466; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1466; $contents = $this->getFileContents(); }
                $stringContents .= $child->getFullText($contents);
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1467; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1467; }
        } else {
            // TODO ensure string consistency (all strings should have start / end quote)
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1468; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1468; $stringContents = trim($this->children->getText($this->getFileContents()), '"\''); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1470; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1470;
        return $stringContents;
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class Variable extends Expression {
    /** @var Token */
    public $dollar;

    /** @var Token|Variable|BracedExpression */
    public $name;

    const CHILD_NAMES = [
        'dollar',
        'name'
    ];

    public function getName() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1475; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1475; if (
            $this->name instanceof Token &&
            \PhpFuzzer\FuzzingContext::traceBlock(1472, $name = ltrim($this->name->getText($this->getFileContents()), '$'))
        ) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1473; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1473; return $name; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1474; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1474; }
        return null;
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class SubscriptExpression extends Expression {

    /** @var Expression */
    public $postfixExpression;

    /** @var Token */
    public $openBracketOrBrace;

    /** @var Expression */
    public $accessExpression;

    /** @var Token */
    public $closeBracketOrBrace;

    const CHILD_NAMES = [
        'postfixExpression',
        'openBracketOrBrace',
        'accessExpression',
        'closeBracketOrBrace'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class ArrayCreationExpression extends Expression {

    /** @var Token|null */
    public $arrayKeyword;

    /** @var Token */
    public $openParenOrBracket;

    /** @var DelimitedList\ArrayElementList */
    public $arrayElements;

    /** @var Token */
    public $closeParenOrBracket;

    const CHILD_NAMES = [
        'arrayKeyword',
        'openParenOrBracket',
        'arrayElements',
        'closeParenOrBracket'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class ArrayElementList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Token;

class NumericLiteral extends Expression {
    /** @var Token */
    public $children;

    const CHILD_NAMES = [
        'children'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class ThrowExpression extends Expression {
    /** @var Token */
    public $throwKeyword;
    /** @var Expression */
    public $expression;

    const CHILD_NAMES = [
        'throwKeyword',
        'expression',
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Token;

class UnaryOpExpression extends UnaryExpression {

    /** @var Token */
    public $operator;

    /** @var UnaryExpression */
    public $operand;

    const CHILD_NAMES = [
        'operator',
        'operand'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class ForeachKey extends Node {
    /** @var Expression */
    public $expression;
    /** @var Token */
    public $arrow;

    const CHILD_NAMES = [
        'expression',
        'arrow'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\ClassLike;
use Microsoft\PhpParser\NamespacedNameInterface;
use Microsoft\PhpParser\NamespacedNameTrait;
use Microsoft\PhpParser\Node\AttributeGroup;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Node\TraitMembers;
use Microsoft\PhpParser\Token;

class TraitDeclaration extends StatementNode implements NamespacedNameInterface, ClassLike {
    use NamespacedNameTrait;

    /** @var AttributeGroup[]|null */
    public $attributes;

    /** @var Token */
    public $traitKeyword;

    /** @var Token */
    public $name;

    /** @var TraitMembers */
    public $traitMembers;

    const CHILD_NAMES = [
        'attributes',
        'traitKeyword',
        'name',
        'traitMembers'
    ];

    public function getNameParts() : array {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1476; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1476; return [$this->name]; }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class TraitMembers extends Node {
    /** @var Token */
    public $openBrace;

    /** @var Node[] */
    public $traitMemberDeclarations;

    /** @var Token */
    public $closeBrace;

    const CHILD_NAMES = [
        'openBrace',
        'traitMemberDeclarations',
        'closeBrace',
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class EvalIntrinsicExpression extends Expression {

    /** @var Token */
    public $evalKeyword;

    /** @var Token */
    public $openParen;

    /** @var Expression */
    public $expression;

    /** @var Token */
    public $closeParen;

    const CHILD_NAMES = [
        'evalKeyword',
        'openParen',
        'expression',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class DoStatement extends StatementNode {
    /** @var Token */
    public $do;
    /** @var StatementNode */
    public $statement;
    /** @var Token */
    public $whileToken;
    /** @var Token */
    public $openParen;
    /** @var Expression */
    public $expression;
    /** @var Token */
    public $closeParen;
    /** @var Token|null */
    public $semicolon;

    const CHILD_NAMES = [
        'do',
        'statement',
        'whileToken',
        'openParen',
        'expression',
        'closeParen',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class ArrayElement extends Node {

    /** @var Expression|null */
    public $elementKey;

    /** @var Token|null */
    public $arrowToken;

    /** @var Token|null */
    public $byRef;

    /** @var Token|null if this is set for PHP 7.4's array spread operator, then other preceding tokens aren't */
    public $dotDotDot;

    /** @var Expression */
    public $elementValue;

    const CHILD_NAMES = [
        'elementKey',
        'arrowToken',
        'byRef',
        'dotDotDot',
        'elementValue'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Token;

class PrefixUpdateExpression extends UnaryExpression {

    /** @var Token */
    public $incrementOrDecrementOperator;

    /** @var Variable */
    public $operand;

    const CHILD_NAMES = [
        'incrementOrDecrementOperator',
        'operand'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class CompoundStatementNode extends StatementNode {
    /** @var Token */
    public $openBrace;

    /** @var array|Node[] */
    public $statements;

    /** @var Token */
    public $closeBrace;

    const CHILD_NAMES = [
        'openBrace',
        'statements',
        'closeBrace'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\ArrayElement;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class YieldExpression extends Expression {
    /** @var Token */
    public $yieldOrYieldFromKeyword;

    /** @var ArrayElement */
    public $arrayElement;

    const CHILD_NAMES = ['yieldOrYieldFromKeyword', 'arrayElement'];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\ElseClauseNode;
use Microsoft\PhpParser\Node\ElseIfClauseNode;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class IfStatementNode extends StatementNode {
    /** @var Token */
    public $ifKeyword;
    /** @var Token */
    public $openParen;
    /** @var Expression */
    public $expression;
    /** @var Token */
    public $closeParen;
    /** @var Token|null */
    public $colon;
    /** @var StatementNode|StatementNode[] */
    public $statements;
    /** @var ElseIfClauseNode[] */
    public $elseIfClauses;
    /** @var ElseClauseNode|null */
    public $elseClause;
    /** @var Token|null */
    public $endifKeyword;
    /** @var Token|null */
    public $semicolon;

    const CHILD_NAMES = [
        'ifKeyword',
        'openParen',
        'expression',
        'closeParen',
        'colon',
        'statements',
        'elseIfClauses',
        'elseClause',
        'endifKeyword',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class NamedLabelStatement extends StatementNode {
    /** @var Token */
    public $name;
    /** @var Token */
    public $colon;
    /**
     * @var null this is always null as of 0.0.23
     * TODO: Clean this up in the next major release.
     */
    public $statement;

    const CHILD_NAMES = [
        'name',
        'colon',
        'statement'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\ClassLike;
use Microsoft\PhpParser\NamespacedNameInterface;
use Microsoft\PhpParser\NamespacedNameTrait;
use Microsoft\PhpParser\Node\AttributeGroup;
use Microsoft\PhpParser\Node\InterfaceBaseClause;
use Microsoft\PhpParser\Node\InterfaceMembers;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class InterfaceDeclaration extends StatementNode implements NamespacedNameInterface, ClassLike {
    use NamespacedNameTrait;

    /** @var AttributeGroup[]|null */
    public $attributes;

    /** @var Token */
    public $interfaceKeyword;

    /** @var Token */
    public $name;

    /** @var InterfaceBaseClause|null */
    public $interfaceBaseClause;

    /** @var InterfaceMembers */
    public $interfaceMembers;

    const CHILD_NAMES = [
        'attributes',
        'interfaceKeyword',
        'name',
        'interfaceBaseClause',
        'interfaceMembers'
    ];

    public function getNameParts() : array {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1477; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1477; return [$this->name]; }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class InterfaceBaseClause extends Node {
    /** @var Token */
    public $extendsKeyword;

    /** @var DelimitedList\QualifiedNameList */
    public $interfaceNameList;

    const CHILD_NAMES = [
        'extendsKeyword',
        'interfaceNameList'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class InterfaceMembers extends Node {
    /** @var Token */
    public $openBrace;

    /** @var Node[] */
    public $interfaceMemberDeclarations;

    /** @var Token */
    public $closeBrace;

    const CHILD_NAMES = [
        'openBrace',
        'interfaceMemberDeclarations',
        'closeBrace'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class ForStatement extends StatementNode {
    /** @var Token */
    public $for;
    /** @var Token */
    public $openParen;
    /** @var Expression|null */
    public $forInitializer;
    /** @var Token */
    public $exprGroupSemicolon1;
    /** @var Expression|null */
    public $forControl;
    /** @var Token */
    public $exprGroupSemicolon2;
    /** @var Expression|null */
    public $forEndOfLoop;
    /** @var Token */
    public $closeParen;
    /** @var Token|null */
    public $colon;
    /** @var StatementNode|StatementNode[] */
    public $statements;
    /** @var Token|null */
    public $endFor;
    /** @var Token|null */
    public $endForSemicolon;

    const CHILD_NAMES = [
        'for',
        'openParen',
        'forInitializer',
        'exprGroupSemicolon1',
        'forControl',
        'exprGroupSemicolon2',
        'forEndOfLoop',
        'closeParen',
        'colon',
        'statements',
        'endFor',
        'endForSemicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\QualifiedName;
use Microsoft\PhpParser\Token;

class ScopedPropertyAccessExpression extends Expression {

    /** @var Expression|QualifiedName|Token */
    public $scopeResolutionQualifier;

    /** @var Token */
    public $doubleColon;

    /** @var Token|Variable */
    public $memberName;

    const CHILD_NAMES = [
        'scopeResolutionQualifier',
        'doubleColon',
        'memberName'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class BracedExpression extends Expression {
    /** @var Token */
    public $openBrace;

    /** @var Expression */
    public $expression;

    /** @var Token */
    public $closeBrace;

    const CHILD_NAMES = [
        'openBrace',
        'expression',
        'closeBrace'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class EmptyStatement extends StatementNode {
    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class WhileStatement extends StatementNode {
    /** @var Token */
    public $whileToken;
    /** @var Token */
    public $openParen;
    /** @var Expression */
    public $expression;
    /** @var Token */
    public $closeParen;
    /** @var Token|null */
    public $colon;
    /** @var StatementNode|StatementNode[] */
    public $statements;
    /** @var Token|null */
    public $endWhile;
    /** @var Token|null */
    public $semicolon;

    const CHILD_NAMES = [
        'whileToken',
        'openParen',
        'expression',
        'closeParen',
        'colon',
        'statements',
        'endWhile',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class PostfixUpdateExpression extends Expression {
    /** @var Variable */
    public $operand;

    /** @var Token */
    public $incrementOrDecrementOperator;

    const CHILD_NAMES = [
        'operand',
        'incrementOrDecrementOperator'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\ModifiedTypeInterface;
use Microsoft\PhpParser\ModifiedTypeTrait;
use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class PropertyDeclaration extends Node implements ModifiedTypeInterface {
    use ModifiedTypeTrait;

    /** @var AttributeGroup[]|null */
    public $attributes;

    /** @var Token|null question token for PHP 7.4 type declaration */
    public $questionToken;

    /** @var QualifiedName|Token|null */
    public $typeDeclaration;

    /**
     * @var DelimitedList\QualifiedNameList|null
     * TODO: Unify with typeDeclaration in a future backwards incompatible release
     */
    public $otherTypeDeclarations;

    /** @var DelimitedList\ExpressionList */
    public $propertyElements;

    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'attributes',
        'modifiers',
        'questionToken',
        'typeDeclaration',
        'otherTypeDeclarations',
        'propertyElements',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

/**
 * Use the ModifiedTypeTrait for convenience in order to implement this interface.
 */
interface ModifiedTypeInterface {
    public function hasModifier(int $targetModifier): bool;
    public function isPublic(): bool;
    public function isStatic(): bool;
}
<?php
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser;

trait ModifiedTypeTrait {
    /** @var Token[] */
    public $modifiers;
    
    public function hasModifier(int $targetModifier): bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1484; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1484; if ($this->modifiers === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1478; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1478; return false; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1479; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1479; }

        foreach ($this->modifiers as $modifier) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1482; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1482; if ($modifier->kind === $targetModifier) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1480; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1480; return true; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1481; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1481; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1483; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1483;

        return false;
    }

    /**
     * Convenience method to check for the existence of the "public" modifier.
     * Does not necessarily need to be defined for that type.
     *
     * @return bool
     */
    public function isPublic(): bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1485; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1485; return $this->hasModifier(TokenKind::PublicKeyword); }
    }

    /**
     * Convenience method to check for the existence of the "static" modifier.
     * Does not necessarily need to be defined for that type.
     *
     * @return bool
     */
    public function isStatic(): bool {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1486; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1486; return $this->hasModifier(TokenKind::StaticKeyword); }
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\QualifiedName;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;
use Microsoft\PhpParser\Node\SourceFileNode;

/**
 * @property SourceFileNode $parent
 */
class NamespaceDefinition extends StatementNode {
    /** @var Token */
    public $namespaceKeyword;
    /** @var QualifiedName|null */
    public $name;
    /** @var CompoundStatementNode|Token */
    public $compoundStatementOrSemicolon;

    const CHILD_NAMES = [
        'namespaceKeyword',
        'name',
        'compoundStatementOrSemicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Diagnostic;
use Microsoft\PhpParser\DiagnosticKind;
use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class NamespaceUseDeclaration extends StatementNode {
    /** @var Token */
    public $useKeyword;
    /** @var Token */
    public $functionOrConst;
    /** @var DelimitedList\NamespaceUseClauseList */
    public $useClauses;
    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'useKeyword',
        'functionOrConst',
        'useClauses',
        'semicolon'
    ];

    /**
     * @return Diagnostic|null - Callers should use DiagnosticsProvider::getDiagnostics instead
     * @internal
     * @override
     */
    public function getDiagnosticForNode() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1495; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1495; if (
            $this->useClauses != null
            && \PhpFuzzer\FuzzingContext::traceBlock(1487, \count($this->useClauses->children) > 1)
        ) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1493; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1493; foreach ($this->useClauses->children as $useClause) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1491; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1491; if($useClause instanceof Node\NamespaceUseClause && \PhpFuzzer\FuzzingContext::traceBlock(1488, !is_null($useClause->openBrace))) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1489; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1489; return new Diagnostic(
                        DiagnosticKind::Error,
                        "; expected.",
                        $useClause->getEndPosition(),
                        1
                    ); }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1490; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1490; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1492; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1492; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1494; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1494; }
        return null;
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class NamespaceUseClauseList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class GlobalDeclaration extends StatementNode {

    /** @var Token */
    public $globalKeyword;

    /** @var DelimitedList\VariableNameList */
    public $variableNameList;

    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'globalKeyword',
        'variableNameList',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class VariableNameList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class ScriptInclusionExpression extends Expression {
    /** @var Token */
    public $requireOrIncludeKeyword;
    /** @var Expression */
    public $expression;

    const CHILD_NAMES = [
        'requireOrIncludeKeyword',
        'expression'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\CaseStatementNode;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class SwitchStatementNode extends StatementNode {
    /** @var Token */
    public $switchKeyword;
    /** @var Token */
    public $openParen;
    /** @var Expression */
    public $expression;
    /** @var Token */
    public $closeParen;
    /** @var Token|null */
    public $colon;
    /** @var Token|null */
    public $openBrace;
    /** @var CaseStatementNode[] */
    public $caseStatements;
    /** @var Token|null */
    public $closeBrace;
    /** @var Token|null */
    public $endswitch;
    /** @var Token|null */
    public $semicolon;

    const CHILD_NAMES = [
        'switchKeyword',
        'openParen',
        'expression',
        'closeParen',
        'colon',
        'openBrace',
        'caseStatements',
        'closeBrace',
        'endswitch',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class Parameter extends Node {
    /** @var AttributeGroup[]|null */
    public $attributes;
    /** @var Token|null */
    public $visibilityToken;
    /** @var Token|null */
    public $questionToken;
    /** @var QualifiedName|Token|null */
    public $typeDeclaration;
    /**
     * @var DelimitedList\QualifiedNameList a list of other types, to support php 8 union types while remaining backwards compatible.
     * TODO: Merge with typeDeclaration in a future backwards incompatible release.
     */
    public $otherTypeDeclarations;
    /** @var Token|null */
    public $byRefToken;
    /** @var Token|null */
    public $dotDotDotToken;
    /** @var Token */
    public $variableName;
    /** @var Token|null */
    public $equalsToken;
    /** @var null|Expression */
    public $default;

    const CHILD_NAMES = [
        'attributes',
        'visibilityToken',
        'questionToken',
        'typeDeclaration',
        'otherTypeDeclarations',
        'byRefToken',
        'dotDotDotToken',
        'variableName',
        'equalsToken',
        'default'
    ];

    public function isVariadic() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1496; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1496; return $this->byRefToken !== null; }
    }

    public function getName() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1500; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1500; if (
            $this->variableName instanceof Token &&
            \PhpFuzzer\FuzzingContext::traceBlock(1497, $name = substr($this->variableName->getText($this->getFileContents()), 1))
        ) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1498; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1498; return $name; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1499; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1499; }
        return null;
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class QualifiedNameList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class ExitIntrinsicExpression extends Expression {

    /** @var Token */
    public $exitOrDieKeyword;

    /** @var Token|null */
    public $openParen;

    /** @var Expression|null */
    public $expression;

    /** @var Token|null */
    public $closeParen;

    const CHILD_NAMES = [
        'exitOrDieKeyword',
        'openParen',
        'expression',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class TraitUseClause extends Node {
    /** @var Token */
    public $useKeyword;

    /** @var DelimitedList\QualifiedNameList */
    public $traitNameList;

    /** @var Token */
    public $semicolonOrOpenBrace;

    /** @var DelimitedList\TraitSelectOrAliasClauseList */
    public $traitSelectAndAliasClauses;

    /** @var Token */
    public $closeBrace;

    const CHILD_NAMES = [
        'useKeyword',
        'traitNameList',
        'semicolonOrOpenBrace',
        'traitSelectAndAliasClauses',
        'closeBrace'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class TraitSelectOrAliasClauseList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\CatchClause;
use Microsoft\PhpParser\Node\FinallyClause;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class TryStatement extends StatementNode {
    /** @var Token */
    public $tryKeyword;
    /** @var StatementNode */
    public $compoundStatement;
    /** @var CatchClause[]|null */
    public $catchClauses;
    /** @var FinallyClause|null */
    public $finallyClause;

    const CHILD_NAMES = [
        'tryKeyword',
        'compoundStatement',
        'catchClauses',
        'finallyClause'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class EmptyIntrinsicExpression extends Expression {

    /** @var Token */
    public $emptyKeyword;

    /** @var Token */
    public $openParen;

    /** @var Expression */
    public $expression;

    /** @var Token */
    public $closeParen;

    const CHILD_NAMES = [
        'emptyKeyword',
        'openParen',
        'expression',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Diagnostic;
use Microsoft\PhpParser\DiagnosticKind;
use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;
use Microsoft\PhpParser\TokenKind;

class BreakOrContinueStatement extends StatementNode {
    /** @var Token */
    public $breakOrContinueKeyword;
    /** @var Expression|null */
    public $breakoutLevel;
    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'breakOrContinueKeyword',
        'breakoutLevel',
        'semicolon'
    ];

    /**
     * @return Diagnostic|null - Callers should use DiagnosticsProvider::getDiagnostics instead
     * @internal
     * @override
     */
    public function getDiagnosticForNode() {
        { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1518; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1518; if ($this->breakoutLevel === null) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1501; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1501; return null; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1502; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1502; }

        $breakoutLevel = $this->breakoutLevel;
        while ($breakoutLevel instanceof Node\Expression\ParenthesizedExpression) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1503; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1503; $breakoutLevel = $breakoutLevel->expression; }
        }

        if (
            $breakoutLevel instanceof Node\NumericLiteral
            && \PhpFuzzer\FuzzingContext::traceBlock(1504, $breakoutLevel->children->kind === TokenKind::IntegerLiteralToken)
        ) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1513; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1513; $literalString = $breakoutLevel->getText(); }
            $firstTwoChars = \substr($literalString, 0, 2);

            if ($firstTwoChars === '0b' || \PhpFuzzer\FuzzingContext::traceBlock(1505, $firstTwoChars === '0B')) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1511; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1511; if (\bindec(\substr($literalString, 2)) > 0) {
                    { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1506; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1506; return null; }
                } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1507; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1507; }
            }
            else { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1510; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1510; if (\intval($literalString, 0) > 0) {
                { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1508; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1508; return null; }
            } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1509; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1509; $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1512; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1512; }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1514; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1514;

        if ($breakoutLevel instanceof Token) {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1516; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1516; $start = $breakoutLevel->getStartPosition(); }
        }
        else {
            { $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1515; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1515; $start = $breakoutLevel->getStart(); }
        } $___key = (\PhpFuzzer\FuzzingContext::$prevBlock << 28) | 1517; \PhpFuzzer\FuzzingContext::$edges[$___key] = (\PhpFuzzer\FuzzingContext::$edges[$___key] ?? 0) + 1; \PhpFuzzer\FuzzingContext::$prevBlock = 1517;
        $end = $breakoutLevel->getEndPosition();

        return new Diagnostic(
            DiagnosticKind::Error,
            "Positive integer literal expected.",
            $start,
            $end - $start
        );
    }
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Token;

class NamespaceUseClause extends Node {
    /** @var QualifiedName */
    public $namespaceName;
    /** @var NamespaceAliasingClause */
    public $namespaceAliasingClause;
    /** @var Token|null */
    public $openBrace;
    /** @var DelimitedList\NamespaceUseGroupClauseList|null */
    public $groupClauses;
    /** @var Token|null */
    public $closeBrace;

    const CHILD_NAMES = [
        'namespaceName',
        'namespaceAliasingClause',
        'openBrace',
        'groupClauses',
        'closeBrace'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class ReturnStatement extends StatementNode {
    /** @var Token */
    public $returnKeyword;
    /** @var Expression|null */
    public $expression;
    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'returnKeyword',
        'expression',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class CloneExpression extends Expression {

    /** @var Token */
    public $cloneKeyword;

    /** @var Expression */
    public $expression;

    const CHILD_NAMES = [
        'cloneKeyword',
        'expression'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

// TODO: Remove this and replace with ThrowExpression in a backwards incompatible major release
class ThrowStatement extends StatementNode {
    /** @var Token */
    public $throwKeyword;
    /** @var Expression */
    public $expression;
    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'throwKeyword',
        'expression',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class ConstDeclaration extends StatementNode {
    /** @var Token */
    public $constKeyword;

    /** @var DelimitedList\ConstElementList */
    public $constElements;

    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'constKeyword',
        'constElements',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class ConstElementList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class DeclareStatement extends StatementNode {
    /** @var Token */
    public $declareKeyword;
    /** @var Token */
    public $openParen;
    /** @var Node */
    public $declareDirective;
    /** @var DelimitedList\DeclareDirectiveList|null TODO: Merge with $declareDirective in a future backwards incompatible release. */
    public $otherDeclareDirectives;
    /** @var Token */
    public $closeParen;
    /** @var Token|null */
    public $colon;
    /** @var StatementNode|StatementNode[] */
    public $statements;
    /** @var Token|null */
    public $enddeclareKeyword;
    /** @var Token|null */
    public $semicolon;

    const CHILD_NAMES = [
        'declareKeyword',
        'openParen',
        'declareDirective',
        'otherDeclareDirectives',
        'closeParen',
        'colon',
        'statements',
        'enddeclareKeyword',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class DeclareDirectiveList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class DeclareDirective extends Node {
    /** @var Token */
    public $name;
    /** @var Token */
    public $equals;
    /** @var Token */
    public $literal;

    const CHILD_NAMES = [
        'name',
        'equals',
        'literal'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class FunctionStaticDeclaration extends StatementNode {

    /** @var Token */
    public $staticKeyword;

    /** @var DelimitedList\StaticVariableNameList */
    public $staticVariableNameList;

    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'staticKeyword',
        'staticVariableNameList',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class StaticVariableNameList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class PrintIntrinsicExpression extends Expression {

    /** @var Token */
    public $printKeyword;

    /** @var Expression */
    public $expression;

    const CHILD_NAMES = [
        'printKeyword',
        'expression'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class UnsetIntrinsicExpression extends Expression {

    /** @var Token */
    public $unsetKeyword;

    /** @var Token */
    public $openParen;

    /** @var DelimitedList\ExpressionList */
    public $expressions;

    /** @var Token */
    public $closeParen;

    const CHILD_NAMES = [
        'unsetKeyword',
        'openParen',
        'expressions',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\FunctionLike;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Node\FunctionBody;
use Microsoft\PhpParser\Node\FunctionHeader;
use Microsoft\PhpParser\Node\FunctionReturnType;
use Microsoft\PhpParser\Node\FunctionUseClause;
use Microsoft\PhpParser\Token;

class AnonymousFunctionCreationExpression extends Expression implements FunctionLike {
    /** @var Token|null */
    public $staticModifier;

    use FunctionHeader, FunctionUseClause, FunctionReturnType, FunctionBody;

    const CHILD_NAMES = [
        'attributes',
        'staticModifier',

        // FunctionHeader
        'functionKeyword',
        'byRefToken',
        'name',
        'openParen',
        'parameters',
        'closeParen',

        // FunctionUseClause
        'anonymousFunctionUseClause',

        // FunctionReturnType
        'colonToken',
        'questionToken',
        'returnType',
        'otherReturnTypes',

        // FunctionBody
        'compoundStatementOrSemicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

trait FunctionUseClause {
    /** @var AnonymousFunctionUseClause|null */
    public $anonymousFunctionUseClause;
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\Node\Statement\CompoundStatementNode;
use Microsoft\PhpParser\Token;

trait FunctionBody {
    /** @var CompoundStatementNode|Token */
    public $compoundStatementOrSemicolon;
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\MissingToken;
use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Node\DelimitedList\UseVariableNameList;
use Microsoft\PhpParser\Token;

class AnonymousFunctionUseClause extends Node {
    /** @var Token */
    public $useKeyword;

    /** @var Token */
    public $openParen;

    /** @var UseVariableNameList|MissingToken */
    public $useVariableNameList;

    /** @var Token */
    public $closeParen;

    const CHILD_NAMES = [
        'useKeyword',
        'openParen',
        'useVariableNameList',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Expression;

use Microsoft\PhpParser\Node\DelimitedList;
use Microsoft\PhpParser\Node\Expression;
use Microsoft\PhpParser\Token;

class ListIntrinsicExpression extends Expression {

    /** @var Token */
    public $listKeyword;

    /** @var Token */
    public $openParen;

    /** @var DelimitedList\ListExpressionList */
    public $listElements;

    /** @var Token */
    public $closeParen;

    const CHILD_NAMES = [
        'listKeyword',
        'openParen',
        'listElements',
        'closeParen'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\DelimitedList;

use Microsoft\PhpParser\Node\DelimitedList;

class ListExpressionList extends DelimitedList {
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node\Statement;

use Microsoft\PhpParser\Node\StatementNode;
use Microsoft\PhpParser\Token;

class GotoStatement extends StatementNode {
    /** @var Token */
    public $goto;
    /** @var Token */
    public $name;
    /** @var Token */
    public $semicolon;

    const CHILD_NAMES = [
        'goto',
        'name',
        'semicolon'
    ];
}
<?php
/*---------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

namespace Microsoft\PhpParser\Node;

use Microsoft\PhpParser\ModifiedTypeInterface;
use Microsoft\PhpParser\ModifiedTypeTrait;
use Microsoft\PhpParser\Node;
use Microsoft\PhpParser\Token;

class MissingMemberDeclaration extends Node implements ModifiedTypeInterface {
    use ModifiedTypeTrait;

    /** @var AttributeGroup[]|null */
    public $attributes;

    /** @var Token|null needed along with typeDeclaration for what looked like typed property declarations but was missing VariableName */
    public $questionToken;

    /** @var QualifiedName|Token|null */
    public $typeDeclaration;

    /** @var DelimitedList\QualifiedNameList|null */
    public $otherTypeDeclarations;

    const CHILD_NAMES = [
        'attributes',
        'modifiers',
        'questionToken',
        'typeDeclaration',
        'otherTypeDeclarations',
    ];
}
